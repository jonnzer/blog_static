{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/gandalfr/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/gandalfr/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/gandalfr/source/css/gandalfr.css","path":"css/gandalfr.css","modified":0,"renderable":1},{"_id":"themes/gandalfr/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":0,"renderable":1},{"_id":"themes/gandalfr/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":0,"renderable":1},{"_id":"themes/gandalfr/source/scss/gandalfr.scss","path":"scss/gandalfr.scss","modified":0,"renderable":1},{"_id":"themes/gandalfr/source/js/Valine.min.js","path":"js/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/gandalfr/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"6c839117491ccb4ebb1a418f58a8f20978a7d39b","modified":1595676059086},{"_id":"themes/gandalfr/.gitignore","hash":"def5f0c9ac6f013028d5b4e9938cbd679cb1c4bf","modified":1595133478812},{"_id":"themes/gandalfr/LICENSE","hash":"e80157fea03e4ee45500ea818fceaf6ca388c17d","modified":1595133478812},{"_id":"themes/gandalfr/README.md","hash":"21dada770ee802d34b5489761891075705f06ad2","modified":1595133478812},{"_id":"themes/gandalfr/TODO.md","hash":"c20ea4cb6aec891d53fc60707f6102e049e7955c","modified":1595133478812},{"_id":"themes/gandalfr/gulpfile.js","hash":"cb1123f7f21b8d37a651599f2f40b7bc4d11963b","modified":1595133478813},{"_id":"themes/gandalfr/_config.yml","hash":"8c89f6bbd4fc1e22dc7917e89e0c50729938b9a2","modified":1595302862520},{"_id":"themes/gandalfr/_config.yml.example","hash":"b651f982ee554ef597451e07e6f8c86048d0cade","modified":1595133478813},{"_id":"themes/gandalfr/package.json","hash":"cc67f61b1a8c216952e48d6ab081b80e6f399516","modified":1595133478817},{"_id":"source/_posts/.DS_Store","hash":"08fd6ee02f6af514077b9d118a6b89208e39c00f","modified":1595676059085},{"_id":"source/_posts/AST.md","hash":"17ac18999a07a8d939d53b1d5ac369ba4692ee9f","modified":1594486722969},{"_id":"source/_posts/CSS_review.md","hash":"a42022ef442ccd797cf405ff3f918fb0560ccc85","modified":1586707783327},{"_id":"source/_posts/ES2019新属性.md","hash":"b52fddfe4fb070c3bdbbd1a9c51d563ef9c4fe18","modified":1595237800268},{"_id":"source/_posts/JS执行顺序.md","hash":"90fba9750555685d6e149cab890d627186574b8b","modified":1595741989843},{"_id":"source/_posts/JS模块化.md","hash":"7d2b8bdfcfaeb7aab78dc304855f34154160d99e","modified":1595501548184},{"_id":"source/_posts/H5-insertAdjacentElement.md","hash":"0984da60630c5768c348e2e45ba1a7ded81dc804","modified":1552834482925},{"_id":"source/_posts/MVVM.md","hash":"1a29b721aad1198fc2ec6e0e4abfec89a84048b8","modified":1595676681547},{"_id":"source/_posts/apollo主题增加Valine评论.md","hash":"988583a7ae81b6f3a8da52bf0df7348ed1bf4ca7","modified":1594631896418},{"_id":"source/_posts/call&apply&bind.md","hash":"810c0a533310f62abca822619b38ed05ae86ff26","modified":1594571417672},{"_id":"source/_posts/array.md","hash":"5c31e28d5da74155f8959f02aa1e01c8fec574ee","modified":1594977219569},{"_id":"source/_posts/nginx科普章.md","hash":"b2df053163de62639f8c89cf195b21380ee370b4","modified":1529223214814},{"_id":"source/_posts/sql.md","hash":"9a2f94b0eccd846b3dc0f2eee0f133ab28d227ae","modified":1528518800468},{"_id":"source/_posts/PWA.md","hash":"359ec5acac3d637d43dba9fc4c56909fe4c1eb6b","modified":1584002869650},{"_id":"source/_posts/proxy.md","hash":"5a9b367527005ca37f811af3d8702878310b90f9","modified":1592375705022},{"_id":"source/_posts/vue源码分析.md","hash":"c6fc149c874d91461d366a8d988e2cdc24cc63a3","modified":1594012249346},{"_id":"source/_posts/upload.md","hash":"41321a489f3ce5b78b5c4bb18cf5915ba159dc11","modified":1515674164083},{"_id":"source/_posts/test.md","hash":"a8ea7350904ed2f1b376fcbe0dc2dd111e9ca07a","modified":1595501558649},{"_id":"source/_posts/偏函数.md","hash":"acdfb8d50ef3936dbb3b9e2caa1265666b6f7595","modified":1593696148729},{"_id":"source/_posts/克隆对象&&数组（一）.md","hash":"7e80a53f24582c87d86365126da2dad50cbf1dc1","modified":1594726391129},{"_id":"source/_posts/webpack.md","hash":"10ac096f09b0726c0f64ff270a0385db63dd2df7","modified":1578118396810},{"_id":"source/_posts/函数柯里化.md","hash":"24bb7fd29795188c92c55130ddd3e2fc085cafe8","modified":1594818799032},{"_id":"source/_posts/复制内容.md","hash":"850249c840a8f990d52c309b00316255e8f6e19f","modified":1552833425542},{"_id":"source/_posts/合成图片.md","hash":"33409515e874e0bf4e67cb5376e1a261415ae2b3","modified":1552721547018},{"_id":"source/_posts/克隆对象&&数组（二）.md","hash":"0552e071e6881a1ee95a089cf75b5e4416ba16e6","modified":1594826471023},{"_id":"source/_posts/小程序入门篇.md","hash":"4e176ac2c8e3a7a213d09d6cb2834d3e2f6f4104","modified":1575342847086},{"_id":"source/_posts/数组去重.md","hash":"77a4af56d6ea8367264b502d0c0c6d45adb1b589","modified":1552739343159},{"_id":"source/_posts/浏览器-输入url操作篇.md","hash":"1d7dd2bc650c24866d6e29c3ccba669c64aec389","modified":1595300709751},{"_id":"source/_posts/浏览器异步（一）.md","hash":"e593c453396de0a55c71b4ba5eec49680db4f216","modified":1595248022280},{"_id":"source/_posts/浏览器异步（二）.md","hash":"b784e6c0aa8b9bf8b9c0e2d20b1d4307adc11424","modified":1595235065190},{"_id":"source/_posts/移动端.md","hash":"eb77cec5647fb24c5b2c8e3507991f67bbfa6383","modified":1543126424668},{"_id":"source/_posts/浏览器异步（三）之Promise实现.md","hash":"4d940fb784a4fea96f916cb2f637e3504c3ce99d","modified":1595247987638},{"_id":"source/_posts/移动端拖拽.md","hash":"48342d72c94af171ba04c8705e196c808ed8a644","modified":1552744284870},{"_id":"source/_posts/算法.md","hash":"af04ccd5b86365203f4a15f7ec14242978a5f76a","modified":1594829956931},{"_id":"source/_posts/继承.md","hash":"2619549589c6b3f38468bc536d9bdc93a6796654","modified":1594997730155},{"_id":"source/_posts/请回答1988.md","hash":"c478c45b0771c9c01803179e88f58a59781feef7","modified":1586521225418},{"_id":"source/_posts/重绘&&重排.md","hash":"4b0dcee3eee6524ade7d4ba24005ddcbf93467a0","modified":1595305236440},{"_id":"source/_posts/面试要求.md","hash":"c17473a7da352885a6ffcbe91a74ce960e4fd865","modified":1594746379763},{"_id":"source/_posts/防抖与节流.md","hash":"937c794a421e78ef6c8c127ab679e0dad9cfe7ea","modified":1594546586390},{"_id":"themes/gandalfr/languages/zh-cn.yml","hash":"9e4b03e14c094000257ea254fd660dde4c7af63c","modified":1595133478813},{"_id":"themes/gandalfr/layout/archive.jade","hash":"080d5a393f086b18f279a6b32ad161d441a7edf3","modified":1595133478813},{"_id":"themes/gandalfr/languages/en.yml","hash":"40292f2a48e4e6361132033a47c516cb33127b6c","modified":1595133478813},{"_id":"themes/gandalfr/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1595133478814},{"_id":"themes/gandalfr/source/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1595142771408},{"_id":"themes/gandalfr/layout/post.jade","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1595133478815},{"_id":"themes/gandalfr/package-lock.json","hash":"dc45fa0fa6c4fee2a3b27c11e5bdb8839a80a312","modified":1595133478816},{"_id":"themes/gandalfr/source/favicon.ico","hash":"ff97e9eeb291dcd407982d438f482280aa25a6d9","modified":1595133478817},{"_id":"themes/gandalfr/layout/mixins/paginator.jade","hash":"deab5182dfccbf88aeca2e3a8abc638b8f988178","modified":1595742046420},{"_id":"themes/gandalfr/layout/partial/copyright.jade","hash":"3f2a357c9d4861386f81d97a97cde9b6817e35cc","modified":1595133478814},{"_id":"themes/gandalfr/layout/mixins/post.jade","hash":"4475dd99479cb6c2a122b0fe353e451e4a056575","modified":1595133478814},{"_id":"themes/gandalfr/layout/partial/head.jade","hash":"f6f8623fca88fb94c5aca8999fc4f0b6396c0790","modified":1595147153502},{"_id":"themes/gandalfr/layout/partial/comment.jade","hash":"a9d832ce5e52edaada88a2c36b619c2c981ce31a","modified":1595145267232},{"_id":"themes/gandalfr/layout/partial/layout.jade","hash":"d28fa3c39fca9624a87e7e83736cf2509dc14a43","modified":1595133478815},{"_id":"themes/gandalfr/source/css/gandalfr.css","hash":"aa0d08732cab3e94f26a789c36012302d89d9d5f","modified":1595303835959},{"_id":"themes/gandalfr/layout/partial/nav.jade","hash":"f4842d9d3d763fbb823d112a6f49f24cc42a0ad4","modified":1595133478815},{"_id":"themes/gandalfr/layout/partial/scripts.jade","hash":"9d3b303dcd6a94ddc1003a07569252c803983576","modified":1595147378678},{"_id":"themes/gandalfr/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1595133478818},{"_id":"themes/gandalfr/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1595133478818},{"_id":"themes/gandalfr/source/scss/gandalfr.scss","hash":"eb7e4dd5949defa1795b90d8ff5e09f553cea53d","modified":1595133478820},{"_id":"themes/gandalfr/source/scss/_partial/archive-post-list.scss","hash":"b173328f07795f64769fe552b5c2749f4159d050","modified":1595133478818},{"_id":"themes/gandalfr/source/scss/_partial/base.scss","hash":"a9a624a14d593ec986cc5d7eada07394f57be41d","modified":1595133478818},{"_id":"themes/gandalfr/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1595133478819},{"_id":"themes/gandalfr/source/scss/_partial/mq.scss","hash":"826ad88815e2ae0d4e92f9ddb35e2a6f5cc6836d","modified":1595133478819},{"_id":"themes/gandalfr/source/scss/_partial/footer.scss","hash":"e331ac53e339eea7e09fc7ef8072bf36db682a9e","modified":1595133478819},{"_id":"themes/gandalfr/source/scss/_partial/header.scss","hash":"0491d194e0f3bd927869f0a6b190624d5ff16c92","modified":1595133478819},{"_id":"themes/gandalfr/source/scss/_partial/home-post-list.scss","hash":"0021e88b04c51aca45627272bc7e3584ba2480b9","modified":1595133478819},{"_id":"themes/gandalfr/source/scss/_partial/post.scss","hash":"69da5e30b1634d2b9647ffafe521aaa26778ca54","modified":1595133478820},{"_id":"themes/gandalfr/source/js/Valine.min.js","hash":"b64fbb45ba5495e16013b7d3d114071eb10c16aa","modified":1595145206854},{"_id":"themes/gandalfr/source/scss/_partial/normalize.scss","hash":"c6fdc91342b36e04d97a17a3d71610cf46de0aca","modified":1595133478819},{"_id":"source/_posts/MVVM/MVVM5.png","hash":"f9235f82e71ac8fe38bbf47d8eb8ffa7e032907e","modified":1595675961000},{"_id":"themes/gandalfr/source/js/jquery.js","hash":"38e82b4f24bf9f7e678a1d69a4e635363ce711ab","modified":1595146939885},{"_id":"source/_posts/MVVM/MVVM2.png","hash":"f56f2f37c9bb7e31ff1d7e9bf7b26dac4421dd38","modified":1595509658000},{"_id":"source/_posts/MVVM/MVVM3.png","hash":"79c54a2d1ad7a38c105a953ea6b3346772c27f35","modified":1595675859000},{"_id":"source/_posts/MVVM/MVVM1.png","hash":"095eec2828cec8fcd6557facb2e15ee862919dd0","modified":1595509621000},{"_id":"source/_posts/重绘&&重排/重绘重排4.png","hash":"bda64a6d17a6ecaec387849eb8fc8f7e901c1d87","modified":1595301271431},{"_id":"source/_posts/重绘&&重排/重绘重排2.png","hash":"65be5de8e44ca71a17881c87dd2f792439e32c51","modified":1595301271326},{"_id":"source/_posts/重绘&&重排/重绘重排1.png","hash":"c7e007486705911be61bb3f3da99b905ed01e52c","modified":1595301271268},{"_id":"source/_posts/MVVM/MVVM4.png","hash":"ac3c744f4dfedf459b893e362415e00460e3252e","modified":1595675897000},{"_id":"source/_posts/重绘&&重排/重绘重排3.png","hash":"18b70aad89748a9839a7e25954c2324d1a5fb02c","modified":1595301271382},{"_id":"public/atom.xml","hash":"f0f1cb52f37a26e4b76bdd5c6b17f4ece08a40c4","modified":1595742076141},{"_id":"public/sitemap.xml","hash":"33bfe943976f5353f39f62e3585277d4add001a9","modified":1595742076141},{"_id":"public/2020/07/20/重绘&&重排/index.html","hash":"29da92ad23754698e96057ad773e8207a481625c","modified":1595742076141},{"_id":"public/2020/07/20/ES2019新属性/index.html","hash":"8fa14e7a77dc829870ee4292d0655f623f5604c4","modified":1595742076141},{"_id":"public/2020/07/18/浏览器异步（二）/index.html","hash":"edab95e272b4a4b21f00005a3f90546e0479ff1a","modified":1595742076141},{"_id":"public/2020/07/15/算法/index.html","hash":"00726cfd5c0d301c6d7f32de85e706ec02de77ad","modified":1595742076141},{"_id":"public/2020/07/13/克隆对象&&数组（一）/index.html","hash":"4667191d5db7c410c46a0589b4fee8fd4836667f","modified":1595742076141},{"_id":"public/2020/07/11/apollo主题增加Valine评论/index.html","hash":"ea6335c7057401a4ff5c698701c3206fea2dfcb3","modified":1595742076141},{"_id":"public/2020/07/03/AST/index.html","hash":"87556d155fa51e711913e1194d069e125e286534","modified":1595742076141},{"_id":"public/2020/07/03/test/index.html","hash":"bb4199de981699df11c9d69e64a21d0f446708ce","modified":1595742076141},{"_id":"public/2020/07/02/偏函数/index.html","hash":"f446d03104079b16f112f78deed8862f57cd9f15","modified":1595742076141},{"_id":"public/2020/04/27/vue源码分析/index.html","hash":"ed36b356333ea1ae9590468bf4e9af728dd536f7","modified":1595742076141},{"_id":"public/2020/04/12/面试要求/index.html","hash":"38c479cd9a1e61246fc974d360375e768df0bd7e","modified":1595742076141},{"_id":"public/2020/04/08/CSS_review/index.html","hash":"2317f388ffb100084a88d67cc2c20397e58eb2ff","modified":1595742076141},{"_id":"public/2020/03/13/浏览器-输入url操作篇/index.html","hash":"ba1f39e7070671a8aae80d4e61f40e5326b8a89e","modified":1595742076141},{"_id":"public/2020/02/06/PWA/index.html","hash":"596eba308e4fbefaedf80f4906cff1dacd052f7b","modified":1595742076141},{"_id":"public/2019/12/11/webpack/index.html","hash":"97f73e9e52f24859a26d91338abbae4343c11ee7","modified":1595742076141},{"_id":"public/2019/12/03/JS执行顺序/index.html","hash":"f24ee1773443588f3479e29593a74014495435c4","modified":1595742076141},{"_id":"public/2019/12/03/防抖与节流/index.html","hash":"1563aaf2bdbd1647ea32f051ac3266da42b054aa","modified":1595742076141},{"_id":"public/2019/08/05/小程序入门篇/index.html","hash":"52dd930227735cb77f740f72e4d8d294e00fda83","modified":1595742076141},{"_id":"public/2019/04/06/请回答1988/index.html","hash":"8ace0c6fbfe06752a2cf06a69896c5c69efecc25","modified":1595742076141},{"_id":"public/2019/03/11/H5-insertAdjacentElement/index.html","hash":"e299dad6471947f6747455a704f83153a73dfaa9","modified":1595742076141},{"_id":"public/2019/03/02/复制内容/index.html","hash":"98a8bea51818ea8fd93b85ab7c68fdbd144875d4","modified":1595742076141},{"_id":"public/2019/02/25/移动端拖拽/index.html","hash":"04926a1a509e738c4fbc70ff31c08a8b75fa9e14","modified":1595742076141},{"_id":"public/2019/02/25/数组去重/index.html","hash":"ffb3fdc4fec796e96b9d397daef6e4ee79f7a283","modified":1595742076141},{"_id":"public/2019/02/15/合成图片/index.html","hash":"4e6a7401832fb983246a4c7042362ae279983bf7","modified":1595742076141},{"_id":"public/2018/11/03/移动端/index.html","hash":"53c2836f135c9f0122f4a19d79de47f70947f083","modified":1595742076141},{"_id":"public/2018/06/17/nginx科普章/index.html","hash":"a19bfe55432747f31ea94880b6fb506934e8064a","modified":1595742076141},{"_id":"public/2018/05/02/sql/index.html","hash":"f331d70987b67e303a2e3bb715599c59e586bb4c","modified":1595742076141},{"_id":"public/2018/01/04/upload/index.html","hash":"6ef7c5689df612e11f668f840572991c92b2de37","modified":1595742076141},{"_id":"public/archives/index.html","hash":"f008c080a20f75e080d51aefe44ecf935be18810","modified":1595742076141},{"_id":"public/index.html","hash":"534f721a903a053580901f886b0745d681078c3b","modified":1595742076141},{"_id":"public/page/2/index.html","hash":"d92d9ba3a83bd30a685f0947e56d6cfa325d6a66","modified":1595742076141},{"_id":"public/page/3/index.html","hash":"4d8bd618cd5265dea5938c8d3946f79f409fd5ee","modified":1595742076141},{"_id":"public/page/4/index.html","hash":"a0a9d11292e6a982124cac69ab5e45d4f82c1b75","modified":1595742076141},{"_id":"public/tags/ES-JS/index.html","hash":"5e7f54bba7249fd6d1b6447269cfa10c4ee0f043","modified":1595742076141},{"_id":"public/tags/面试/index.html","hash":"9abe812a5ec86090d9ce4cdf689d9532c4751a34","modified":1595742076141},{"_id":"public/tags/JS原理/index.html","hash":"8aa7b81cfae680963270712933dc12b473c5b891","modified":1595742076141},{"_id":"public/tags/H5/index.html","hash":"131f1292b22e8c2fc160043c46b5fb3234859921","modified":1595742076141},{"_id":"public/tags/Apollo-Hexo-Valine/index.html","hash":"da4306be463baabf446387e939b987284acf0c3c","modified":1595742076141},{"_id":"public/tags/MVVM-框架/index.html","hash":"c5f529a6c07e1418d4de69e638b4a8934e8a8f19","modified":1595742076141},{"_id":"public/tags/面试-JS/index.html","hash":"b8c9b96a44287854b9b2f564aeb3ba9c8cd3e9ad","modified":1595742076141},{"_id":"public/tags/Array/index.html","hash":"35568da426d20b196b955688446f3acfc116bdac","modified":1595742076141},{"_id":"public/tags/nginx/index.html","hash":"41193832d6436cc229cd1018abe23d0dc1980fa0","modified":1595742076141},{"_id":"public/tags/模块化/index.html","hash":"97a97c0e2af940b5b90fd695fe305f73b8eb29ea","modified":1595742076141},{"_id":"public/tags/工具/index.html","hash":"a745f12266f3f728cec62f3f026d4f00378e6323","modified":1595742076141},{"_id":"public/tags/sql/index.html","hash":"d13772360cf790508ab6dfd0e3f1a0c3c2cba3a3","modified":1595742076141},{"_id":"public/tags/ES6/index.html","hash":"fc38b73d59757c1229b4988579b3e3ac88ad432b","modified":1595742076141},{"_id":"public/tags/vue/index.html","hash":"debea26501a88a5d47e42f15d1f5af7db56fa94a","modified":1595742076141},{"_id":"public/tags/upload/index.html","hash":"908b5bc24bb409dfae49d37c19adb6824b9cdded","modified":1595742076141},{"_id":"public/tags/JS/index.html","hash":"4e218bc0363cd484629320079cba6d235de3aac6","modified":1595742076141},{"_id":"public/tags/JS-拷贝/index.html","hash":"e3c16ebd75d065b6297f0f5f301a8862cd9fe632","modified":1595742076141},{"_id":"public/tags/工具-webpack/index.html","hash":"6f2675cb82418275c2997f015c1c904e9e7f16b9","modified":1595742076141},{"_id":"public/tags/小程序/index.html","hash":"a6e80da74316b94ef1c8bdcd3f959a66ec7a71bb","modified":1595742076141},{"_id":"public/tags/浏览器/index.html","hash":"ae8791da13dcb1a0d94c2fddc8fd216c5b5a4a82","modified":1595742076141},{"_id":"public/tags/Promise-工具/index.html","hash":"cbb8c4fad4b7e067e33cda5d6a7d1f14bc30f8d9","modified":1595742076141},{"_id":"public/tags/移动端/index.html","hash":"3cf81efc1701bf2f9b631d7edb11888f8a0b3f24","modified":1595742076141},{"_id":"public/tags/算法/index.html","hash":"42e115a74836b69acd319af84556bb53eb289c25","modified":1595742076141},{"_id":"public/tags/浏览器-CSS渲染/index.html","hash":"84cdd2f9d1ea9ee3562693a95b9ddfa78611767a","modified":1595742076141},{"_id":"public/tags/随笔/index.html","hash":"71c8f1b791c87be50f3492355c818ff625bc427e","modified":1595742076141},{"_id":"public/tags/JS优化/index.html","hash":"1e0f5327a04115b6ac90ea4c6a3882724b256ec9","modified":1595742076141},{"_id":"public/2020/07/23/MVVM/index.html","hash":"93626153b345515d7583b500f272a7de0d252956","modified":1595742076141},{"_id":"public/2020/07/18/浏览器异步（三）之Promise实现/index.html","hash":"3686ad1ee7b0a8e78b8ba2e167de74c9f7e9ab56","modified":1595742076141},{"_id":"public/2020/07/17/浏览器异步（一）/index.html","hash":"348295419c95cb54801bd4edf64b3a7b2dda8be1","modified":1595742076141},{"_id":"public/2020/07/13/克隆对象&&数组（二）/index.html","hash":"f0f49901bbedeecbbcd606b0c6cfca1e9e8e2ba0","modified":1595742076141},{"_id":"public/2020/06/14/proxy/index.html","hash":"48c2f1b69d46152e35bd1b7e1b2c662c59e55e77","modified":1595742076141},{"_id":"public/2020/05/27/函数柯里化/index.html","hash":"097b09d6035cb442c76b718beb4278fa6d6d9145","modified":1595742076141},{"_id":"public/2020/05/26/array/index.html","hash":"3da9dee8d7d7fe15cb0e2c9e5584428b97228ace","modified":1595742076141},{"_id":"public/2020/04/09/call&apply&bind/index.html","hash":"630e0923df98d52df065e4dfebf45c6512f05772","modified":1595742076141},{"_id":"public/2020/04/07/继承/index.html","hash":"7bab67377d347e4303a85ae67cd8f04e348a1d27","modified":1595742076141},{"_id":"public/2020/01/04/JS模块化/index.html","hash":"e0d605c1ffc4195c8e5a278b45cf075636563642","modified":1595742076141},{"_id":"public/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1595742076141},{"_id":"public/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1595742076141},{"_id":"public/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1595742076141},{"_id":"public/scss/gandalfr.scss","hash":"eb7e4dd5949defa1795b90d8ff5e09f553cea53d","modified":1595742076141},{"_id":"public/lib/blog-encrypt.js","hash":"91fda12d550323056762c5408623eb8a1d201ecc","modified":1595742076141},{"_id":"public/css/blog-encrypt.css","hash":"22e25b0d16ea053d25eb971e038c817a4c9cb584","modified":1595742076141},{"_id":"public/favicon.ico","hash":"ff97e9eeb291dcd407982d438f482280aa25a6d9","modified":1595742076141},{"_id":"public/css/gandalfr.css","hash":"aa0d08732cab3e94f26a789c36012302d89d9d5f","modified":1595742076141},{"_id":"public/js/Valine.min.js","hash":"b64fbb45ba5495e16013b7d3d114071eb10c16aa","modified":1595742076141},{"_id":"public/js/jquery.js","hash":"38e82b4f24bf9f7e678a1d69a4e635363ce711ab","modified":1595742076141},{"_id":"public/2020/07/23/MVVM/MVVM5.png","hash":"f9235f82e71ac8fe38bbf47d8eb8ffa7e032907e","modified":1595742076141},{"_id":"public/2020/07/23/MVVM/MVVM2.png","hash":"f56f2f37c9bb7e31ff1d7e9bf7b26dac4421dd38","modified":1595742076141},{"_id":"public/2020/07/23/MVVM/MVVM1.png","hash":"095eec2828cec8fcd6557facb2e15ee862919dd0","modified":1595742076141},{"_id":"public/2020/07/23/MVVM/MVVM3.png","hash":"79c54a2d1ad7a38c105a953ea6b3346772c27f35","modified":1595742076141},{"_id":"public/2020/07/20/重绘&&重排/重绘重排2.png","hash":"65be5de8e44ca71a17881c87dd2f792439e32c51","modified":1595742076141},{"_id":"public/2020/07/20/重绘&&重排/重绘重排4.png","hash":"bda64a6d17a6ecaec387849eb8fc8f7e901c1d87","modified":1595742076141},{"_id":"public/2020/07/20/重绘&&重排/重绘重排1.png","hash":"c7e007486705911be61bb3f3da99b905ed01e52c","modified":1595742076141},{"_id":"public/2020/07/23/MVVM/MVVM4.png","hash":"ac3c744f4dfedf459b893e362415e00460e3252e","modified":1595742076141},{"_id":"public/2020/07/20/重绘&&重排/重绘重排3.png","hash":"18b70aad89748a9839a7e25954c2324d1a5fb02c","modified":1595742076141}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"AST","date":"2020-07-03T09:54:10.000Z","_content":"\nAST 一种语法树<!--more-->\n<div class=\"tip\">\n   tip文案\n</div>\n","source":"_posts/AST.md","raw":"---\ntitle: AST\ndate: 2020-07-03 17:54:10\ntags: \n\n---\n\nAST 一种语法树<!--more-->\n<div class=\"tip\">\n   tip文案\n</div>\n","slug":"AST","published":1,"updated":"2020-07-11T16:58:42.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr950000z5o80tpod0cy","content":"<p>AST 一种语法树<a id=\"more\"></a></p>\n<div class=\"tip\">\n   tip文案\n</div>\n","site":{"data":{}},"excerpt":"<p>AST 一种语法树</p>","more":"<p></p>\n<div class=\"tip\">\n   tip文案\n</div>"},{"title":"ES2019新变化","date":"2020-07-20T09:37:05.000Z","_content":"\n1 数组：\n数组降维：Array.prototype.flat() 递归地将嵌套数组拼合到指定深度 创建新数组，不改原数组\n```js\nconst arr1 = [1, 2, [3, 4]];\narr1.flat(); \n// [1, 2, 3, 4]\n\nconst arr2 = [1, 2, [3, 4, [5, 6]]];\narr2.flat(2); \n// [1, 2, 3, 4, 5, 6]\n\nconst arr3 = [1, 2, [3, 4, [5, 6, [7, 8]]]];\narr3.flat(Infinity); \n// [1, 2, 3, 4, 5, 6, 7, 8]\n```\n\nflat还会移除数组空项\n```js\nconst arr4 = [1, 2, , 4, 5];\narr4.flat(); // [1, 2, 4, 5]\n```\n\n \n2 字符串\n去头去尾： String.prototype.trimStart() 和 String.prototype.trimEnd() 创建新字符串，不修改原字符串\n```js\nconst test = \" hello \";\n\ntest.trim(); // \"hello\";\ntest.trimStart(); // \"hello \";\ntest.trimEnd(); // \" hello\";\n```\n\n\n3 对象\nObject.fromEntries() 数组转对象 \n与之相对应的是Object.entries() 对象转数组\n```js\nconst obj = { prop1: 2, prop2: 10, prop3: 15 };\n\n// 转化为键值对数组：\nlet array = Object.entries(obj); \n// [[\"prop1\", 2], [\"prop2\", 10], [\"prop3\", 15]]\n\narray = array.map(([key, value]) => [key, Math.pow(value, 2)]); \n// [[\"prop1\", 4], [\"prop2\", 100], [\"prop3\", 225]]\n\nconst newObj = Object.fromEntries(array); \n// {prop1: 4, prop2: 100, prop3: 225}\n\n```\n\n参考：\n[瓶子君的blog](https://github.com/sisterAn/blog/issues/47)","source":"_posts/ES2019新属性.md","raw":"---\ntitle: ES2019新变化\ndate: 2020-07-20 17:37:05\ntags: ES JS\n---\n\n1 数组：\n数组降维：Array.prototype.flat() 递归地将嵌套数组拼合到指定深度 创建新数组，不改原数组\n```js\nconst arr1 = [1, 2, [3, 4]];\narr1.flat(); \n// [1, 2, 3, 4]\n\nconst arr2 = [1, 2, [3, 4, [5, 6]]];\narr2.flat(2); \n// [1, 2, 3, 4, 5, 6]\n\nconst arr3 = [1, 2, [3, 4, [5, 6, [7, 8]]]];\narr3.flat(Infinity); \n// [1, 2, 3, 4, 5, 6, 7, 8]\n```\n\nflat还会移除数组空项\n```js\nconst arr4 = [1, 2, , 4, 5];\narr4.flat(); // [1, 2, 4, 5]\n```\n\n \n2 字符串\n去头去尾： String.prototype.trimStart() 和 String.prototype.trimEnd() 创建新字符串，不修改原字符串\n```js\nconst test = \" hello \";\n\ntest.trim(); // \"hello\";\ntest.trimStart(); // \"hello \";\ntest.trimEnd(); // \" hello\";\n```\n\n\n3 对象\nObject.fromEntries() 数组转对象 \n与之相对应的是Object.entries() 对象转数组\n```js\nconst obj = { prop1: 2, prop2: 10, prop3: 15 };\n\n// 转化为键值对数组：\nlet array = Object.entries(obj); \n// [[\"prop1\", 2], [\"prop2\", 10], [\"prop3\", 15]]\n\narray = array.map(([key, value]) => [key, Math.pow(value, 2)]); \n// [[\"prop1\", 4], [\"prop2\", 100], [\"prop3\", 225]]\n\nconst newObj = Object.fromEntries(array); \n// {prop1: 4, prop2: 100, prop3: 225}\n\n```\n\n参考：\n[瓶子君的blog](https://github.com/sisterAn/blog/issues/47)","slug":"ES2019新属性","published":1,"updated":"2020-07-20T09:36:40.268Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr9b0001z5o89tgc2hhe","content":"<p>1 数组：<br>数组降维：Array.prototype.flat() 递归地将嵌套数组拼合到指定深度 创建新数组，不改原数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]];</span><br><span class=\"line\">arr1.flat(); </span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr2 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"number\">5</span>, <span class=\"number\">6</span>]]];</span><br><span class=\"line\">arr2.flat(<span class=\"number\">2</span>); </span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4, 5, 6]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr3 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"number\">5</span>, <span class=\"number\">6</span>, [<span class=\"number\">7</span>, <span class=\"number\">8</span>]]]];</span><br><span class=\"line\">arr3.flat(<span class=\"literal\">Infinity</span>); </span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>\n\n<p>flat还会移除数组空项</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr4 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, , <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">arr4.flat(); <span class=\"comment\">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure>\n\n\n<p>2 字符串<br>去头去尾： String.prototype.trimStart() 和 String.prototype.trimEnd() 创建新字符串，不修改原字符串</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> test = <span class=\"string\">\" hello \"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">test.trim(); <span class=\"comment\">// \"hello\";</span></span><br><span class=\"line\">test.trimStart(); <span class=\"comment\">// \"hello \";</span></span><br><span class=\"line\">test.trimEnd(); <span class=\"comment\">// \" hello\";</span></span><br></pre></td></tr></table></figure>\n\n\n<p>3 对象<br>Object.fromEntries() 数组转对象<br>与之相对应的是Object.entries() 对象转数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">prop1</span>: <span class=\"number\">2</span>, <span class=\"attr\">prop2</span>: <span class=\"number\">10</span>, <span class=\"attr\">prop3</span>: <span class=\"number\">15</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转化为键值对数组：</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> array = <span class=\"built_in\">Object</span>.entries(obj); </span><br><span class=\"line\"><span class=\"comment\">// [[\"prop1\", 2], [\"prop2\", 10], [\"prop3\", 15]]</span></span><br><span class=\"line\"></span><br><span class=\"line\">array = array.map(<span class=\"function\">(<span class=\"params\">[key, value]</span>) =&gt;</span> [key, <span class=\"built_in\">Math</span>.pow(value, <span class=\"number\">2</span>)]); </span><br><span class=\"line\"><span class=\"comment\">// [[\"prop1\", 4], [\"prop2\", 100], [\"prop3\", 225]]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = <span class=\"built_in\">Object</span>.fromEntries(array); </span><br><span class=\"line\"><span class=\"comment\">// &#123;prop1: 4, prop2: 100, prop3: 225&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>参考：<br><a href=\"https://github.com/sisterAn/blog/issues/47\" target=\"_blank\" rel=\"noopener\">瓶子君的blog</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1 数组：<br>数组降维：Array.prototype.flat() 递归地将嵌套数组拼合到指定深度 创建新数组，不改原数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]];</span><br><span class=\"line\">arr1.flat(); </span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr2 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"number\">5</span>, <span class=\"number\">6</span>]]];</span><br><span class=\"line\">arr2.flat(<span class=\"number\">2</span>); </span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4, 5, 6]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr3 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"number\">5</span>, <span class=\"number\">6</span>, [<span class=\"number\">7</span>, <span class=\"number\">8</span>]]]];</span><br><span class=\"line\">arr3.flat(<span class=\"literal\">Infinity</span>); </span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>\n\n<p>flat还会移除数组空项</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr4 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, , <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">arr4.flat(); <span class=\"comment\">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure>\n\n\n<p>2 字符串<br>去头去尾： String.prototype.trimStart() 和 String.prototype.trimEnd() 创建新字符串，不修改原字符串</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> test = <span class=\"string\">\" hello \"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">test.trim(); <span class=\"comment\">// \"hello\";</span></span><br><span class=\"line\">test.trimStart(); <span class=\"comment\">// \"hello \";</span></span><br><span class=\"line\">test.trimEnd(); <span class=\"comment\">// \" hello\";</span></span><br></pre></td></tr></table></figure>\n\n\n<p>3 对象<br>Object.fromEntries() 数组转对象<br>与之相对应的是Object.entries() 对象转数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">prop1</span>: <span class=\"number\">2</span>, <span class=\"attr\">prop2</span>: <span class=\"number\">10</span>, <span class=\"attr\">prop3</span>: <span class=\"number\">15</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转化为键值对数组：</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> array = <span class=\"built_in\">Object</span>.entries(obj); </span><br><span class=\"line\"><span class=\"comment\">// [[\"prop1\", 2], [\"prop2\", 10], [\"prop3\", 15]]</span></span><br><span class=\"line\"></span><br><span class=\"line\">array = array.map(<span class=\"function\">(<span class=\"params\">[key, value]</span>) =&gt;</span> [key, <span class=\"built_in\">Math</span>.pow(value, <span class=\"number\">2</span>)]); </span><br><span class=\"line\"><span class=\"comment\">// [[\"prop1\", 4], [\"prop2\", 100], [\"prop3\", 225]]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> newObj = <span class=\"built_in\">Object</span>.fromEntries(array); </span><br><span class=\"line\"><span class=\"comment\">// &#123;prop1: 4, prop2: 100, prop3: 225&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>参考：<br><a href=\"https://github.com/sisterAn/blog/issues/47\" target=\"_blank\" rel=\"noopener\">瓶子君的blog</a></p>\n"},{"title":"CSS准备","date":"2020-04-08T09:21:35.000Z","_content":"\n### 1. 介绍下BFC及其应用\n+ 1.1 BFC是什么:\n它是css盒模型的css渲染模式。\n有着盒子对齐，外边距重叠，清除浮动，防止文字环绕，多列最后列宽度自定义（不挤掉）\n\n+ 1.2 怎么新建一个BFC:\n一个新的BFC可以通过给容器添加任何一个触发BFC的CSS样式，如overflow: scroll, overflow: hidden, display: flex, float: left,或者 display: table来创建。\ndisplay:table可能会产生一些问题\noverflow:scroll可能会显示不必要的滚动条\nfloat:left将会把元素置于容器的左边，其他元素环绕着它\noverflow:hidden将会剪切掉溢出的元素\n\n参考链接：\n[w3cPlus](https://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html)\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context)\n\n\n### 2. A: display:none; B: visibility:hidden; C: opacity: 0的区别\n+ 展示程度上\n都不显示\n+ dom可操作上\nA不可操作，B不可操作，C可操作\n+ 继承性\nA和C的父盒子设置了对应的属性A和C，则他们的子代也是不可见，不可操作。B的子代是可以设置显示的\n+ 性能\nA改变了结构，引起文档回流，性能消耗最大\nB引起元素重绘，消耗中等\nC消耗最低\n\n参考链接：\n[张鑫旭BLOG](https://www.zhangxinxu.com/wordpress/2012/02/css-overflow-hidden-visibility-hidden-disabled-use/)","source":"_posts/CSS_review.md","raw":"---\ntitle: CSS准备\ndate: 2020-04-08 17:21:35\ntags: 面试\n---\n\n### 1. 介绍下BFC及其应用\n+ 1.1 BFC是什么:\n它是css盒模型的css渲染模式。\n有着盒子对齐，外边距重叠，清除浮动，防止文字环绕，多列最后列宽度自定义（不挤掉）\n\n+ 1.2 怎么新建一个BFC:\n一个新的BFC可以通过给容器添加任何一个触发BFC的CSS样式，如overflow: scroll, overflow: hidden, display: flex, float: left,或者 display: table来创建。\ndisplay:table可能会产生一些问题\noverflow:scroll可能会显示不必要的滚动条\nfloat:left将会把元素置于容器的左边，其他元素环绕着它\noverflow:hidden将会剪切掉溢出的元素\n\n参考链接：\n[w3cPlus](https://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html)\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context)\n\n\n### 2. A: display:none; B: visibility:hidden; C: opacity: 0的区别\n+ 展示程度上\n都不显示\n+ dom可操作上\nA不可操作，B不可操作，C可操作\n+ 继承性\nA和C的父盒子设置了对应的属性A和C，则他们的子代也是不可见，不可操作。B的子代是可以设置显示的\n+ 性能\nA改变了结构，引起文档回流，性能消耗最大\nB引起元素重绘，消耗中等\nC消耗最低\n\n参考链接：\n[张鑫旭BLOG](https://www.zhangxinxu.com/wordpress/2012/02/css-overflow-hidden-visibility-hidden-disabled-use/)","slug":"CSS_review","published":1,"updated":"2020-04-12T16:09:43.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr9d0002z5o82gq72en7","content":"<h3 id=\"1-介绍下BFC及其应用\"><a href=\"#1-介绍下BFC及其应用\" class=\"headerlink\" title=\"1. 介绍下BFC及其应用\"></a>1. 介绍下BFC及其应用</h3><ul>\n<li><p>1.1 BFC是什么:<br>它是css盒模型的css渲染模式。<br>有着盒子对齐，外边距重叠，清除浮动，防止文字环绕，多列最后列宽度自定义（不挤掉）</p>\n</li>\n<li><p>1.2 怎么新建一个BFC:<br>一个新的BFC可以通过给容器添加任何一个触发BFC的CSS样式，如overflow: scroll, overflow: hidden, display: flex, float: left,或者 display: table来创建。<br>display:table可能会产生一些问题<br>overflow:scroll可能会显示不必要的滚动条<br>float:left将会把元素置于容器的左边，其他元素环绕着它<br>overflow:hidden将会剪切掉溢出的元素</p>\n</li>\n</ul>\n<p>参考链接：<br><a href=\"https://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html\" target=\"_blank\" rel=\"noopener\">w3cPlus</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n<h3 id=\"2-A-display-none-B-visibility-hidden-C-opacity-0的区别\"><a href=\"#2-A-display-none-B-visibility-hidden-C-opacity-0的区别\" class=\"headerlink\" title=\"2. A: display:none; B: visibility:hidden; C: opacity: 0的区别\"></a>2. A: display:none; B: visibility:hidden; C: opacity: 0的区别</h3><ul>\n<li>展示程度上<br>都不显示</li>\n<li>dom可操作上<br>A不可操作，B不可操作，C可操作</li>\n<li>继承性<br>A和C的父盒子设置了对应的属性A和C，则他们的子代也是不可见，不可操作。B的子代是可以设置显示的</li>\n<li>性能<br>A改变了结构，引起文档回流，性能消耗最大<br>B引起元素重绘，消耗中等<br>C消耗最低</li>\n</ul>\n<p>参考链接：<br><a href=\"https://www.zhangxinxu.com/wordpress/2012/02/css-overflow-hidden-visibility-hidden-disabled-use/\" target=\"_blank\" rel=\"noopener\">张鑫旭BLOG</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-介绍下BFC及其应用\"><a href=\"#1-介绍下BFC及其应用\" class=\"headerlink\" title=\"1. 介绍下BFC及其应用\"></a>1. 介绍下BFC及其应用</h3><ul>\n<li><p>1.1 BFC是什么:<br>它是css盒模型的css渲染模式。<br>有着盒子对齐，外边距重叠，清除浮动，防止文字环绕，多列最后列宽度自定义（不挤掉）</p>\n</li>\n<li><p>1.2 怎么新建一个BFC:<br>一个新的BFC可以通过给容器添加任何一个触发BFC的CSS样式，如overflow: scroll, overflow: hidden, display: flex, float: left,或者 display: table来创建。<br>display:table可能会产生一些问题<br>overflow:scroll可能会显示不必要的滚动条<br>float:left将会把元素置于容器的左边，其他元素环绕着它<br>overflow:hidden将会剪切掉溢出的元素</p>\n</li>\n</ul>\n<p>参考链接：<br><a href=\"https://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html\" target=\"_blank\" rel=\"noopener\">w3cPlus</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n<h3 id=\"2-A-display-none-B-visibility-hidden-C-opacity-0的区别\"><a href=\"#2-A-display-none-B-visibility-hidden-C-opacity-0的区别\" class=\"headerlink\" title=\"2. A: display:none; B: visibility:hidden; C: opacity: 0的区别\"></a>2. A: display:none; B: visibility:hidden; C: opacity: 0的区别</h3><ul>\n<li>展示程度上<br>都不显示</li>\n<li>dom可操作上<br>A不可操作，B不可操作，C可操作</li>\n<li>继承性<br>A和C的父盒子设置了对应的属性A和C，则他们的子代也是不可见，不可操作。B的子代是可以设置显示的</li>\n<li>性能<br>A改变了结构，引起文档回流，性能消耗最大<br>B引起元素重绘，消耗中等<br>C消耗最低</li>\n</ul>\n<p>参考链接：<br><a href=\"https://www.zhangxinxu.com/wordpress/2012/02/css-overflow-hidden-visibility-hidden-disabled-use/\" target=\"_blank\" rel=\"noopener\">张鑫旭BLOG</a></p>\n"},{"title":"JS执行顺序 || EventLoop","date":"2019-12-03T07:08:36.000Z","_content":"\n### 1.EventLoop\nEventLoop就是那只看不见的手，由它主宰着JS的一切执行。\nJS的异步代码，遇到时会被放置在一个小圈子里，当把同步代码执行完，就从这圈子里取出来异步代码执行。\n```javascript\nconsole.log('script start');\nsetTimeout(function() { // 置底进程\n  console.log('from setTimeout');\n},0)\nconsole.log('script end');\n// 执行顺序：script start => script end => from setTimeout\n```\n\n### 2.微任务 && 宏任务\n优先级：同步代码 > 微任务 > 宏任务 > 异步代码\n宏任务：script , setTimeout, setInterval, setImmediate, i/0 , UI rendering ,requestAnimationFrame\n微任务：process.nextTick, promise, Object.observe, MutationObserver,await\n\n+ new Promise(fn) // 也属于微任务，执行优先级高\n+ 且process.nextTick优先级大于promise.then\n+ await后的async的fn 也会立刻执行 因为这是一个promise返回\n\n```javascript\nconsole.log('1');\n\nsetTimeout(function() { // setTimeout1\n    console.log('2');\n    process.nextTick(function() { // process2\n        console.log('3');\n    })\n    new Promise(function(resolve) { // promise2\n        console.log('4');\n        resolve();\n    }).then(function() { // then2\n        console.log('5')\n    })\n})\nprocess.nextTick(function() { // process1\n    console.log('6');\n})\nnew Promise(function(resolve) {\n    console.log('7'); // new Promise立即执行\n    resolve();\n}).then(function() { // then1\n    console.log('8')\n})\n\nsetTimeout(function() { // setTimeout2\n    console.log('9');\n    process.nextTick(function() { // process3\n        console.log('10');\n    })\n    new Promise(function(resolve) { // promise3\n        console.log('11');\n        resolve();\n    }).then(function() { // then3\n        console.log('12')\n    })\n})\n\n// 输出顺序 ：\n// 第一步：\n// \n```\n\n执行完 1 和 7后，现在看下，身边有这些任务\n\n| 宏任务Event | 微任务Event Queue |\n| ------------- |:-------------:| \n| setTimeout1   | process1      | \n| setTimeout2   | then1      |  \n\n现在第一轮的主线跑完了，轮到第一轮的微任务了，\n所以，接下来执行的是process1和then1，也就是\n1，7，6，8， \n\n第一轮结束，\n第二轮开始。\n\n接下来是开启新的一轮eventLoop。开始查询到新的宏任务setTimeout1；\n\n| 宏任务Event | 微任务Event Queue |\n| ------------- |:-------------:| \n| setTimeout1   |  process2     | \n| setTimeout2   |  then2        | \n \n1，7，6，8，2，4，3，5\n\n这下好了，setTimeout1宏任务完成了。\n接下来，就剩setTimeout2宏任务。\n\n| 宏任务Event | 微任务Event Queue |\n| ------------- |:-------------:| \n|               |  process3     | \n| setTimeout2   |  then3        |  \n\n1，7，6，8，2，4，3，5，9，11，10，12\n\n\n### 3. Vue的nextTick\n\n> 异步更新内部是最重要的就是nextTick方法，它负责将异步任务加入队列和执行异步任务。\nVUE  也将它暴露出来提供给用户使用。在数据修改完成后，立即获取相关DOM还没那么快更新，使用nextTick便可以解决这一问题。\n\n> watcher:每个监视者都有他们自己的id，当没有记录到对应的监视者.\n即第一次进入逻辑，否则是重复的监视者，则不会进入。这一步就是实现监视者去重的点。\n\n\n```js\n<input v-if=\"show\" type=\"text\" ref=\"myInput\">\n\n// js\n\ndata() {\n    show: false,\n},\nmounted() {\n    this.show = true\n    \n    this.$refs.myInput.focus() // error\n\n    this.$nextTick(function() { // 获取dom的更新，成功执行\n        this.$refs.myInput.focus()\n    })\n},\n\n```\n\n\n参考链接：\n[掘金](https://juejin.im/post/5aa8a07cf265da238a3022a4)\n[掘金2](https://juejin.im/post/59e85eebf265da430d571f89)\n[segment](https://segmentfault.com/a/1190000019494012)\n[blog](cxymsg.com/guide/eventLoop.html#前言)\n[promise async await](https://segmentfault.com/a/1190000015057278)","source":"_posts/JS执行顺序.md","raw":"---\ntitle: JS执行顺序 || EventLoop\ndate: 2019-12-03 15:08:36\ntags: JS原理\n---\n\n### 1.EventLoop\nEventLoop就是那只看不见的手，由它主宰着JS的一切执行。\nJS的异步代码，遇到时会被放置在一个小圈子里，当把同步代码执行完，就从这圈子里取出来异步代码执行。\n```javascript\nconsole.log('script start');\nsetTimeout(function() { // 置底进程\n  console.log('from setTimeout');\n},0)\nconsole.log('script end');\n// 执行顺序：script start => script end => from setTimeout\n```\n\n### 2.微任务 && 宏任务\n优先级：同步代码 > 微任务 > 宏任务 > 异步代码\n宏任务：script , setTimeout, setInterval, setImmediate, i/0 , UI rendering ,requestAnimationFrame\n微任务：process.nextTick, promise, Object.observe, MutationObserver,await\n\n+ new Promise(fn) // 也属于微任务，执行优先级高\n+ 且process.nextTick优先级大于promise.then\n+ await后的async的fn 也会立刻执行 因为这是一个promise返回\n\n```javascript\nconsole.log('1');\n\nsetTimeout(function() { // setTimeout1\n    console.log('2');\n    process.nextTick(function() { // process2\n        console.log('3');\n    })\n    new Promise(function(resolve) { // promise2\n        console.log('4');\n        resolve();\n    }).then(function() { // then2\n        console.log('5')\n    })\n})\nprocess.nextTick(function() { // process1\n    console.log('6');\n})\nnew Promise(function(resolve) {\n    console.log('7'); // new Promise立即执行\n    resolve();\n}).then(function() { // then1\n    console.log('8')\n})\n\nsetTimeout(function() { // setTimeout2\n    console.log('9');\n    process.nextTick(function() { // process3\n        console.log('10');\n    })\n    new Promise(function(resolve) { // promise3\n        console.log('11');\n        resolve();\n    }).then(function() { // then3\n        console.log('12')\n    })\n})\n\n// 输出顺序 ：\n// 第一步：\n// \n```\n\n执行完 1 和 7后，现在看下，身边有这些任务\n\n| 宏任务Event | 微任务Event Queue |\n| ------------- |:-------------:| \n| setTimeout1   | process1      | \n| setTimeout2   | then1      |  \n\n现在第一轮的主线跑完了，轮到第一轮的微任务了，\n所以，接下来执行的是process1和then1，也就是\n1，7，6，8， \n\n第一轮结束，\n第二轮开始。\n\n接下来是开启新的一轮eventLoop。开始查询到新的宏任务setTimeout1；\n\n| 宏任务Event | 微任务Event Queue |\n| ------------- |:-------------:| \n| setTimeout1   |  process2     | \n| setTimeout2   |  then2        | \n \n1，7，6，8，2，4，3，5\n\n这下好了，setTimeout1宏任务完成了。\n接下来，就剩setTimeout2宏任务。\n\n| 宏任务Event | 微任务Event Queue |\n| ------------- |:-------------:| \n|               |  process3     | \n| setTimeout2   |  then3        |  \n\n1，7，6，8，2，4，3，5，9，11，10，12\n\n\n### 3. Vue的nextTick\n\n> 异步更新内部是最重要的就是nextTick方法，它负责将异步任务加入队列和执行异步任务。\nVUE  也将它暴露出来提供给用户使用。在数据修改完成后，立即获取相关DOM还没那么快更新，使用nextTick便可以解决这一问题。\n\n> watcher:每个监视者都有他们自己的id，当没有记录到对应的监视者.\n即第一次进入逻辑，否则是重复的监视者，则不会进入。这一步就是实现监视者去重的点。\n\n\n```js\n<input v-if=\"show\" type=\"text\" ref=\"myInput\">\n\n// js\n\ndata() {\n    show: false,\n},\nmounted() {\n    this.show = true\n    \n    this.$refs.myInput.focus() // error\n\n    this.$nextTick(function() { // 获取dom的更新，成功执行\n        this.$refs.myInput.focus()\n    })\n},\n\n```\n\n\n参考链接：\n[掘金](https://juejin.im/post/5aa8a07cf265da238a3022a4)\n[掘金2](https://juejin.im/post/59e85eebf265da430d571f89)\n[segment](https://segmentfault.com/a/1190000019494012)\n[blog](cxymsg.com/guide/eventLoop.html#前言)\n[promise async await](https://segmentfault.com/a/1190000015057278)","slug":"JS执行顺序","published":1,"updated":"2020-07-26T05:39:49.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr9g0004z5o85cwhcu0g","content":"<h3 id=\"1-EventLoop\"><a href=\"#1-EventLoop\" class=\"headerlink\" title=\"1.EventLoop\"></a>1.EventLoop</h3><p>EventLoop就是那只看不见的手，由它主宰着JS的一切执行。<br>JS的异步代码，遇到时会被放置在一个小圈子里，当把同步代码执行完，就从这圈子里取出来异步代码执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>);</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 置底进程</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'from setTimeout'</span>);</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 执行顺序：script start =&gt; script end =&gt; from setTimeout</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-微任务-amp-amp-宏任务\"><a href=\"#2-微任务-amp-amp-宏任务\" class=\"headerlink\" title=\"2.微任务 &amp;&amp; 宏任务\"></a>2.微任务 &amp;&amp; 宏任务</h3><p>优先级：同步代码 &gt; 微任务 &gt; 宏任务 &gt; 异步代码<br>宏任务：script , setTimeout, setInterval, setImmediate, i/0 , UI rendering ,requestAnimationFrame<br>微任务：process.nextTick, promise, Object.observe, MutationObserver,await</p>\n<ul>\n<li>new Promise(fn) // 也属于微任务，执行优先级高</li>\n<li>且process.nextTick优先级大于promise.then</li>\n<li>await后的async的fn 也会立刻执行 因为这是一个promise返回</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'1'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// setTimeout1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'2'</span>);</span><br><span class=\"line\">    process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// process2</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'3'</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123; <span class=\"comment\">// promise2</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'4'</span>);</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// then2</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'5'</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// process1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'6'</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'7'</span>); <span class=\"comment\">// new Promise立即执行</span></span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// then1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'8'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// setTimeout2</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'9'</span>);</span><br><span class=\"line\">    process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// process3</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'10'</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123; <span class=\"comment\">// promise3</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'11'</span>);</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// then3</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'12'</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出顺序 ：</span></span><br><span class=\"line\"><span class=\"comment\">// 第一步：</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n\n<p>执行完 1 和 7后，现在看下，身边有这些任务</p>\n<table>\n<thead>\n<tr>\n<th>宏任务Event</th>\n<th align=\"center\">微任务Event Queue</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>setTimeout1</td>\n<td align=\"center\">process1</td>\n</tr>\n<tr>\n<td>setTimeout2</td>\n<td align=\"center\">then1</td>\n</tr>\n</tbody></table>\n<p>现在第一轮的主线跑完了，轮到第一轮的微任务了，<br>所以，接下来执行的是process1和then1，也就是<br>1，7，6，8， </p>\n<p>第一轮结束，<br>第二轮开始。</p>\n<p>接下来是开启新的一轮eventLoop。开始查询到新的宏任务setTimeout1；</p>\n<table>\n<thead>\n<tr>\n<th>宏任务Event</th>\n<th align=\"center\">微任务Event Queue</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>setTimeout1</td>\n<td align=\"center\">process2</td>\n</tr>\n<tr>\n<td>setTimeout2</td>\n<td align=\"center\">then2</td>\n</tr>\n</tbody></table>\n<p>1，7，6，8，2，4，3，5</p>\n<p>这下好了，setTimeout1宏任务完成了。<br>接下来，就剩setTimeout2宏任务。</p>\n<table>\n<thead>\n<tr>\n<th>宏任务Event</th>\n<th align=\"center\">微任务Event Queue</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td align=\"center\">process3</td>\n</tr>\n<tr>\n<td>setTimeout2</td>\n<td align=\"center\">then3</td>\n</tr>\n</tbody></table>\n<p>1，7，6，8，2，4，3，5，9，11，10，12</p>\n<h3 id=\"3-Vue的nextTick\"><a href=\"#3-Vue的nextTick\" class=\"headerlink\" title=\"3. Vue的nextTick\"></a>3. Vue的nextTick</h3><blockquote>\n<p>异步更新内部是最重要的就是nextTick方法，它负责将异步任务加入队列和执行异步任务。<br>VUE  也将它暴露出来提供给用户使用。在数据修改完成后，立即获取相关DOM还没那么快更新，使用nextTick便可以解决这一问题。</p>\n</blockquote>\n<blockquote>\n<p>watcher:每个监视者都有他们自己的id，当没有记录到对应的监视者.<br>即第一次进入逻辑，否则是重复的监视者，则不会进入。这一步就是实现监视者去重的点。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-<span class=\"keyword\">if</span>=<span class=\"string\">\"show\"</span> type=<span class=\"string\">\"text\"</span> ref=<span class=\"string\">\"myInput\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// js</span></span><br><span class=\"line\"></span><br><span class=\"line\">data() &#123;</span><br><span class=\"line\">    show: <span class=\"literal\">false</span>,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.show = <span class=\"literal\">true</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$refs.myInput.focus() <span class=\"comment\">// error</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 获取dom的更新，成功执行</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.$refs.myInput.focus()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n\n<p>参考链接：<br><a href=\"https://juejin.im/post/5aa8a07cf265da238a3022a4\" target=\"_blank\" rel=\"noopener\">掘金</a><br><a href=\"https://juejin.im/post/59e85eebf265da430d571f89\" target=\"_blank\" rel=\"noopener\">掘金2</a><br><a href=\"https://segmentfault.com/a/1190000019494012\" target=\"_blank\" rel=\"noopener\">segment</a><br><a href=\"cxymsg.com/guide/eventLoop.html#前言\">blog</a><br><a href=\"https://segmentfault.com/a/1190000015057278\" target=\"_blank\" rel=\"noopener\">promise async await</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-EventLoop\"><a href=\"#1-EventLoop\" class=\"headerlink\" title=\"1.EventLoop\"></a>1.EventLoop</h3><p>EventLoop就是那只看不见的手，由它主宰着JS的一切执行。<br>JS的异步代码，遇到时会被放置在一个小圈子里，当把同步代码执行完，就从这圈子里取出来异步代码执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>);</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 置底进程</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'from setTimeout'</span>);</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 执行顺序：script start =&gt; script end =&gt; from setTimeout</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-微任务-amp-amp-宏任务\"><a href=\"#2-微任务-amp-amp-宏任务\" class=\"headerlink\" title=\"2.微任务 &amp;&amp; 宏任务\"></a>2.微任务 &amp;&amp; 宏任务</h3><p>优先级：同步代码 &gt; 微任务 &gt; 宏任务 &gt; 异步代码<br>宏任务：script , setTimeout, setInterval, setImmediate, i/0 , UI rendering ,requestAnimationFrame<br>微任务：process.nextTick, promise, Object.observe, MutationObserver,await</p>\n<ul>\n<li>new Promise(fn) // 也属于微任务，执行优先级高</li>\n<li>且process.nextTick优先级大于promise.then</li>\n<li>await后的async的fn 也会立刻执行 因为这是一个promise返回</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'1'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// setTimeout1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'2'</span>);</span><br><span class=\"line\">    process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// process2</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'3'</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123; <span class=\"comment\">// promise2</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'4'</span>);</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// then2</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'5'</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// process1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'6'</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'7'</span>); <span class=\"comment\">// new Promise立即执行</span></span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// then1</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'8'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// setTimeout2</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'9'</span>);</span><br><span class=\"line\">    process.nextTick(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// process3</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'10'</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123; <span class=\"comment\">// promise3</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'11'</span>);</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// then3</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'12'</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出顺序 ：</span></span><br><span class=\"line\"><span class=\"comment\">// 第一步：</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n\n<p>执行完 1 和 7后，现在看下，身边有这些任务</p>\n<table>\n<thead>\n<tr>\n<th>宏任务Event</th>\n<th align=\"center\">微任务Event Queue</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>setTimeout1</td>\n<td align=\"center\">process1</td>\n</tr>\n<tr>\n<td>setTimeout2</td>\n<td align=\"center\">then1</td>\n</tr>\n</tbody></table>\n<p>现在第一轮的主线跑完了，轮到第一轮的微任务了，<br>所以，接下来执行的是process1和then1，也就是<br>1，7，6，8， </p>\n<p>第一轮结束，<br>第二轮开始。</p>\n<p>接下来是开启新的一轮eventLoop。开始查询到新的宏任务setTimeout1；</p>\n<table>\n<thead>\n<tr>\n<th>宏任务Event</th>\n<th align=\"center\">微任务Event Queue</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>setTimeout1</td>\n<td align=\"center\">process2</td>\n</tr>\n<tr>\n<td>setTimeout2</td>\n<td align=\"center\">then2</td>\n</tr>\n</tbody></table>\n<p>1，7，6，8，2，4，3，5</p>\n<p>这下好了，setTimeout1宏任务完成了。<br>接下来，就剩setTimeout2宏任务。</p>\n<table>\n<thead>\n<tr>\n<th>宏任务Event</th>\n<th align=\"center\">微任务Event Queue</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td align=\"center\">process3</td>\n</tr>\n<tr>\n<td>setTimeout2</td>\n<td align=\"center\">then3</td>\n</tr>\n</tbody></table>\n<p>1，7，6，8，2，4，3，5，9，11，10，12</p>\n<h3 id=\"3-Vue的nextTick\"><a href=\"#3-Vue的nextTick\" class=\"headerlink\" title=\"3. Vue的nextTick\"></a>3. Vue的nextTick</h3><blockquote>\n<p>异步更新内部是最重要的就是nextTick方法，它负责将异步任务加入队列和执行异步任务。<br>VUE  也将它暴露出来提供给用户使用。在数据修改完成后，立即获取相关DOM还没那么快更新，使用nextTick便可以解决这一问题。</p>\n</blockquote>\n<blockquote>\n<p>watcher:每个监视者都有他们自己的id，当没有记录到对应的监视者.<br>即第一次进入逻辑，否则是重复的监视者，则不会进入。这一步就是实现监视者去重的点。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-<span class=\"keyword\">if</span>=<span class=\"string\">\"show\"</span> type=<span class=\"string\">\"text\"</span> ref=<span class=\"string\">\"myInput\"</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// js</span></span><br><span class=\"line\"></span><br><span class=\"line\">data() &#123;</span><br><span class=\"line\">    show: <span class=\"literal\">false</span>,</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mounted() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.show = <span class=\"literal\">true</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$refs.myInput.focus() <span class=\"comment\">// error</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 获取dom的更新，成功执行</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.$refs.myInput.focus()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n\n<p>参考链接：<br><a href=\"https://juejin.im/post/5aa8a07cf265da238a3022a4\" target=\"_blank\" rel=\"noopener\">掘金</a><br><a href=\"https://juejin.im/post/59e85eebf265da430d571f89\" target=\"_blank\" rel=\"noopener\">掘金2</a><br><a href=\"https://segmentfault.com/a/1190000019494012\" target=\"_blank\" rel=\"noopener\">segment</a><br><a href=\"cxymsg.com/guide/eventLoop.html#前言\">blog</a><br><a href=\"https://segmentfault.com/a/1190000015057278\" target=\"_blank\" rel=\"noopener\">promise async await</a></p>\n"},{"title":"H5-insertAdjacentElement","date":"2019-03-11T14:42:25.000Z","_content":"\n###### insertAdjacentElement作用是？\n该方法将一个给定的元素节点`插入到`*相对于被调用的元素*的给定的`一个位置`。\n\n###### 如何用呢？\n```js\nelement1.insertAdjacentElement(position, element2);\n```\n参数positon:\n+ `beforebegin`: 在该元素本身的前面.\n+ `afterbegin`:只在该元素当中, 在该元素第一个子孩子前面.\n+ `beforeend`:只在该元素当中, 在该元素最后一个子孩子后面.\n+ `afterend`: 在该元素本身的后面.\n\nelement1：不动的元素\nelement2：被插入的元素\n\n###### 具体例子\n```js\nlet fileWrap = document.querySelector(`#${this.fileWrapId}`);\nfileWrap.insertAdjacentElement('afterbegin', elem); // elem为插入的元素\n```\n\n###### 参考链接：\n[mdn](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/insertAdjacentElement)","source":"_posts/H5-insertAdjacentElement.md","raw":"---\ntitle: H5-insertAdjacentElement\ndate: 2019-03-11 22:42:25\ntags: H5\n---\n\n###### insertAdjacentElement作用是？\n该方法将一个给定的元素节点`插入到`*相对于被调用的元素*的给定的`一个位置`。\n\n###### 如何用呢？\n```js\nelement1.insertAdjacentElement(position, element2);\n```\n参数positon:\n+ `beforebegin`: 在该元素本身的前面.\n+ `afterbegin`:只在该元素当中, 在该元素第一个子孩子前面.\n+ `beforeend`:只在该元素当中, 在该元素最后一个子孩子后面.\n+ `afterend`: 在该元素本身的后面.\n\nelement1：不动的元素\nelement2：被插入的元素\n\n###### 具体例子\n```js\nlet fileWrap = document.querySelector(`#${this.fileWrapId}`);\nfileWrap.insertAdjacentElement('afterbegin', elem); // elem为插入的元素\n```\n\n###### 参考链接：\n[mdn](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/insertAdjacentElement)","slug":"H5-insertAdjacentElement","published":1,"updated":"2019-03-17T14:54:42.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr9j0005z5o8ezx701yf","content":"<h6 id=\"insertAdjacentElement作用是？\"><a href=\"#insertAdjacentElement作用是？\" class=\"headerlink\" title=\"insertAdjacentElement作用是？\"></a>insertAdjacentElement作用是？</h6><p>该方法将一个给定的元素节点<code>插入到</code><em>相对于被调用的元素</em>的给定的<code>一个位置</code>。</p>\n<h6 id=\"如何用呢？\"><a href=\"#如何用呢？\" class=\"headerlink\" title=\"如何用呢？\"></a>如何用呢？</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element1.insertAdjacentElement(position, element2);</span><br></pre></td></tr></table></figure>\n<p>参数positon:</p>\n<ul>\n<li><code>beforebegin</code>: 在该元素本身的前面.</li>\n<li><code>afterbegin</code>:只在该元素当中, 在该元素第一个子孩子前面.</li>\n<li><code>beforeend</code>:只在该元素当中, 在该元素最后一个子孩子后面.</li>\n<li><code>afterend</code>: 在该元素本身的后面.</li>\n</ul>\n<p>element1：不动的元素<br>element2：被插入的元素</p>\n<h6 id=\"具体例子\"><a href=\"#具体例子\" class=\"headerlink\" title=\"具体例子\"></a>具体例子</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fileWrap = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">`#<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.fileWrapId&#125;</span>`</span>);</span><br><span class=\"line\">fileWrap.insertAdjacentElement(<span class=\"string\">'afterbegin'</span>, elem); <span class=\"comment\">// elem为插入的元素</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h6><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/insertAdjacentElement\" target=\"_blank\" rel=\"noopener\">mdn</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h6 id=\"insertAdjacentElement作用是？\"><a href=\"#insertAdjacentElement作用是？\" class=\"headerlink\" title=\"insertAdjacentElement作用是？\"></a>insertAdjacentElement作用是？</h6><p>该方法将一个给定的元素节点<code>插入到</code><em>相对于被调用的元素</em>的给定的<code>一个位置</code>。</p>\n<h6 id=\"如何用呢？\"><a href=\"#如何用呢？\" class=\"headerlink\" title=\"如何用呢？\"></a>如何用呢？</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element1.insertAdjacentElement(position, element2);</span><br></pre></td></tr></table></figure>\n<p>参数positon:</p>\n<ul>\n<li><code>beforebegin</code>: 在该元素本身的前面.</li>\n<li><code>afterbegin</code>:只在该元素当中, 在该元素第一个子孩子前面.</li>\n<li><code>beforeend</code>:只在该元素当中, 在该元素最后一个子孩子后面.</li>\n<li><code>afterend</code>: 在该元素本身的后面.</li>\n</ul>\n<p>element1：不动的元素<br>element2：被插入的元素</p>\n<h6 id=\"具体例子\"><a href=\"#具体例子\" class=\"headerlink\" title=\"具体例子\"></a>具体例子</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> fileWrap = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">`#<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.fileWrapId&#125;</span>`</span>);</span><br><span class=\"line\">fileWrap.insertAdjacentElement(<span class=\"string\">'afterbegin'</span>, elem); <span class=\"comment\">// elem为插入的元素</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h6><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/insertAdjacentElement\" target=\"_blank\" rel=\"noopener\">mdn</a></p>\n"},{"title":"apollo主题增加Valine评论","date":"2020-07-11T11:08:18.000Z","_content":"\n#### 初衷\n大道至简\n最近刚迁移主题到`Apollo`，相当清新的主题，具体的参考[github](https://github.com/pinggod/hexo-theme-apollo)\n\n#### 评论系统的选择\n从支持的表情与颜值上来看，果断选择了`Valine`\n效果图可以看博客下方😊\n\n<div class=\"tip\">\n    因为Apollo主题已经关闭issue，所以只能自己去增加评论的初始化代码了\n</div> \n\n#### 魔改\n1 `themes/apollo/_config.yml`: \n    ```yml\n        valine:\n            # 开启 Valine 评论\n            enable: true\n            # 设置应用 id 和 key\n            appId: 您的appId\n            appKey: 您的appkey\n    ```\n2 `themes/apollo/source/js/Valine.min.js`： 拷贝Valinecdn路径，缓存到本地，以防万一\n3 `themes/apollo/layout/partial/head.jade`: 增加引用`script(src=url_for(\"js/Valine.min.js\"))`\n4 `themes/apollo/layout/partial/comment.jade`: 增加主题的评论判断\n     ```JavaScript\n        if theme.valine\n            div#vcomments\n            //script(src=\"//unpkg.com/valine/dist/Valine.min.js\")\n            script.\n                new Valine({ // 里面的参数配置具体参考Valine官网\n                    el: '#vcomments',\n                    appId: `#{theme.valine.appId}`,\n                    appKey: `#{theme.valine.appKey}`,\n                    placeholder: '快来评论吧(#^.^#)',\n                    avatar: 'wavatar'\n                });\n      ```\n     \n---\n\n参考\n[Valine前后所需介绍](https://www.playpi.org/2019032001.html)\n[Valine官网](https://valine.js.org/)\n","source":"_posts/apollo主题增加Valine评论.md","raw":"---\ntitle: apollo主题增加Valine评论\ndate: 2020-07-11 19:08:18\ntags: Apollo Hexo Valine \n---\n\n#### 初衷\n大道至简\n最近刚迁移主题到`Apollo`，相当清新的主题，具体的参考[github](https://github.com/pinggod/hexo-theme-apollo)\n\n#### 评论系统的选择\n从支持的表情与颜值上来看，果断选择了`Valine`\n效果图可以看博客下方😊\n\n<div class=\"tip\">\n    因为Apollo主题已经关闭issue，所以只能自己去增加评论的初始化代码了\n</div> \n\n#### 魔改\n1 `themes/apollo/_config.yml`: \n    ```yml\n        valine:\n            # 开启 Valine 评论\n            enable: true\n            # 设置应用 id 和 key\n            appId: 您的appId\n            appKey: 您的appkey\n    ```\n2 `themes/apollo/source/js/Valine.min.js`： 拷贝Valinecdn路径，缓存到本地，以防万一\n3 `themes/apollo/layout/partial/head.jade`: 增加引用`script(src=url_for(\"js/Valine.min.js\"))`\n4 `themes/apollo/layout/partial/comment.jade`: 增加主题的评论判断\n     ```JavaScript\n        if theme.valine\n            div#vcomments\n            //script(src=\"//unpkg.com/valine/dist/Valine.min.js\")\n            script.\n                new Valine({ // 里面的参数配置具体参考Valine官网\n                    el: '#vcomments',\n                    appId: `#{theme.valine.appId}`,\n                    appKey: `#{theme.valine.appKey}`,\n                    placeholder: '快来评论吧(#^.^#)',\n                    avatar: 'wavatar'\n                });\n      ```\n     \n---\n\n参考\n[Valine前后所需介绍](https://www.playpi.org/2019032001.html)\n[Valine官网](https://valine.js.org/)\n","slug":"apollo主题增加Valine评论","published":1,"updated":"2020-07-13T09:18:16.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr9k0006z5o8a9q37yvz","content":"<h4 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h4><p>大道至简<br>最近刚迁移主题到<code>Apollo</code>，相当清新的主题，具体的参考<a href=\"https://github.com/pinggod/hexo-theme-apollo\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<h4 id=\"评论系统的选择\"><a href=\"#评论系统的选择\" class=\"headerlink\" title=\"评论系统的选择\"></a>评论系统的选择</h4><p>从支持的表情与颜值上来看，果断选择了<code>Valine</code><br>效果图可以看博客下方😊</p>\n<div class=\"tip\">\n    因为Apollo主题已经关闭issue，所以只能自己去增加评论的初始化代码了\n</div> \n\n<h4 id=\"魔改\"><a href=\"#魔改\" class=\"headerlink\" title=\"魔改\"></a>魔改</h4><p>1 <code>themes/apollo/_config.yml</code>:<br>    <figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\">    <span class=\"comment\"># 开启 Valine 评论</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"comment\"># 设置应用 id 和 key</span></span><br><span class=\"line\">    <span class=\"attr\">appId:</span> <span class=\"string\">您的appId</span></span><br><span class=\"line\">    <span class=\"attr\">appKey:</span> <span class=\"string\">您的appkey</span></span><br></pre></td></tr></table></figure><br>2 <code>themes/apollo/source/js/Valine.min.js</code>： 拷贝Valinecdn路径，缓存到本地，以防万一<br>3 <code>themes/apollo/layout/partial/head.jade</code>: 增加引用<code>script(src=url_for(&quot;js/Valine.min.js&quot;))</code><br>4 <code>themes/apollo/layout/partial/comment.jade</code>: 增加主题的评论判断<br>     <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> theme.valine</span><br><span class=\"line\">    div#vcomments</span><br><span class=\"line\">    <span class=\"comment\">//script(src=\"//unpkg.com/valine/dist/Valine.min.js\")</span></span><br><span class=\"line\">    script.</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Valine(&#123; <span class=\"comment\">// 里面的参数配置具体参考Valine官网</span></span><br><span class=\"line\">            el: <span class=\"string\">'#vcomments'</span>,</span><br><span class=\"line\">            appId: <span class=\"string\">`#&#123;theme.valine.appId&#125;`</span>,</span><br><span class=\"line\">            appKey: <span class=\"string\">`#&#123;theme.valine.appKey&#125;`</span>,</span><br><span class=\"line\">            placeholder: <span class=\"string\">'快来评论吧(#^.^#)'</span>,</span><br><span class=\"line\">            avatar: <span class=\"string\">'wavatar'</span></span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>参考<br><a href=\"https://www.playpi.org/2019032001.html\" target=\"_blank\" rel=\"noopener\">Valine前后所需介绍</a><br><a href=\"https://valine.js.org/\" target=\"_blank\" rel=\"noopener\">Valine官网</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"初衷\"><a href=\"#初衷\" class=\"headerlink\" title=\"初衷\"></a>初衷</h4><p>大道至简<br>最近刚迁移主题到<code>Apollo</code>，相当清新的主题，具体的参考<a href=\"https://github.com/pinggod/hexo-theme-apollo\" target=\"_blank\" rel=\"noopener\">github</a></p>\n<h4 id=\"评论系统的选择\"><a href=\"#评论系统的选择\" class=\"headerlink\" title=\"评论系统的选择\"></a>评论系统的选择</h4><p>从支持的表情与颜值上来看，果断选择了<code>Valine</code><br>效果图可以看博客下方😊</p>\n<div class=\"tip\">\n    因为Apollo主题已经关闭issue，所以只能自己去增加评论的初始化代码了\n</div> \n\n<h4 id=\"魔改\"><a href=\"#魔改\" class=\"headerlink\" title=\"魔改\"></a>魔改</h4><p>1 <code>themes/apollo/_config.yml</code>:<br>    <figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\">    <span class=\"comment\"># 开启 Valine 评论</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"comment\"># 设置应用 id 和 key</span></span><br><span class=\"line\">    <span class=\"attr\">appId:</span> <span class=\"string\">您的appId</span></span><br><span class=\"line\">    <span class=\"attr\">appKey:</span> <span class=\"string\">您的appkey</span></span><br></pre></td></tr></table></figure><br>2 <code>themes/apollo/source/js/Valine.min.js</code>： 拷贝Valinecdn路径，缓存到本地，以防万一<br>3 <code>themes/apollo/layout/partial/head.jade</code>: 增加引用<code>script(src=url_for(&quot;js/Valine.min.js&quot;))</code><br>4 <code>themes/apollo/layout/partial/comment.jade</code>: 增加主题的评论判断<br>     <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> theme.valine</span><br><span class=\"line\">    div#vcomments</span><br><span class=\"line\">    <span class=\"comment\">//script(src=\"//unpkg.com/valine/dist/Valine.min.js\")</span></span><br><span class=\"line\">    script.</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Valine(&#123; <span class=\"comment\">// 里面的参数配置具体参考Valine官网</span></span><br><span class=\"line\">            el: <span class=\"string\">'#vcomments'</span>,</span><br><span class=\"line\">            appId: <span class=\"string\">`#&#123;theme.valine.appId&#125;`</span>,</span><br><span class=\"line\">            appKey: <span class=\"string\">`#&#123;theme.valine.appKey&#125;`</span>,</span><br><span class=\"line\">            placeholder: <span class=\"string\">'快来评论吧(#^.^#)'</span>,</span><br><span class=\"line\">            avatar: <span class=\"string\">'wavatar'</span></span><br><span class=\"line\">        &#125;);</span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>参考<br><a href=\"https://www.playpi.org/2019032001.html\" target=\"_blank\" rel=\"noopener\">Valine前后所需介绍</a><br><a href=\"https://valine.js.org/\" target=\"_blank\" rel=\"noopener\">Valine官网</a></p>\n"},{"title":"MVVM实现（Object.defineProperty && 观察订阅）","date":"2020-07-23T13:01:50.000Z","_content":"\n### 1. MVVM特点图解\n![MVVM注解图1](/MVVM/MVVM1.png)\n![MVVM注解图2](/MVVM/MVVM2.png)\n![MVVM注解图3](/MVVM/MVVM3.png)\n![MVVM注解图4](/MVVM/MVVM4.png)\n![MVVM注解图5](/MVVM/MVVM5.png)\n\n### 2. MVVM的功能：\n+ 给所有data属性值都设置数据劫持，绑定好属性观察。（*也是深度响应原理*）\n+ 结合观察订阅者模式\n\n### 3.代码实现：(`MVVM `包含双向数据绑定、`v-model`、`computed`)\n```js\n/**\n * let zs = new Vue({\n *     el: '#app',\n *     data: {a: 1}\n * })\n */\n\n/**\n *\n * @param options 参考vue实例化时传进的对象,代表我们存储的所有对象\n */\nfunction demoVue(options = {}) {\n    this.$options = options;  // 当前实例，存储存进的对象\n    let data = this._data = this.$options.data;  // 当前实例，存储options.data 准备像vue一样观察数据\n    observe(data);\n    // 为了代理_data属性。可以直接在实例的时候取到data，再用define一次\n    for (let key in data) {\n        Object.defineProperty(this,key,{\n            enumerable: true,\n            get() {\n                return this._data[key]; // 将this._data.key 通过定义对象的方式 赋给了 this.key，模拟vue\n            },\n            set(newVal) {\n                this._data[key] = newVal;\n            }\n        })\n    }\n    let computed = this.$options.computed;\n    operatedComputed.call(this)  // computedde 的操作需放在数据都已被观察完，并挂载到_data里\n   \n    new Compile(options.el, this);\n}\n\nfunction operatedComputed() { // computed 处理函数\n    let vm = this\n    let computedFn = this.$options.computed\n    Object.keys(computedFn).forEach(function(key){\n        // \bcomputed挂载到vm上\n        Object.defineProperty(vm,key,{\n            get: typeof computedFn[key] === 'function' ?  computedFn[key] : computedFn[key].get,\n            set() {\n\n            }\n        })\n    })\n}\n\nfunction observe(data) { // 数据劫持，增加Object.defineProperty\n     if (typeof data !== 'object') return;\n     return new Observe(data); // 方便递归\n}\n\n/**\n * 把数据编译到dom上，实现数据绑定\n * @param el 替换的dom\n * @param vm 实例\n * @constructor\n * note:\n * (1) 文档碎片\n * (2) regExp.$n: --[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n]\n * (3)正则图形化 https://regexper.com/\n * (4)正则对照表：http://tool.oschina.net/uploads/apidocs/jquery/regexp.html\n */\nfunction Compile(el, vm) {\n    vm.$el = document.querySelector(el);\n    let fragment = document.createDocumentFragment(); // 之所以用了文档碎片，是因为这样造成页面渲染回流的代价最低\n    let child;\n    // 此处用到了appendChild的一个特性：对于被添加的子节点，如果之前已经存在，则会销毁自己在dom树的节点，然后把自己添加到新的地方\n    // 因此vm.$el.firstChild才会不停地切换成下一个子节点。\n    // --[https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild]\n\n    while (child = vm.$el.firstChild) {\n        fragment.appendChild(child);\n    }\n    replace(fragment);\n    /**\n     * Array.from 将伪数组对象转为数组实例\n      textContext: 节点内容\n      节点类型 --[https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType] nodeType为3时，是element或者属性中的字\n      之所以抽离出方法，是因为想要重复调用，当子节点里还有子节点时，可以调用。\n     */\n    function replace(fragment) {\n        Array.from(fragment.childNodes).forEach(function (node) {\n            let text = node.textContent;\n            let exp;\n            let reg = /\\{\\{(.*)\\}\\}/;\n            if (node.nodeType === 3 && reg.test(text)) {\n               exp = text.replace(reg, '$1'); // 正则匹配中第一个括号所代表的内容\n                let pointArr = exp.split('.'); // a.a b\n                let existVal = vm;\n                pointArr.forEach(function (key) { // vm.a.a  vm.b\n                    existVal = existVal[key];\n                });\n                // 添加一个watcher事件 监听了值的变化\n                new Watcher(vm,exp,function (newVal) {\n                    node.textContent = text.replace(reg, newVal);\n                });\n                 // @todo此处parser有待完善，只能兼容纯{{}}，带上其他字符会让existVal失效\n                node.textContent = text.replace(reg, existVal);\n            }\n            if (node.nodeType === 1 ) { // v-model实现\n                let attr = Array.from(node.attributes)\n                let attr_value;\n                attr.forEach(function(item){\n                    if (item.name === 'v-model') {\n                        attr_value = item.value\n                        new Watcher(vm,attr_value, function(newVal) {\n                            node.value = newVal\n                        })\n                        node.addEventListener('input',function(e){\n                            vm[attr_value] = e.target.value\n                        })  \n                    }\n                   \n                })\n            }\n            if (node.childNodes) {\n                replace(node);\n            }\n            vm.$el.appendChild(fragment); // 文档碎片的内容重新添加到原来挂载的元素里\n        });\n    }\n}\n\n\n/**\n * @param data\n * @returns {*}\n * @constructor\n */\nfunction Observe(data) { // 实际观察方法,设置 Object.defineProperty\n    let dep = new Dep();\n    for (let key in data) {\n        let val = data[key];\n        observe(val); // 这里就已经可以递归了\n        Object.defineProperty(data,key, {\n            enumerable: true,\n            get() {\n                // 此时Dep.target是this\n                if (Dep.target) {\n                    dep.addSub(Dep.target); // 添加事件订阅（watcher 的 push）\n                }\n                return val;\n            },\n            set(newVal) {\n                if (newVal ===  val) { // 值没发生变化\n                    return; \n                } else {\n                    val = newVal; // 更新值。get获取值时，也可以得到最新的值。\n                    observe(newVal); // 这里是为了给新值也添上观察者\n                    dep.notify(); // 添加事件的通知更新（watcher的update）\n                }\n            }\n        })\n    }\n}\n\n/**\n * 发布订阅函数\n * @Dep\n */\nfunction Dep() {\n    this.subs = []; // 事件池\n}\nDep.prototype.addSub = function (sub) { // 订阅\n    this.subs.push(sub);\n};\nDep.prototype.notify = function () { // 通知\n    this.subs.forEach(sub => {\n        sub.update();\n    })\n};\n\n/**\n * 事件池其中的一个\n * @param vm: 实例环境（总的数据来源）\n * @param 正则表达式的遍历对象exp (要更改的对象)\n * @param fn（处理的回调函数）\n * @constructor\n */\nfunction Watcher(vm,exp,fn) { // fn是回调函数 new的时候传进来\n    this.vm = vm;\n    this.exp = exp;\n    this.fn = fn;\n\n    // 添加到订阅中\n    // Dep.target ??? 扮演着一个watcher对象，也是Watcher的实例  它和 Object.defineProperty的get会有反应\n    Dep.target = this;\n    let val = vm;\n    let arr = exp.split('.');\n    arr.forEach(function (k) { // 这里获取 this.a.a时还是会触发到默认的getter\n        val = val[k];\n    });\n    Dep.target = null;\n\n}\nWatcher.prototype.update = function () { // watcher的更新方法\n    let val = this.vm;\n    let arr = this.exp.split('.');\n    arr.forEach(function (k) {\n        val = val[k];\n    });\n    this.fn(val); // 把最新值传进callback\n};\n\n\n```\n\n\n```HTML\n<body>\n    <div id=\"app\">\n        <div>{{a.a}}</div>\n        <div>{{b}}</div>\n        <input type=\"text\" v-model=\"b\">\n        <div>{{cacultate_c}}</div>\n    </div>\n</body>\n<!--<script src=\"../dist/my_bundle.js\"></script>-->\n<script src=\"./compile.js\"></script>\n<script>\n    // 调用\n    let little = new demoVue({\n        el: \"#app\",\n        data: {\n            a: {a:\"是a\"},\n            b: \"是b\"\n        },\n        computed: {\n            cacultate_c: function() {\n                return this.a.a + this.b;\n            },\n            cacultate_d: {\n                get() {\n                    return this.a.a + this.b + this.b\n                },\n                set(val) {\n                    this.a = val\n                }\n            }\n        }\n    });\n\n```\n\n\n---\n\n### 知识储备\n1、 `Object.defineProperty` 给对象设置某属性，并且可以设置setter，用于绑定属性。\n\n```js\nlet obj = {}\nObject.defineProperty(obj, 'school',{\n    configurable: true, // 让 delete 更新属性值 生效\n    enumberable: true,\n    get(){ // 取值\n        return 123\n    },\n    set(val){ // 设置值时触发\n        console.log('setting ')\n        obj.school = val // 超出内存 mag size\n    }\n})\nconsole.log(obj)\n```\n\n--- \n#### 参考\n[掘金 - MVVM](https://juejin.im/post/5e7410ed51882549087dc365#heading-0)  \n[发布订阅模式 && 观察者模式](https://blog.csdn.net/hf872914334/article/details/88899326)\n[发布订阅模式 && 观察者模式](https://zhuanlan.zhihu.com/p/51357583)\n[Vue2.0响应原理](https://segmentfault.com/a/1190000019700618)","source":"_posts/MVVM.md","raw":"---\ntitle: MVVM实现（Object.defineProperty && 观察订阅）\ndate: 2020-07-23 21:01:50\ntags: MVVM 框架\n---\n\n### 1. MVVM特点图解\n![MVVM注解图1](/MVVM/MVVM1.png)\n![MVVM注解图2](/MVVM/MVVM2.png)\n![MVVM注解图3](/MVVM/MVVM3.png)\n![MVVM注解图4](/MVVM/MVVM4.png)\n![MVVM注解图5](/MVVM/MVVM5.png)\n\n### 2. MVVM的功能：\n+ 给所有data属性值都设置数据劫持，绑定好属性观察。（*也是深度响应原理*）\n+ 结合观察订阅者模式\n\n### 3.代码实现：(`MVVM `包含双向数据绑定、`v-model`、`computed`)\n```js\n/**\n * let zs = new Vue({\n *     el: '#app',\n *     data: {a: 1}\n * })\n */\n\n/**\n *\n * @param options 参考vue实例化时传进的对象,代表我们存储的所有对象\n */\nfunction demoVue(options = {}) {\n    this.$options = options;  // 当前实例，存储存进的对象\n    let data = this._data = this.$options.data;  // 当前实例，存储options.data 准备像vue一样观察数据\n    observe(data);\n    // 为了代理_data属性。可以直接在实例的时候取到data，再用define一次\n    for (let key in data) {\n        Object.defineProperty(this,key,{\n            enumerable: true,\n            get() {\n                return this._data[key]; // 将this._data.key 通过定义对象的方式 赋给了 this.key，模拟vue\n            },\n            set(newVal) {\n                this._data[key] = newVal;\n            }\n        })\n    }\n    let computed = this.$options.computed;\n    operatedComputed.call(this)  // computedde 的操作需放在数据都已被观察完，并挂载到_data里\n   \n    new Compile(options.el, this);\n}\n\nfunction operatedComputed() { // computed 处理函数\n    let vm = this\n    let computedFn = this.$options.computed\n    Object.keys(computedFn).forEach(function(key){\n        // \bcomputed挂载到vm上\n        Object.defineProperty(vm,key,{\n            get: typeof computedFn[key] === 'function' ?  computedFn[key] : computedFn[key].get,\n            set() {\n\n            }\n        })\n    })\n}\n\nfunction observe(data) { // 数据劫持，增加Object.defineProperty\n     if (typeof data !== 'object') return;\n     return new Observe(data); // 方便递归\n}\n\n/**\n * 把数据编译到dom上，实现数据绑定\n * @param el 替换的dom\n * @param vm 实例\n * @constructor\n * note:\n * (1) 文档碎片\n * (2) regExp.$n: --[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n]\n * (3)正则图形化 https://regexper.com/\n * (4)正则对照表：http://tool.oschina.net/uploads/apidocs/jquery/regexp.html\n */\nfunction Compile(el, vm) {\n    vm.$el = document.querySelector(el);\n    let fragment = document.createDocumentFragment(); // 之所以用了文档碎片，是因为这样造成页面渲染回流的代价最低\n    let child;\n    // 此处用到了appendChild的一个特性：对于被添加的子节点，如果之前已经存在，则会销毁自己在dom树的节点，然后把自己添加到新的地方\n    // 因此vm.$el.firstChild才会不停地切换成下一个子节点。\n    // --[https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild]\n\n    while (child = vm.$el.firstChild) {\n        fragment.appendChild(child);\n    }\n    replace(fragment);\n    /**\n     * Array.from 将伪数组对象转为数组实例\n      textContext: 节点内容\n      节点类型 --[https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType] nodeType为3时，是element或者属性中的字\n      之所以抽离出方法，是因为想要重复调用，当子节点里还有子节点时，可以调用。\n     */\n    function replace(fragment) {\n        Array.from(fragment.childNodes).forEach(function (node) {\n            let text = node.textContent;\n            let exp;\n            let reg = /\\{\\{(.*)\\}\\}/;\n            if (node.nodeType === 3 && reg.test(text)) {\n               exp = text.replace(reg, '$1'); // 正则匹配中第一个括号所代表的内容\n                let pointArr = exp.split('.'); // a.a b\n                let existVal = vm;\n                pointArr.forEach(function (key) { // vm.a.a  vm.b\n                    existVal = existVal[key];\n                });\n                // 添加一个watcher事件 监听了值的变化\n                new Watcher(vm,exp,function (newVal) {\n                    node.textContent = text.replace(reg, newVal);\n                });\n                 // @todo此处parser有待完善，只能兼容纯{{}}，带上其他字符会让existVal失效\n                node.textContent = text.replace(reg, existVal);\n            }\n            if (node.nodeType === 1 ) { // v-model实现\n                let attr = Array.from(node.attributes)\n                let attr_value;\n                attr.forEach(function(item){\n                    if (item.name === 'v-model') {\n                        attr_value = item.value\n                        new Watcher(vm,attr_value, function(newVal) {\n                            node.value = newVal\n                        })\n                        node.addEventListener('input',function(e){\n                            vm[attr_value] = e.target.value\n                        })  \n                    }\n                   \n                })\n            }\n            if (node.childNodes) {\n                replace(node);\n            }\n            vm.$el.appendChild(fragment); // 文档碎片的内容重新添加到原来挂载的元素里\n        });\n    }\n}\n\n\n/**\n * @param data\n * @returns {*}\n * @constructor\n */\nfunction Observe(data) { // 实际观察方法,设置 Object.defineProperty\n    let dep = new Dep();\n    for (let key in data) {\n        let val = data[key];\n        observe(val); // 这里就已经可以递归了\n        Object.defineProperty(data,key, {\n            enumerable: true,\n            get() {\n                // 此时Dep.target是this\n                if (Dep.target) {\n                    dep.addSub(Dep.target); // 添加事件订阅（watcher 的 push）\n                }\n                return val;\n            },\n            set(newVal) {\n                if (newVal ===  val) { // 值没发生变化\n                    return; \n                } else {\n                    val = newVal; // 更新值。get获取值时，也可以得到最新的值。\n                    observe(newVal); // 这里是为了给新值也添上观察者\n                    dep.notify(); // 添加事件的通知更新（watcher的update）\n                }\n            }\n        })\n    }\n}\n\n/**\n * 发布订阅函数\n * @Dep\n */\nfunction Dep() {\n    this.subs = []; // 事件池\n}\nDep.prototype.addSub = function (sub) { // 订阅\n    this.subs.push(sub);\n};\nDep.prototype.notify = function () { // 通知\n    this.subs.forEach(sub => {\n        sub.update();\n    })\n};\n\n/**\n * 事件池其中的一个\n * @param vm: 实例环境（总的数据来源）\n * @param 正则表达式的遍历对象exp (要更改的对象)\n * @param fn（处理的回调函数）\n * @constructor\n */\nfunction Watcher(vm,exp,fn) { // fn是回调函数 new的时候传进来\n    this.vm = vm;\n    this.exp = exp;\n    this.fn = fn;\n\n    // 添加到订阅中\n    // Dep.target ??? 扮演着一个watcher对象，也是Watcher的实例  它和 Object.defineProperty的get会有反应\n    Dep.target = this;\n    let val = vm;\n    let arr = exp.split('.');\n    arr.forEach(function (k) { // 这里获取 this.a.a时还是会触发到默认的getter\n        val = val[k];\n    });\n    Dep.target = null;\n\n}\nWatcher.prototype.update = function () { // watcher的更新方法\n    let val = this.vm;\n    let arr = this.exp.split('.');\n    arr.forEach(function (k) {\n        val = val[k];\n    });\n    this.fn(val); // 把最新值传进callback\n};\n\n\n```\n\n\n```HTML\n<body>\n    <div id=\"app\">\n        <div>{{a.a}}</div>\n        <div>{{b}}</div>\n        <input type=\"text\" v-model=\"b\">\n        <div>{{cacultate_c}}</div>\n    </div>\n</body>\n<!--<script src=\"../dist/my_bundle.js\"></script>-->\n<script src=\"./compile.js\"></script>\n<script>\n    // 调用\n    let little = new demoVue({\n        el: \"#app\",\n        data: {\n            a: {a:\"是a\"},\n            b: \"是b\"\n        },\n        computed: {\n            cacultate_c: function() {\n                return this.a.a + this.b;\n            },\n            cacultate_d: {\n                get() {\n                    return this.a.a + this.b + this.b\n                },\n                set(val) {\n                    this.a = val\n                }\n            }\n        }\n    });\n\n```\n\n\n---\n\n### 知识储备\n1、 `Object.defineProperty` 给对象设置某属性，并且可以设置setter，用于绑定属性。\n\n```js\nlet obj = {}\nObject.defineProperty(obj, 'school',{\n    configurable: true, // 让 delete 更新属性值 生效\n    enumberable: true,\n    get(){ // 取值\n        return 123\n    },\n    set(val){ // 设置值时触发\n        console.log('setting ')\n        obj.school = val // 超出内存 mag size\n    }\n})\nconsole.log(obj)\n```\n\n--- \n#### 参考\n[掘金 - MVVM](https://juejin.im/post/5e7410ed51882549087dc365#heading-0)  \n[发布订阅模式 && 观察者模式](https://blog.csdn.net/hf872914334/article/details/88899326)\n[发布订阅模式 && 观察者模式](https://zhuanlan.zhihu.com/p/51357583)\n[Vue2.0响应原理](https://segmentfault.com/a/1190000019700618)","slug":"MVVM","published":1,"updated":"2020-07-25T11:31:21.547Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr9m0009z5o885m74lx4","content":"<h3 id=\"1-MVVM特点图解\"><a href=\"#1-MVVM特点图解\" class=\"headerlink\" title=\"1. MVVM特点图解\"></a>1. MVVM特点图解</h3><p><img src=\"/2020/07/23/MVVM/MVVM1.png\" alt=\"MVVM注解图1\"><br><img src=\"/2020/07/23/MVVM/MVVM2.png\" alt=\"MVVM注解图2\"><br><img src=\"/2020/07/23/MVVM/MVVM3.png\" alt=\"MVVM注解图3\"><br><img src=\"/2020/07/23/MVVM/MVVM4.png\" alt=\"MVVM注解图4\"><br><img src=\"/2020/07/23/MVVM/MVVM5.png\" alt=\"MVVM注解图5\"></p>\n<h3 id=\"2-MVVM的功能：\"><a href=\"#2-MVVM的功能：\" class=\"headerlink\" title=\"2. MVVM的功能：\"></a>2. MVVM的功能：</h3><ul>\n<li>给所有data属性值都设置数据劫持，绑定好属性观察。（<em>也是深度响应原理</em>）</li>\n<li>结合观察订阅者模式</li>\n</ul>\n<h3 id=\"3-代码实现：-MVVM包含双向数据绑定、v-model、computed\"><a href=\"#3-代码实现：-MVVM包含双向数据绑定、v-model、computed\" class=\"headerlink\" title=\"3.代码实现：(MVVM包含双向数据绑定、v-model、computed)\"></a>3.代码实现：(<code>MVVM</code>包含双向数据绑定、<code>v-model</code>、<code>computed</code>)</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * let zs = new Vue(&#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     el: '#app',</span></span><br><span class=\"line\"><span class=\"comment\"> *     data: &#123;a: 1&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>options 参考vue实例化时传进的对象,代表我们存储的所有对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demoVue</span>(<span class=\"params\">options = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$options = options;  <span class=\"comment\">// 当前实例，存储存进的对象</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = <span class=\"keyword\">this</span>._data = <span class=\"keyword\">this</span>.$options.data;  <span class=\"comment\">// 当前实例，存储options.data 准备像vue一样观察数据</span></span><br><span class=\"line\">    observe(data);</span><br><span class=\"line\">    <span class=\"comment\">// 为了代理_data属性。可以直接在实例的时候取到data，再用define一次</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.defineProperty(<span class=\"keyword\">this</span>,key,&#123;</span><br><span class=\"line\">            enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._data[key]; <span class=\"comment\">// 将this._data.key 通过定义对象的方式 赋给了 this.key，模拟vue</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"keyword\">set</span>(newVal) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>._data[key] = newVal;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> computed = <span class=\"keyword\">this</span>.$options.computed;</span><br><span class=\"line\">    operatedComputed.call(<span class=\"keyword\">this</span>)  <span class=\"comment\">// computedde 的操作需放在数据都已被观察完，并挂载到_data里</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">new</span> Compile(options.el, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">operatedComputed</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// computed 处理函数</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> vm = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> computedFn = <span class=\"keyword\">this</span>.$options.computed</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(computedFn).forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// \bcomputed挂载到vm上</span></span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.defineProperty(vm,key,&#123;</span><br><span class=\"line\">            <span class=\"keyword\">get</span>: typeof computedFn[key] === 'function' ?  computedFn[key] : computedFn[key].<span class=\"keyword\">get</span>,</span><br><span class=\"line\">            <span class=\"keyword\">set</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span>(<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">// 数据劫持，增加Object.defineProperty</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> data !== <span class=\"string\">'object'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Observe(data); <span class=\"comment\">// 方便递归</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 把数据编译到dom上，实现数据绑定</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>el 替换的dom</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>vm 实例</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@constructor</span></span></span><br><span class=\"line\"><span class=\"comment\"> * note:</span></span><br><span class=\"line\"><span class=\"comment\"> * (1) 文档碎片</span></span><br><span class=\"line\"><span class=\"comment\"> * (2) regExp.$n: --[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n]</span></span><br><span class=\"line\"><span class=\"comment\"> * (3)正则图形化 https://regexper.com/</span></span><br><span class=\"line\"><span class=\"comment\"> * (4)正则对照表：http://tool.oschina.net/uploads/apidocs/jquery/regexp.html</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Compile</span>(<span class=\"params\">el, vm</span>) </span>&#123;</span><br><span class=\"line\">    vm.$el = <span class=\"built_in\">document</span>.querySelector(el);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment(); <span class=\"comment\">// 之所以用了文档碎片，是因为这样造成页面渲染回流的代价最低</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> child;</span><br><span class=\"line\">    <span class=\"comment\">// 此处用到了appendChild的一个特性：对于被添加的子节点，如果之前已经存在，则会销毁自己在dom树的节点，然后把自己添加到新的地方</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此vm.$el.firstChild才会不停地切换成下一个子节点。</span></span><br><span class=\"line\">    <span class=\"comment\">// --[https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild]</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (child = vm.$el.firstChild) &#123;</span><br><span class=\"line\">        fragment.appendChild(child);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    replace(fragment);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Array.from 将伪数组对象转为数组实例</span></span><br><span class=\"line\"><span class=\"comment\">      textContext: 节点内容</span></span><br><span class=\"line\"><span class=\"comment\">      节点类型 --[https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType] nodeType为3时，是element或者属性中的字</span></span><br><span class=\"line\"><span class=\"comment\">      之所以抽离出方法，是因为想要重复调用，当子节点里还有子节点时，可以调用。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replace</span>(<span class=\"params\">fragment</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">Array</span>.from(fragment.childNodes).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> text = node.textContent;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> exp;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> reg = <span class=\"regexp\">/\\&#123;\\&#123;(.*)\\&#125;\\&#125;/</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.nodeType === <span class=\"number\">3</span> &amp;&amp; reg.test(text)) &#123;</span><br><span class=\"line\">               exp = text.replace(reg, <span class=\"string\">'$1'</span>); <span class=\"comment\">// 正则匹配中第一个括号所代表的内容</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> pointArr = exp.split(<span class=\"string\">'.'</span>); <span class=\"comment\">// a.a b</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> existVal = vm;</span><br><span class=\"line\">                pointArr.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123; <span class=\"comment\">// vm.a.a  vm.b</span></span><br><span class=\"line\">                    existVal = existVal[key];</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                <span class=\"comment\">// 添加一个watcher事件 监听了值的变化</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> Watcher(vm,exp,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newVal</span>) </span>&#123;</span><br><span class=\"line\">                    node.textContent = text.replace(reg, newVal);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                 <span class=\"comment\">// @todo此处parser有待完善，只能兼容纯&#123;&#123;&#125;&#125;，带上其他字符会让existVal失效</span></span><br><span class=\"line\">                node.textContent = text.replace(reg, existVal);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.nodeType === <span class=\"number\">1</span> ) &#123; <span class=\"comment\">// v-model实现</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> attr = <span class=\"built_in\">Array</span>.from(node.attributes)</span><br><span class=\"line\">                <span class=\"keyword\">let</span> attr_value;</span><br><span class=\"line\">                attr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (item.name === <span class=\"string\">'v-model'</span>) &#123;</span><br><span class=\"line\">                        attr_value = item.value</span><br><span class=\"line\">                        <span class=\"keyword\">new</span> Watcher(vm,attr_value, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newVal</span>) </span>&#123;</span><br><span class=\"line\">                            node.value = newVal</span><br><span class=\"line\">                        &#125;)</span><br><span class=\"line\">                        node.addEventListener(<span class=\"string\">'input'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">                            vm[attr_value] = e.target.value</span><br><span class=\"line\">                        &#125;)  </span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                   </span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.childNodes) &#123;</span><br><span class=\"line\">                replace(node);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            vm.$el.appendChild(fragment); <span class=\"comment\">// 文档碎片的内容重新添加到原来挂载的元素里</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">data</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns <span class=\"type\">&#123;*&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@constructor</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Observe</span>(<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">// 实际观察方法,设置 Object.defineProperty</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> dep = <span class=\"keyword\">new</span> Dep();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> val = data[key];</span><br><span class=\"line\">        observe(val); <span class=\"comment\">// 这里就已经可以递归了</span></span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.defineProperty(data,key, &#123;</span><br><span class=\"line\">            enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 此时Dep.target是this</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Dep.target) &#123;</span><br><span class=\"line\">                    dep.addSub(Dep.target); <span class=\"comment\">// 添加事件订阅（watcher 的 push）</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"keyword\">set</span>(newVal) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (newVal ===  val) &#123; <span class=\"comment\">// 值没发生变化</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span>; </span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    val = newVal; <span class=\"comment\">// 更新值。get获取值时，也可以得到最新的值。</span></span><br><span class=\"line\">                    observe(newVal); <span class=\"comment\">// 这里是为了给新值也添上观察者</span></span><br><span class=\"line\">                    dep.notify(); <span class=\"comment\">// 添加事件的通知更新（watcher的update）</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 发布订阅函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Dep</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dep</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs = []; <span class=\"comment\">// 事件池</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Dep.prototype.addSub = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">sub</span>) </span>&#123; <span class=\"comment\">// 订阅</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs.push(sub);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Dep.prototype.notify = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 通知</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs.forEach(<span class=\"function\"><span class=\"params\">sub</span> =&gt;</span> &#123;</span><br><span class=\"line\">        sub.update();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 事件池其中的一个</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>vm: 实例环境（总的数据来源）</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>正则表达式的遍历对象exp (要更改的对象)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>fn（处理的回调函数）</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@constructor</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Watcher</span>(<span class=\"params\">vm,exp,fn</span>) </span>&#123; <span class=\"comment\">// fn是回调函数 new的时候传进来</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.vm = vm;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.exp = exp;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fn = fn;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加到订阅中</span></span><br><span class=\"line\">    <span class=\"comment\">// Dep.target ??? 扮演着一个watcher对象，也是Watcher的实例  它和 Object.defineProperty的get会有反应</span></span><br><span class=\"line\">    Dep.target = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> val = vm;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = exp.split(<span class=\"string\">'.'</span>);</span><br><span class=\"line\">    arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">k</span>) </span>&#123; <span class=\"comment\">// 这里获取 this.a.a时还是会触发到默认的getter</span></span><br><span class=\"line\">        val = val[k];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Dep.target = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Watcher.prototype.update = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// watcher的更新方法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> val = <span class=\"keyword\">this</span>.vm;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = <span class=\"keyword\">this</span>.exp.split(<span class=\"string\">'.'</span>);</span><br><span class=\"line\">    arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">k</span>) </span>&#123;</span><br><span class=\"line\">        val = val[k];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fn(val); <span class=\"comment\">// 把最新值传进callback</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;a.a&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;b&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"b\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;cacultate_c&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--&lt;script src=\"../dist/my_bundle.js\"&gt;&lt;/script&gt;--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./compile.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// 调用</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> little = <span class=\"keyword\">new</span> demoVue(&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        el: <span class=\"string\">\"#app\"</span>,</span></span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\"><span class=\"actionscript\">            a: &#123;a:<span class=\"string\">\"是a\"</span>&#125;,</span></span><br><span class=\"line\"><span class=\"actionscript\">            b: <span class=\"string\">\"是b\"</span></span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        computed: &#123;</span><br><span class=\"line\"><span class=\"actionscript\">            cacultate_c: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">                <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a.a + <span class=\"keyword\">this</span>.b;</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            cacultate_d: &#123;</span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">get</span>() &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a.a + <span class=\"keyword\">this</span>.b + <span class=\"keyword\">this</span>.b</span></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">set</span>(val) &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">                    <span class=\"keyword\">this</span>.a = val</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"知识储备\"><a href=\"#知识储备\" class=\"headerlink\" title=\"知识储备\"></a>知识储备</h3><p>1、 <code>Object.defineProperty</code> 给对象设置某属性，并且可以设置setter，用于绑定属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'school'</span>,&#123;</span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>, <span class=\"comment\">// 让 delete 更新属性值 生效</span></span><br><span class=\"line\">    enumberable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"keyword\">get</span>()&#123; <span class=\"comment\">// 取值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">123</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span>(val)&#123; <span class=\"comment\">// 设置值时触发</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'setting '</span>)</span><br><span class=\"line\">        obj.school = val <span class=\"comment\">// 超出内存 mag size</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://juejin.im/post/5e7410ed51882549087dc365#heading-0\" target=\"_blank\" rel=\"noopener\">掘金 - MVVM</a><br><a href=\"https://blog.csdn.net/hf872914334/article/details/88899326\" target=\"_blank\" rel=\"noopener\">发布订阅模式 &amp;&amp; 观察者模式</a><br><a href=\"https://zhuanlan.zhihu.com/p/51357583\" target=\"_blank\" rel=\"noopener\">发布订阅模式 &amp;&amp; 观察者模式</a><br><a href=\"https://segmentfault.com/a/1190000019700618\" target=\"_blank\" rel=\"noopener\">Vue2.0响应原理</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-MVVM特点图解\"><a href=\"#1-MVVM特点图解\" class=\"headerlink\" title=\"1. MVVM特点图解\"></a>1. MVVM特点图解</h3><p><img src=\"/2020/07/23/MVVM/MVVM1.png\" alt=\"MVVM注解图1\"><br><img src=\"/2020/07/23/MVVM/MVVM2.png\" alt=\"MVVM注解图2\"><br><img src=\"/2020/07/23/MVVM/MVVM3.png\" alt=\"MVVM注解图3\"><br><img src=\"/2020/07/23/MVVM/MVVM4.png\" alt=\"MVVM注解图4\"><br><img src=\"/2020/07/23/MVVM/MVVM5.png\" alt=\"MVVM注解图5\"></p>\n<h3 id=\"2-MVVM的功能：\"><a href=\"#2-MVVM的功能：\" class=\"headerlink\" title=\"2. MVVM的功能：\"></a>2. MVVM的功能：</h3><ul>\n<li>给所有data属性值都设置数据劫持，绑定好属性观察。（<em>也是深度响应原理</em>）</li>\n<li>结合观察订阅者模式</li>\n</ul>\n<h3 id=\"3-代码实现：-MVVM包含双向数据绑定、v-model、computed\"><a href=\"#3-代码实现：-MVVM包含双向数据绑定、v-model、computed\" class=\"headerlink\" title=\"3.代码实现：(MVVM包含双向数据绑定、v-model、computed)\"></a>3.代码实现：(<code>MVVM</code>包含双向数据绑定、<code>v-model</code>、<code>computed</code>)</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * let zs = new Vue(&#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     el: '#app',</span></span><br><span class=\"line\"><span class=\"comment\"> *     data: &#123;a: 1&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>options 参考vue实例化时传进的对象,代表我们存储的所有对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demoVue</span>(<span class=\"params\">options = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$options = options;  <span class=\"comment\">// 当前实例，存储存进的对象</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = <span class=\"keyword\">this</span>._data = <span class=\"keyword\">this</span>.$options.data;  <span class=\"comment\">// 当前实例，存储options.data 准备像vue一样观察数据</span></span><br><span class=\"line\">    observe(data);</span><br><span class=\"line\">    <span class=\"comment\">// 为了代理_data属性。可以直接在实例的时候取到data，再用define一次</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.defineProperty(<span class=\"keyword\">this</span>,key,&#123;</span><br><span class=\"line\">            enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._data[key]; <span class=\"comment\">// 将this._data.key 通过定义对象的方式 赋给了 this.key，模拟vue</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"keyword\">set</span>(newVal) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>._data[key] = newVal;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> computed = <span class=\"keyword\">this</span>.$options.computed;</span><br><span class=\"line\">    operatedComputed.call(<span class=\"keyword\">this</span>)  <span class=\"comment\">// computedde 的操作需放在数据都已被观察完，并挂载到_data里</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">new</span> Compile(options.el, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">operatedComputed</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// computed 处理函数</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> vm = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> computedFn = <span class=\"keyword\">this</span>.$options.computed</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.keys(computedFn).forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// \bcomputed挂载到vm上</span></span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.defineProperty(vm,key,&#123;</span><br><span class=\"line\">            <span class=\"keyword\">get</span>: typeof computedFn[key] === 'function' ?  computedFn[key] : computedFn[key].<span class=\"keyword\">get</span>,</span><br><span class=\"line\">            <span class=\"keyword\">set</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span>(<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">// 数据劫持，增加Object.defineProperty</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> data !== <span class=\"string\">'object'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Observe(data); <span class=\"comment\">// 方便递归</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 把数据编译到dom上，实现数据绑定</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>el 替换的dom</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>vm 实例</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@constructor</span></span></span><br><span class=\"line\"><span class=\"comment\"> * note:</span></span><br><span class=\"line\"><span class=\"comment\"> * (1) 文档碎片</span></span><br><span class=\"line\"><span class=\"comment\"> * (2) regExp.$n: --[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n]</span></span><br><span class=\"line\"><span class=\"comment\"> * (3)正则图形化 https://regexper.com/</span></span><br><span class=\"line\"><span class=\"comment\"> * (4)正则对照表：http://tool.oschina.net/uploads/apidocs/jquery/regexp.html</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Compile</span>(<span class=\"params\">el, vm</span>) </span>&#123;</span><br><span class=\"line\">    vm.$el = <span class=\"built_in\">document</span>.querySelector(el);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment(); <span class=\"comment\">// 之所以用了文档碎片，是因为这样造成页面渲染回流的代价最低</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> child;</span><br><span class=\"line\">    <span class=\"comment\">// 此处用到了appendChild的一个特性：对于被添加的子节点，如果之前已经存在，则会销毁自己在dom树的节点，然后把自己添加到新的地方</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此vm.$el.firstChild才会不停地切换成下一个子节点。</span></span><br><span class=\"line\">    <span class=\"comment\">// --[https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild]</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (child = vm.$el.firstChild) &#123;</span><br><span class=\"line\">        fragment.appendChild(child);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    replace(fragment);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Array.from 将伪数组对象转为数组实例</span></span><br><span class=\"line\"><span class=\"comment\">      textContext: 节点内容</span></span><br><span class=\"line\"><span class=\"comment\">      节点类型 --[https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType] nodeType为3时，是element或者属性中的字</span></span><br><span class=\"line\"><span class=\"comment\">      之所以抽离出方法，是因为想要重复调用，当子节点里还有子节点时，可以调用。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replace</span>(<span class=\"params\">fragment</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">Array</span>.from(fragment.childNodes).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> text = node.textContent;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> exp;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> reg = <span class=\"regexp\">/\\&#123;\\&#123;(.*)\\&#125;\\&#125;/</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.nodeType === <span class=\"number\">3</span> &amp;&amp; reg.test(text)) &#123;</span><br><span class=\"line\">               exp = text.replace(reg, <span class=\"string\">'$1'</span>); <span class=\"comment\">// 正则匹配中第一个括号所代表的内容</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> pointArr = exp.split(<span class=\"string\">'.'</span>); <span class=\"comment\">// a.a b</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> existVal = vm;</span><br><span class=\"line\">                pointArr.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123; <span class=\"comment\">// vm.a.a  vm.b</span></span><br><span class=\"line\">                    existVal = existVal[key];</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                <span class=\"comment\">// 添加一个watcher事件 监听了值的变化</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> Watcher(vm,exp,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">newVal</span>) </span>&#123;</span><br><span class=\"line\">                    node.textContent = text.replace(reg, newVal);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                 <span class=\"comment\">// @todo此处parser有待完善，只能兼容纯&#123;&#123;&#125;&#125;，带上其他字符会让existVal失效</span></span><br><span class=\"line\">                node.textContent = text.replace(reg, existVal);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.nodeType === <span class=\"number\">1</span> ) &#123; <span class=\"comment\">// v-model实现</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> attr = <span class=\"built_in\">Array</span>.from(node.attributes)</span><br><span class=\"line\">                <span class=\"keyword\">let</span> attr_value;</span><br><span class=\"line\">                attr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (item.name === <span class=\"string\">'v-model'</span>) &#123;</span><br><span class=\"line\">                        attr_value = item.value</span><br><span class=\"line\">                        <span class=\"keyword\">new</span> Watcher(vm,attr_value, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newVal</span>) </span>&#123;</span><br><span class=\"line\">                            node.value = newVal</span><br><span class=\"line\">                        &#125;)</span><br><span class=\"line\">                        node.addEventListener(<span class=\"string\">'input'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">                            vm[attr_value] = e.target.value</span><br><span class=\"line\">                        &#125;)  </span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                   </span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.childNodes) &#123;</span><br><span class=\"line\">                replace(node);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            vm.$el.appendChild(fragment); <span class=\"comment\">// 文档碎片的内容重新添加到原来挂载的元素里</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"variable\">data</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns <span class=\"type\">&#123;*&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@constructor</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Observe</span>(<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">// 实际观察方法,设置 Object.defineProperty</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> dep = <span class=\"keyword\">new</span> Dep();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> val = data[key];</span><br><span class=\"line\">        observe(val); <span class=\"comment\">// 这里就已经可以递归了</span></span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.defineProperty(data,key, &#123;</span><br><span class=\"line\">            enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 此时Dep.target是this</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Dep.target) &#123;</span><br><span class=\"line\">                    dep.addSub(Dep.target); <span class=\"comment\">// 添加事件订阅（watcher 的 push）</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"keyword\">set</span>(newVal) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (newVal ===  val) &#123; <span class=\"comment\">// 值没发生变化</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span>; </span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    val = newVal; <span class=\"comment\">// 更新值。get获取值时，也可以得到最新的值。</span></span><br><span class=\"line\">                    observe(newVal); <span class=\"comment\">// 这里是为了给新值也添上观察者</span></span><br><span class=\"line\">                    dep.notify(); <span class=\"comment\">// 添加事件的通知更新（watcher的update）</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 发布订阅函数</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Dep</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dep</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs = []; <span class=\"comment\">// 事件池</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Dep.prototype.addSub = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">sub</span>) </span>&#123; <span class=\"comment\">// 订阅</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs.push(sub);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Dep.prototype.notify = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 通知</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs.forEach(<span class=\"function\"><span class=\"params\">sub</span> =&gt;</span> &#123;</span><br><span class=\"line\">        sub.update();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 事件池其中的一个</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>vm: 实例环境（总的数据来源）</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>正则表达式的遍历对象exp (要更改的对象)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>fn（处理的回调函数）</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@constructor</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Watcher</span>(<span class=\"params\">vm,exp,fn</span>) </span>&#123; <span class=\"comment\">// fn是回调函数 new的时候传进来</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.vm = vm;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.exp = exp;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fn = fn;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加到订阅中</span></span><br><span class=\"line\">    <span class=\"comment\">// Dep.target ??? 扮演着一个watcher对象，也是Watcher的实例  它和 Object.defineProperty的get会有反应</span></span><br><span class=\"line\">    Dep.target = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> val = vm;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = exp.split(<span class=\"string\">'.'</span>);</span><br><span class=\"line\">    arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">k</span>) </span>&#123; <span class=\"comment\">// 这里获取 this.a.a时还是会触发到默认的getter</span></span><br><span class=\"line\">        val = val[k];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Dep.target = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Watcher.prototype.update = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// watcher的更新方法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> val = <span class=\"keyword\">this</span>.vm;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arr = <span class=\"keyword\">this</span>.exp.split(<span class=\"string\">'.'</span>);</span><br><span class=\"line\">    arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">k</span>) </span>&#123;</span><br><span class=\"line\">        val = val[k];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fn(val); <span class=\"comment\">// 把最新值传进callback</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"app\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;a.a&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;b&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">v-model</span>=<span class=\"string\">\"b\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;cacultate_c&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--&lt;script src=\"../dist/my_bundle.js\"&gt;&lt;/script&gt;--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./compile.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"comment\">// 调用</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> little = <span class=\"keyword\">new</span> demoVue(&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">        el: <span class=\"string\">\"#app\"</span>,</span></span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\"><span class=\"actionscript\">            a: &#123;a:<span class=\"string\">\"是a\"</span>&#125;,</span></span><br><span class=\"line\"><span class=\"actionscript\">            b: <span class=\"string\">\"是b\"</span></span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        computed: &#123;</span><br><span class=\"line\"><span class=\"actionscript\">            cacultate_c: <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">                <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a.a + <span class=\"keyword\">this</span>.b;</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            cacultate_d: &#123;</span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">get</span>() &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a.a + <span class=\"keyword\">this</span>.b + <span class=\"keyword\">this</span>.b</span></span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">set</span>(val) &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">                    <span class=\"keyword\">this</span>.a = val</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"知识储备\"><a href=\"#知识储备\" class=\"headerlink\" title=\"知识储备\"></a>知识储备</h3><p>1、 <code>Object.defineProperty</code> 给对象设置某属性，并且可以设置setter，用于绑定属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'school'</span>,&#123;</span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>, <span class=\"comment\">// 让 delete 更新属性值 生效</span></span><br><span class=\"line\">    enumberable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"keyword\">get</span>()&#123; <span class=\"comment\">// 取值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">123</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span>(val)&#123; <span class=\"comment\">// 设置值时触发</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'setting '</span>)</span><br><span class=\"line\">        obj.school = val <span class=\"comment\">// 超出内存 mag size</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://juejin.im/post/5e7410ed51882549087dc365#heading-0\" target=\"_blank\" rel=\"noopener\">掘金 - MVVM</a><br><a href=\"https://blog.csdn.net/hf872914334/article/details/88899326\" target=\"_blank\" rel=\"noopener\">发布订阅模式 &amp;&amp; 观察者模式</a><br><a href=\"https://zhuanlan.zhihu.com/p/51357583\" target=\"_blank\" rel=\"noopener\">发布订阅模式 &amp;&amp; 观察者模式</a><br><a href=\"https://segmentfault.com/a/1190000019700618\" target=\"_blank\" rel=\"noopener\">Vue2.0响应原理</a></p>\n"},{"title":"call && apply && bind","date":"2020-04-09T09:22:35.000Z","_content":"\n#### 1. apply\n调用一个具有`给定this值`的函数，以及`作为一个数组（或类似数组对象）`提供的参数。\n语法：\n```javascript\n    function.apply(thisArg, [argsArray])\n```\n\n<div class=\"tip\">\n        如果这个函数处于非严格模式下，`thisArg`指定为 `null` 或 `undefined` 时会自动替换为`指向全局对象`，原始值会被包装！！！\n</div>\n\n 基础用法\n```javascript\n    const numbers = [5, 6, 2, 3, 7];\n    const max = Math.max.apply(null, numbers);\n    console.log(max);// expected output: 7\n```\n\n将A数组里的元素都添加到B数组 （apply有种`循环参数数组`的能力）\n```javascript\n    Array.push.apply(BArray,AArray)\n    // 等同于\n    BArray.push(...AArray)\n```\n\n#### 2. call\n调用一个具有`给定this值`的函数，以及一个或多个参数。\n语法：\n```javascript\n    function.call(thisArg, arg1, arg2, ...) \n```\n\n用来继承\n```javascript\n    function Product(name, price) {\n      this.name = name;\n      this.price = price;\n    }\n    \n    function Food(name, price) {\n      Product.call(this, name, price);\n      this.category = 'food';\n    }\n    \n    console.log(new Food('cheese', 5).name);\n    // expected output: \"cheese\"\n```\n\n绑定上下文\n```javascript\n    function greet() {\n      var reply = [this.animal, 'typically sleep between', this.sleepDuration].join(' ');\n      console.log(reply);\n    }\n    \n    var obj = {\n      animal: 'cats', sleepDuration: '12 and 16 hours'\n    };\n    \n    greet.call(obj);  // cats typically sleep between 12 and 16 hours\n```\n\n非严格模式下，不传值则默认上下文是全局对象\n```javascript\n    var sData = 'Wisen';\n    \n    function display() {\n      console.log('sData value is %s ', this.sData);\n    }\n    \n    display.call();  // sData value is Wisen   这里上下文是window\n```\n\n#### 3.bind\n该方法创建一个新的函数，在 `bind() `被调用时，这个`新函数`的 `this 被指定为 bind() 的第一个参数`，而其余参数将作为新函数的参数，供调用时使用。\n也就是说，返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。\n语法：\n```javascript\n    function.bind(thisArg[, arg1[, arg2[, ...]]])\n```\n\n<div class=\"tip\">\n1 使用`new`构造函数时，忽略`thisArg` \n---※---\n2 在`setTimeout`中回调函数使用时，`thisArg`的任何值都将转化成`object`\n---※---\n3 如果`thisArg`为`null或undefined`，`执行作用域中的this`将作为新的`thisArg`\n</div> \n\n\n基础用法\n```javascript\n    const module = {\n      x: 42,\n      getX: function() {\n        return this.x;\n      }\n    };\n    \n    const unboundGetX = module.getX;\n    console.log(unboundGetX());\n    // expected output: window.x => undefined\n    \n    const boundGetX = unboundGetX.bind(module);\n    console.log(boundGetX());\n    // expected output: 42\n```\n\n偏函数\nbind() 的另一个最简单的用法是使一个函数拥有预设的初始参数。\n只要将这些参数（如果有的话）作为 bind() 的参数写在 this 后面。\n当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。\n```javascript\nfunction list() {\n  return Array.prototype.slice.call(arguments);\n}\n\nfunction addArguments(arg1, arg2) {\n    return arg1 + arg2\n}\n\nvar list1 = list(1, 2, 3); // [1, 2, 3]\n\nvar result1 = addArguments(1, 2); // 3\n\n// 创建一个函数，它拥有预设参数列表。\nvar leadingThirtysevenList = list.bind(null, 37);\n\n// 创建一个函数，它拥有预设的第一个参数\nvar addThirtySeven = addArguments.bind(null, 37); \n\nvar list2 = leadingThirtysevenList(); \n// [37]\n\nvar list3 = leadingThirtysevenList(1, 2, 3); \n// [37, 1, 2, 3]\n\nvar result2 = addThirtySeven(5); \n// 37 + 5 = 42 \n\nvar result3 = addThirtySeven(5, 10);\n// 37 + 5 = 42 ，第二个参数被忽略\n```\n\n有意思的代码\n```javascript\nvar unboundSlice = Array.prototype.slice;\nvar slice = Function.prototype.apply.bind(unboundSlice);\n // 这里的Function.prototype.apply 其实就是apply函数 \nslice(arguments);\n// 等同于 apply.bind(unboundSlice); 也就是slice === Array.prototype.slice\n```\n\n\n假如不支持`bind`的时候\n```javascript\n// Does not work with `new (funcA.bind(thisArg, args))`\nif (!Function.prototype.bind) (function(){\n  var slice = Array.prototype.slice;\n  Function.prototype.bind = function() {\n    var thatFunc = this, thatArg = arguments[0]; // 缓存调用函数，this指向，其它参数\n    var args = slice.call(arguments, 1);\n    if (typeof thatFunc !== 'function') {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new TypeError('Function.prototype.bind - ' +\n             'what is trying to be bound is not callable');\n    }\n    return function(){\n      var funcArgs = args.concat(slice.call(arguments)) // 其它参数合并传入参数，并成统一的函参\n      return thatFunc.apply(thatArg, funcArgs);\n    };\n  };\n})();\n```\n\n#### 4. 三者同否\n+ apply是传参数数组(参数不确定)，call是传参数(参数确定)\n+ apply、call、bind 三者都是为了`改变上下文`，改变函数`内部this`的指向\n+ 通过apply这种方式，您将面临超过JavaScript引擎的参数长度限制的风险\n+ 多次bind也只是bind第一次绑定的值\n\n参考链接：\n[MDN 关于 apply](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n[MDN 关于 bind](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)\n[ChokCocoblog](https://www.cnblogs.com/coco1s/p/4833199.html)\n[模拟实现](https://muyiy.cn/blog/3/3.3.html#call-%E5%92%8C-apply)","source":"_posts/call&apply&bind.md","raw":"---\ntitle: call && apply && bind\ndate: 2020-04-09 17:22:35\ntags: 面试 JS\n---\n\n#### 1. apply\n调用一个具有`给定this值`的函数，以及`作为一个数组（或类似数组对象）`提供的参数。\n语法：\n```javascript\n    function.apply(thisArg, [argsArray])\n```\n\n<div class=\"tip\">\n        如果这个函数处于非严格模式下，`thisArg`指定为 `null` 或 `undefined` 时会自动替换为`指向全局对象`，原始值会被包装！！！\n</div>\n\n 基础用法\n```javascript\n    const numbers = [5, 6, 2, 3, 7];\n    const max = Math.max.apply(null, numbers);\n    console.log(max);// expected output: 7\n```\n\n将A数组里的元素都添加到B数组 （apply有种`循环参数数组`的能力）\n```javascript\n    Array.push.apply(BArray,AArray)\n    // 等同于\n    BArray.push(...AArray)\n```\n\n#### 2. call\n调用一个具有`给定this值`的函数，以及一个或多个参数。\n语法：\n```javascript\n    function.call(thisArg, arg1, arg2, ...) \n```\n\n用来继承\n```javascript\n    function Product(name, price) {\n      this.name = name;\n      this.price = price;\n    }\n    \n    function Food(name, price) {\n      Product.call(this, name, price);\n      this.category = 'food';\n    }\n    \n    console.log(new Food('cheese', 5).name);\n    // expected output: \"cheese\"\n```\n\n绑定上下文\n```javascript\n    function greet() {\n      var reply = [this.animal, 'typically sleep between', this.sleepDuration].join(' ');\n      console.log(reply);\n    }\n    \n    var obj = {\n      animal: 'cats', sleepDuration: '12 and 16 hours'\n    };\n    \n    greet.call(obj);  // cats typically sleep between 12 and 16 hours\n```\n\n非严格模式下，不传值则默认上下文是全局对象\n```javascript\n    var sData = 'Wisen';\n    \n    function display() {\n      console.log('sData value is %s ', this.sData);\n    }\n    \n    display.call();  // sData value is Wisen   这里上下文是window\n```\n\n#### 3.bind\n该方法创建一个新的函数，在 `bind() `被调用时，这个`新函数`的 `this 被指定为 bind() 的第一个参数`，而其余参数将作为新函数的参数，供调用时使用。\n也就是说，返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。\n语法：\n```javascript\n    function.bind(thisArg[, arg1[, arg2[, ...]]])\n```\n\n<div class=\"tip\">\n1 使用`new`构造函数时，忽略`thisArg` \n---※---\n2 在`setTimeout`中回调函数使用时，`thisArg`的任何值都将转化成`object`\n---※---\n3 如果`thisArg`为`null或undefined`，`执行作用域中的this`将作为新的`thisArg`\n</div> \n\n\n基础用法\n```javascript\n    const module = {\n      x: 42,\n      getX: function() {\n        return this.x;\n      }\n    };\n    \n    const unboundGetX = module.getX;\n    console.log(unboundGetX());\n    // expected output: window.x => undefined\n    \n    const boundGetX = unboundGetX.bind(module);\n    console.log(boundGetX());\n    // expected output: 42\n```\n\n偏函数\nbind() 的另一个最简单的用法是使一个函数拥有预设的初始参数。\n只要将这些参数（如果有的话）作为 bind() 的参数写在 this 后面。\n当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。\n```javascript\nfunction list() {\n  return Array.prototype.slice.call(arguments);\n}\n\nfunction addArguments(arg1, arg2) {\n    return arg1 + arg2\n}\n\nvar list1 = list(1, 2, 3); // [1, 2, 3]\n\nvar result1 = addArguments(1, 2); // 3\n\n// 创建一个函数，它拥有预设参数列表。\nvar leadingThirtysevenList = list.bind(null, 37);\n\n// 创建一个函数，它拥有预设的第一个参数\nvar addThirtySeven = addArguments.bind(null, 37); \n\nvar list2 = leadingThirtysevenList(); \n// [37]\n\nvar list3 = leadingThirtysevenList(1, 2, 3); \n// [37, 1, 2, 3]\n\nvar result2 = addThirtySeven(5); \n// 37 + 5 = 42 \n\nvar result3 = addThirtySeven(5, 10);\n// 37 + 5 = 42 ，第二个参数被忽略\n```\n\n有意思的代码\n```javascript\nvar unboundSlice = Array.prototype.slice;\nvar slice = Function.prototype.apply.bind(unboundSlice);\n // 这里的Function.prototype.apply 其实就是apply函数 \nslice(arguments);\n// 等同于 apply.bind(unboundSlice); 也就是slice === Array.prototype.slice\n```\n\n\n假如不支持`bind`的时候\n```javascript\n// Does not work with `new (funcA.bind(thisArg, args))`\nif (!Function.prototype.bind) (function(){\n  var slice = Array.prototype.slice;\n  Function.prototype.bind = function() {\n    var thatFunc = this, thatArg = arguments[0]; // 缓存调用函数，this指向，其它参数\n    var args = slice.call(arguments, 1);\n    if (typeof thatFunc !== 'function') {\n      // closest thing possible to the ECMAScript 5\n      // internal IsCallable function\n      throw new TypeError('Function.prototype.bind - ' +\n             'what is trying to be bound is not callable');\n    }\n    return function(){\n      var funcArgs = args.concat(slice.call(arguments)) // 其它参数合并传入参数，并成统一的函参\n      return thatFunc.apply(thatArg, funcArgs);\n    };\n  };\n})();\n```\n\n#### 4. 三者同否\n+ apply是传参数数组(参数不确定)，call是传参数(参数确定)\n+ apply、call、bind 三者都是为了`改变上下文`，改变函数`内部this`的指向\n+ 通过apply这种方式，您将面临超过JavaScript引擎的参数长度限制的风险\n+ 多次bind也只是bind第一次绑定的值\n\n参考链接：\n[MDN 关于 apply](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n[MDN 关于 bind](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)\n[ChokCocoblog](https://www.cnblogs.com/coco1s/p/4833199.html)\n[模拟实现](https://muyiy.cn/blog/3/3.3.html#call-%E5%92%8C-apply)","slug":"call&apply&bind","published":1,"updated":"2020-07-12T16:30:17.672Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr9n000az5o8hzgn5m5j","content":"<h4 id=\"1-apply\"><a href=\"#1-apply\" class=\"headerlink\" title=\"1. apply\"></a>1. apply</h4><p>调用一个具有<code>给定this值</code>的函数，以及<code>作为一个数组（或类似数组对象）</code>提供的参数。<br>语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>.<span class=\"title\">apply</span>(<span class=\"params\">thisArg, [argsArray]</span>)</span></span><br></pre></td></tr></table></figure>\n\n<div class=\"tip\">\n        如果这个函数处于非严格模式下，`thisArg`指定为 `null` 或 `undefined` 时会自动替换为`指向全局对象`，原始值会被包装！！！\n</div>\n\n<p> 基础用法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> max = <span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, numbers);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(max);<span class=\"comment\">// expected output: 7</span></span><br></pre></td></tr></table></figure>\n\n<p>将A数组里的元素都添加到B数组 （apply有种<code>循环参数数组</code>的能力）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.push.apply(BArray,AArray)</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">BArray.push(...AArray)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-call\"><a href=\"#2-call\" class=\"headerlink\" title=\"2. call\"></a>2. call</h4><p>调用一个具有<code>给定this值</code>的函数，以及一个或多个参数。<br>语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>.<span class=\"title\">call</span>(<span class=\"params\">thisArg, arg1, arg2, ...</span>)</span></span><br></pre></td></tr></table></figure>\n\n<p>用来继承</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Product</span>(<span class=\"params\">name, price</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span>(<span class=\"params\">name, price</span>) </span>&#123;</span><br><span class=\"line\">  Product.call(<span class=\"keyword\">this</span>, name, price);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.category = <span class=\"string\">'food'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> Food(<span class=\"string\">'cheese'</span>, <span class=\"number\">5</span>).name);</span><br><span class=\"line\"><span class=\"comment\">// expected output: \"cheese\"</span></span><br></pre></td></tr></table></figure>\n\n<p>绑定上下文</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> reply = [<span class=\"keyword\">this</span>.animal, <span class=\"string\">'typically sleep between'</span>, <span class=\"keyword\">this</span>.sleepDuration].join(<span class=\"string\">' '</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(reply);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  animal: <span class=\"string\">'cats'</span>, <span class=\"attr\">sleepDuration</span>: <span class=\"string\">'12 and 16 hours'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">greet.call(obj);  <span class=\"comment\">// cats typically sleep between 12 and 16 hours</span></span><br></pre></td></tr></table></figure>\n\n<p>非严格模式下，不传值则默认上下文是全局对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sData = <span class=\"string\">'Wisen'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">display</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'sData value is %s '</span>, <span class=\"keyword\">this</span>.sData);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">display.call();  <span class=\"comment\">// sData value is Wisen   这里上下文是window</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-bind\"><a href=\"#3-bind\" class=\"headerlink\" title=\"3.bind\"></a>3.bind</h4><p>该方法创建一个新的函数，在 <code>bind()</code>被调用时，这个<code>新函数</code>的 <code>this 被指定为 bind() 的第一个参数</code>，而其余参数将作为新函数的参数，供调用时使用。<br>也就是说，返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。<br>语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>.<span class=\"title\">bind</span>(<span class=\"params\">thisArg[, arg1[, arg2[, ...]]]</span>)</span></span><br></pre></td></tr></table></figure>\n\n<div class=\"tip\">\n1 使用`new`构造函数时，忽略`thisArg` \n---※---\n2 在`setTimeout`中回调函数使用时，`thisArg`的任何值都将转化成`object`\n---※---\n3 如果`thisArg`为`null或undefined`，`执行作用域中的this`将作为新的`thisArg`\n</div> \n\n\n<p>基础用法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">module</span> = &#123;</span><br><span class=\"line\">  x: <span class=\"number\">42</span>,</span><br><span class=\"line\">  getX: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> unboundGetX = <span class=\"built_in\">module</span>.getX;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unboundGetX());</span><br><span class=\"line\"><span class=\"comment\">// expected output: window.x =&gt; undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> boundGetX = unboundGetX.bind(<span class=\"built_in\">module</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(boundGetX());</span><br><span class=\"line\"><span class=\"comment\">// expected output: 42</span></span><br></pre></td></tr></table></figure>\n\n<p>偏函数<br>bind() 的另一个最简单的用法是使一个函数拥有预设的初始参数。<br>只要将这些参数（如果有的话）作为 bind() 的参数写在 this 后面。<br>当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">list</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addArguments</span>(<span class=\"params\">arg1, arg2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg1 + arg2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list1 = list(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result1 = addArguments(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个函数，它拥有预设参数列表。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> leadingThirtysevenList = list.bind(<span class=\"literal\">null</span>, <span class=\"number\">37</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个函数，它拥有预设的第一个参数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> addThirtySeven = addArguments.bind(<span class=\"literal\">null</span>, <span class=\"number\">37</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list2 = leadingThirtysevenList(); </span><br><span class=\"line\"><span class=\"comment\">// [37]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list3 = leadingThirtysevenList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); </span><br><span class=\"line\"><span class=\"comment\">// [37, 1, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result2 = addThirtySeven(<span class=\"number\">5</span>); </span><br><span class=\"line\"><span class=\"comment\">// 37 + 5 = 42 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result3 = addThirtySeven(<span class=\"number\">5</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"comment\">// 37 + 5 = 42 ，第二个参数被忽略</span></span><br></pre></td></tr></table></figure>\n\n<p>有意思的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> unboundSlice = <span class=\"built_in\">Array</span>.prototype.slice;</span><br><span class=\"line\"><span class=\"keyword\">var</span> slice = <span class=\"built_in\">Function</span>.prototype.apply.bind(unboundSlice);</span><br><span class=\"line\"> <span class=\"comment\">// 这里的Function.prototype.apply 其实就是apply函数 </span></span><br><span class=\"line\">slice(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\"><span class=\"comment\">// 等同于 apply.bind(unboundSlice); 也就是slice === Array.prototype.slice</span></span><br></pre></td></tr></table></figure>\n\n\n<p>假如不支持<code>bind</code>的时候</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Does not work with `new (funcA.bind(thisArg, args))`</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"built_in\">Function</span>.prototype.bind) (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> slice = <span class=\"built_in\">Array</span>.prototype.slice;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span>.prototype.bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> thatFunc = <span class=\"keyword\">this</span>, thatArg = <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]; <span class=\"comment\">// 缓存调用函数，this指向，其它参数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> thatFunc !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// closest thing possible to the ECMAScript 5</span></span><br><span class=\"line\">      <span class=\"comment\">// internal IsCallable function</span></span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Function.prototype.bind - '</span> +</span><br><span class=\"line\">             <span class=\"string\">'what is trying to be bound is not callable'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> funcArgs = args.concat(slice.call(<span class=\"built_in\">arguments</span>)) <span class=\"comment\">// 其它参数合并传入参数，并成统一的函参</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> thatFunc.apply(thatArg, funcArgs);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-三者同否\"><a href=\"#4-三者同否\" class=\"headerlink\" title=\"4. 三者同否\"></a>4. 三者同否</h4><ul>\n<li>apply是传参数数组(参数不确定)，call是传参数(参数确定)</li>\n<li>apply、call、bind 三者都是为了<code>改变上下文</code>，改变函数<code>内部this</code>的指向</li>\n<li>通过apply这种方式，您将面临超过JavaScript引擎的参数长度限制的风险</li>\n<li>多次bind也只是bind第一次绑定的值</li>\n</ul>\n<p>参考链接：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\" target=\"_blank\" rel=\"noopener\">MDN 关于 apply</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener\">MDN 关于 bind</a><br><a href=\"https://www.cnblogs.com/coco1s/p/4833199.html\" target=\"_blank\" rel=\"noopener\">ChokCocoblog</a><br><a href=\"https://muyiy.cn/blog/3/3.3.html#call-%E5%92%8C-apply\" target=\"_blank\" rel=\"noopener\">模拟实现</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1-apply\"><a href=\"#1-apply\" class=\"headerlink\" title=\"1. apply\"></a>1. apply</h4><p>调用一个具有<code>给定this值</code>的函数，以及<code>作为一个数组（或类似数组对象）</code>提供的参数。<br>语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>.<span class=\"title\">apply</span>(<span class=\"params\">thisArg, [argsArray]</span>)</span></span><br></pre></td></tr></table></figure>\n\n<div class=\"tip\">\n        如果这个函数处于非严格模式下，`thisArg`指定为 `null` 或 `undefined` 时会自动替换为`指向全局对象`，原始值会被包装！！！\n</div>\n\n<p> 基础用法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> max = <span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, numbers);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(max);<span class=\"comment\">// expected output: 7</span></span><br></pre></td></tr></table></figure>\n\n<p>将A数组里的元素都添加到B数组 （apply有种<code>循环参数数组</code>的能力）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.push.apply(BArray,AArray)</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">BArray.push(...AArray)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-call\"><a href=\"#2-call\" class=\"headerlink\" title=\"2. call\"></a>2. call</h4><p>调用一个具有<code>给定this值</code>的函数，以及一个或多个参数。<br>语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>.<span class=\"title\">call</span>(<span class=\"params\">thisArg, arg1, arg2, ...</span>)</span></span><br></pre></td></tr></table></figure>\n\n<p>用来继承</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Product</span>(<span class=\"params\">name, price</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.price = price;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span>(<span class=\"params\">name, price</span>) </span>&#123;</span><br><span class=\"line\">  Product.call(<span class=\"keyword\">this</span>, name, price);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.category = <span class=\"string\">'food'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> Food(<span class=\"string\">'cheese'</span>, <span class=\"number\">5</span>).name);</span><br><span class=\"line\"><span class=\"comment\">// expected output: \"cheese\"</span></span><br></pre></td></tr></table></figure>\n\n<p>绑定上下文</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> reply = [<span class=\"keyword\">this</span>.animal, <span class=\"string\">'typically sleep between'</span>, <span class=\"keyword\">this</span>.sleepDuration].join(<span class=\"string\">' '</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(reply);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  animal: <span class=\"string\">'cats'</span>, <span class=\"attr\">sleepDuration</span>: <span class=\"string\">'12 and 16 hours'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">greet.call(obj);  <span class=\"comment\">// cats typically sleep between 12 and 16 hours</span></span><br></pre></td></tr></table></figure>\n\n<p>非严格模式下，不传值则默认上下文是全局对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sData = <span class=\"string\">'Wisen'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">display</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'sData value is %s '</span>, <span class=\"keyword\">this</span>.sData);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">display.call();  <span class=\"comment\">// sData value is Wisen   这里上下文是window</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-bind\"><a href=\"#3-bind\" class=\"headerlink\" title=\"3.bind\"></a>3.bind</h4><p>该方法创建一个新的函数，在 <code>bind()</code>被调用时，这个<code>新函数</code>的 <code>this 被指定为 bind() 的第一个参数</code>，而其余参数将作为新函数的参数，供调用时使用。<br>也就是说，返回一个原函数的拷贝，并拥有指定的 this 值和初始参数。<br>语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>.<span class=\"title\">bind</span>(<span class=\"params\">thisArg[, arg1[, arg2[, ...]]]</span>)</span></span><br></pre></td></tr></table></figure>\n\n<div class=\"tip\">\n1 使用`new`构造函数时，忽略`thisArg` \n---※---\n2 在`setTimeout`中回调函数使用时，`thisArg`的任何值都将转化成`object`\n---※---\n3 如果`thisArg`为`null或undefined`，`执行作用域中的this`将作为新的`thisArg`\n</div> \n\n\n<p>基础用法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">module</span> = &#123;</span><br><span class=\"line\">  x: <span class=\"number\">42</span>,</span><br><span class=\"line\">  getX: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> unboundGetX = <span class=\"built_in\">module</span>.getX;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unboundGetX());</span><br><span class=\"line\"><span class=\"comment\">// expected output: window.x =&gt; undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> boundGetX = unboundGetX.bind(<span class=\"built_in\">module</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(boundGetX());</span><br><span class=\"line\"><span class=\"comment\">// expected output: 42</span></span><br></pre></td></tr></table></figure>\n\n<p>偏函数<br>bind() 的另一个最简单的用法是使一个函数拥有预设的初始参数。<br>只要将这些参数（如果有的话）作为 bind() 的参数写在 this 后面。<br>当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">list</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addArguments</span>(<span class=\"params\">arg1, arg2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg1 + arg2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list1 = list(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result1 = addArguments(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个函数，它拥有预设参数列表。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> leadingThirtysevenList = list.bind(<span class=\"literal\">null</span>, <span class=\"number\">37</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个函数，它拥有预设的第一个参数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> addThirtySeven = addArguments.bind(<span class=\"literal\">null</span>, <span class=\"number\">37</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list2 = leadingThirtysevenList(); </span><br><span class=\"line\"><span class=\"comment\">// [37]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list3 = leadingThirtysevenList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); </span><br><span class=\"line\"><span class=\"comment\">// [37, 1, 2, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result2 = addThirtySeven(<span class=\"number\">5</span>); </span><br><span class=\"line\"><span class=\"comment\">// 37 + 5 = 42 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result3 = addThirtySeven(<span class=\"number\">5</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"comment\">// 37 + 5 = 42 ，第二个参数被忽略</span></span><br></pre></td></tr></table></figure>\n\n<p>有意思的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> unboundSlice = <span class=\"built_in\">Array</span>.prototype.slice;</span><br><span class=\"line\"><span class=\"keyword\">var</span> slice = <span class=\"built_in\">Function</span>.prototype.apply.bind(unboundSlice);</span><br><span class=\"line\"> <span class=\"comment\">// 这里的Function.prototype.apply 其实就是apply函数 </span></span><br><span class=\"line\">slice(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\"><span class=\"comment\">// 等同于 apply.bind(unboundSlice); 也就是slice === Array.prototype.slice</span></span><br></pre></td></tr></table></figure>\n\n\n<p>假如不支持<code>bind</code>的时候</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Does not work with `new (funcA.bind(thisArg, args))`</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"built_in\">Function</span>.prototype.bind) (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> slice = <span class=\"built_in\">Array</span>.prototype.slice;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span>.prototype.bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> thatFunc = <span class=\"keyword\">this</span>, thatArg = <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]; <span class=\"comment\">// 缓存调用函数，this指向，其它参数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> thatFunc !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// closest thing possible to the ECMAScript 5</span></span><br><span class=\"line\">      <span class=\"comment\">// internal IsCallable function</span></span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Function.prototype.bind - '</span> +</span><br><span class=\"line\">             <span class=\"string\">'what is trying to be bound is not callable'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> funcArgs = args.concat(slice.call(<span class=\"built_in\">arguments</span>)) <span class=\"comment\">// 其它参数合并传入参数，并成统一的函参</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> thatFunc.apply(thatArg, funcArgs);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-三者同否\"><a href=\"#4-三者同否\" class=\"headerlink\" title=\"4. 三者同否\"></a>4. 三者同否</h4><ul>\n<li>apply是传参数数组(参数不确定)，call是传参数(参数确定)</li>\n<li>apply、call、bind 三者都是为了<code>改变上下文</code>，改变函数<code>内部this</code>的指向</li>\n<li>通过apply这种方式，您将面临超过JavaScript引擎的参数长度限制的风险</li>\n<li>多次bind也只是bind第一次绑定的值</li>\n</ul>\n<p>参考链接：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\" target=\"_blank\" rel=\"noopener\">MDN 关于 apply</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\" rel=\"noopener\">MDN 关于 bind</a><br><a href=\"https://www.cnblogs.com/coco1s/p/4833199.html\" target=\"_blank\" rel=\"noopener\">ChokCocoblog</a><br><a href=\"https://muyiy.cn/blog/3/3.3.html#call-%E5%92%8C-apply\" target=\"_blank\" rel=\"noopener\">模拟实现</a></p>\n"},{"title":"数组常见技巧","date":"2020-05-26T05:40:18.000Z","_content":"\n### 1. 数组降维\n二维数组降维成一维数组（引自vue源码）\n> 利用原理：\n(1) `concat`的属性 : 如果concat方法的参数是一个元素，该元素会被直接插入到新数组中；如果参数是一个数组，该数组的各个元素将被插入到新数组中；\n(2) `apply`的优化：`Array.prototype.concat.apply`([], children) 等同于 [].concat(demoArr)\n\n\n```javascript\nlet demoArr = [1,2,3,4,5,[7,8],[22,23,43]]\nexport function simpleNormalizeChildren (children) {\n  for (let i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\nsimpleNormalizeChildren(demoArr)  \n// result =>  [1, 2, 3, 4, 5, 7, 8, 22, 23, 43]\n```\n\n#### 扩展：\n\n多维数组递归降维(借助了`递归`的能力)\n```javascript\nlet children = [1, [2,3], [4, [5, 6, [7, 8]]], [9, 10]];\nfunction simpleNormalizeChildren(children) {\n  for (let i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      children = Array.prototype.concat.apply([], children);\n      for(let j =0; j<children.length; j++) {\n        simpleNormalizeChildren(children)\n      }\n    }\n  }\n  return children;\n}\nsimpleNormalizeChildren(children); \n// result =>  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n### 2. 数组去重\n（1） ES6 `set`方法 (Set 对象允许你存储任何类型的唯一值)\n```javascript\nfunction unique (arr) {\n  return Array.from(new Set(arr))\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined,\n null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n //[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {}, {}] \n```\n<div class=\"tip\">\n  set方法无法识别重复的{}空对象\n</div> \n\n（2）双重for循环，splice去重\n```javascript\nfunction unique(arr){            \n        for(var i=0; i<arr.length; i++){\n            for(var j=i+1; j<arr.length; j++){\n                if(arr[i]==arr[j]){         //前者等于后者的时候，splice方法删除后者\n                    arr.splice(j,1);\n                    j--; \n                }\n            }\n        }\nreturn arr;\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined,\n     null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\n    console.log(unique(arr))\n    //[1, \"true\", 15, false, undefined, NaN, NaN, \"NaN\", \"a\", {…}, {…}]     \n\n```\n<div class=\"tip\">\nNaN和{}没有去重，两个null直接消失了\n</div>\n\n\n(3) indexOf（新建了一个空数组，遍历旧数组，如果空数组里没遇到重复的遍历项，则添加） \n```javascript\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var array = [];\n    for (var i = 0; i < arr.length; i++) {\n        if (array.indexOf(arr[i]) === -1) {\n            array.push(arr[i])\n        }\n    }\n    return array;\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined,\n           null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n   // [1, \"true\", true, 15, false, undefined, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, {…}]  \n```\n<div class=\"tip\">\nNaN、{}没有去重</div>\n\n(4) sort排序后再去重（sort后一样的元素的会在旁边，只需与身边的对比）高性能，推荐👍\n```javascript\n  function unique(arr) {\n    var seen; // 动态指针\n    // 浅拷贝后 排序targetArr 排序有要求的话，需要sort传入自定义的排序函数\n    var targetArr = Array.prototype.concat.call(arr).sort() \n    var result = [];\n    // 与上一位对比 因为index为0的时候没有上一位，所以直接插入结果数组返回\n    for (var i = 0; i <targetArr.length; i++) { \n       // 这里 0转为boolean是false，!0即true\n      // 这个if是，如果是第一位，或者，动态指针与遍历到的不一样，即是匹配到新元素\n      if (!i || seen !== targetArr[i]) {\n        result.push(targetArr[i])\n      }\n      // 更新指针\n      seen = targetArr[i]\n    }\n    return result\n  }\n\n  // test\n  var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined,\n           null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\n  console.log(unique(arr));\n```\n\n<div class=\"tip\">\n  sort方法需要注意看使用场景，特殊类型的时候，sort会有坑。\n</div>\n\n(5) underScore 思路版 （提供三个参数）这个思路杂糅上面的方法\n `array`： 必填参数，去重目标数组\n`isSorted`: 表示目标数组是否已经排序过了，true的话，将会采用方法（4）那样的高效对比。false的话，用indexOf\n`iteratee`: 自定义对目标数组的操作\n\n```javascript\nfunction unique(array, isSorted, iteratee) {\n    var res = [];\n    var seen = [];\n\n    for (var i = 0, len = array.length; i < len; i++) {\n        var value = array[i];\n        var computed = iteratee ? iteratee(value, i, array) : value;\n        if (isSorted) {\n            if (!i || seen !== computed) {\n                res.push(value)\n            }\n            seen = computed;\n        }\n        else if (iteratee) {\n            if (seen.indexOf(computed) === -1) {\n                seen.push(computed);\n                res.push(value);\n            }\n        }\n        else if (res.indexOf(value) === -1) {\n            res.push(value);\n        }        \n    }\n    return res;\n}\n\nconsole.log(unique(array3, false, function(item){\n    return typeof item == 'string' ? item.toLowerCase() : item\n})); // [1, \"a\", 2]\n```\n\n(6) 利用Object的key是唯一的\n```javascript\nfunction distinct(array) {\n    var obj = {};\n    return array.filter(function(item, index, array){\n        return obj.hasOwnProperty(typeof item + item) \n        ? false\n        : (obj[typeof item + item] = true)\n    })\n}\n```\n真是叹为观止，妙！妙在哪？\n+ `array.filter`本身就兼职`遍历，过滤，返回新数组`于一身，干净利落\n+ Object的`key确实是唯一`的，如果重复时候，只能是覆盖value的\n+ filter过滤条件需要的`true和false`就由 Obj是否包含这个`type+value`为key  来决定，\n如果之前没存进obj，可以任意设置一个value，就是三元运算符里的`obj[typeof item + item] = true`\n\n\n---\n\n###  API补充：\n1. `reduce`\n\n升序让数组每一项都调用传入函数，可以设置初始值。\n四个参数\n`Accumulator` (acc) (累计器)\n`Current Value` (cur) (当前值)\n`Current Index` (idx) (当前索引)\n`Source Array `(src) (源数组)\n\n```javascript\narr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])```\n```javascript\n// 统计出现次数\nvar names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];\n// allNames为Accumulator累积器，name为当前值\nvar countedNames = names.reduce(function (allNames, name) { \n  if (name in allNames) {\n    allNames[name]++;\n  }\n  else {\n    allNames[name] = 1;\n  }\n  return allNames;\n}, {});\n// countedNames is:\n// { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 }\n```\n\n\n```javascript\n  var pipe = (function(){ // proxy结合reduce实现 链式调用函数封装 需是get结尾\n        return function (value) { // value是参数 闭包缓存funcStack数组\n            var funcStack = [];\n            var oproxy = new Proxy({} , {\n                get : function (pipeObject, fnName) {\n                    console.log('fnName is:' + fnName)\n                    if (fnName === 'get') {\n                        return funcStack.reduce(function (val, fn) {\n                            return fn(val);\n                        },value);\n                    }\n                    funcStack.push(window[fnName]);\n                    console.log(funcStack)\n                    return oproxy;\n                }\n            });\n            return oproxy;\n        }\n    }());\n\n    var double = n => n * 2;\n    var pow    = n => n * n;\n    var reverseInt = n => n.toString().split(\"\").reverse().join(\"\") | 0;\n\n    console.log(pipe(3)['double'].pow.get);\n    // pipe(3).double.pow.reverseInt.get; // 63 \n```\n\n2. `slice`\n类数组 => 真数组\n```javascript\n    function list() {\n      // 也可以写成 [].slice.call(arguments) \n      return Array.prototype.slice.call(arguments); \n    }\n    \n    var list1 = list(1, 2, 3); // [1, 2, 3]\n```\n\n3. `Array.from`\n从一个类似数组或可迭代对象创建一个新的，`浅拷贝`的数组实例。\n```javascript\nArray.from(arrayLike[, mapFn[, thisArg]])\n```\n`arrayLike`：想要转换成数组的伪数组对象或可迭代对象。比如拥有一个 length 属性和若干索引属性的任意对象和Map、set等。\n`mapFn` 可选：如果指定了该参数，新数组中的每个元素会执行该回调函数。\n`thisArg` 可选：可选参数，执行回调函数 mapFn 时 this 对象。\n\n```javascript\nconst someNumbers = { '0': 10, '1': 15, length: 2 };\nArray.from(someNumbers, value => value * 2); // => [20, 30] 这里利用了mapFn的能力\n```\n```javascript\nfunction sumArguments() {\n    return Array.from(arguments).reduce((sum, num) => sum + num);\n}\nsumArguments(1, 2, 3); // => 6 //这里利用了转化伪数组成真数组的能力\n```\n\n4. `Array.concat()` 不传参数的时候，是一种浅拷贝的行为\n\n5. `Array.filter(function(){})`  如名，filter，过滤，该方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。不改变原数组\n\n```javascript\n  var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])\n```\n`callback`: 用来测试数组元素的函数 return true时 保留元素 否则不保留。\n`index`: 当前处理索引\n`array`: 调用了filter的数组本身\n\n\n```javascript\n // 创建了一个新数组，该数组的元素由原数组中值大于 10 的元素组成\nfunction isBigEnough(element) { \n  return element >= 10;\n}\nvar filtered = [12, 5, 8, 130, 44].filter(isBigEnough);\n```\n\n\n### 参考\n[MDN - slice](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n[MDN - reduce](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)\n[MDN - typeof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof)\n[MDN - Array.from](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from)\n[掘金 reduce](https://juejin.im/post/5b4d35406fb9a04fd55ac064)\n[掘金 Array.from](https://juejin.im/post/5d66b019f265da03a715e5d7)\n[拉钩博文](https://www.lagou.com/lgeduarticle/86449.html)\n[冴羽 Array去重 issue](https://github.com/mqyqingfeng/Blog/issues/27)\n[阮一峰 reduce transduce 关于 函数编程](http://www.ruanyifeng.com/blog/2017/03/reduce_transduce.html)\n","source":"_posts/array.md","raw":"---\ntitle: 数组常见技巧\ndate: 2020-05-26 13:40:18\ntags: Array \n---\n\n### 1. 数组降维\n二维数组降维成一维数组（引自vue源码）\n> 利用原理：\n(1) `concat`的属性 : 如果concat方法的参数是一个元素，该元素会被直接插入到新数组中；如果参数是一个数组，该数组的各个元素将被插入到新数组中；\n(2) `apply`的优化：`Array.prototype.concat.apply`([], children) 等同于 [].concat(demoArr)\n\n\n```javascript\nlet demoArr = [1,2,3,4,5,[7,8],[22,23,43]]\nexport function simpleNormalizeChildren (children) {\n  for (let i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\nsimpleNormalizeChildren(demoArr)  \n// result =>  [1, 2, 3, 4, 5, 7, 8, 22, 23, 43]\n```\n\n#### 扩展：\n\n多维数组递归降维(借助了`递归`的能力)\n```javascript\nlet children = [1, [2,3], [4, [5, 6, [7, 8]]], [9, 10]];\nfunction simpleNormalizeChildren(children) {\n  for (let i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      children = Array.prototype.concat.apply([], children);\n      for(let j =0; j<children.length; j++) {\n        simpleNormalizeChildren(children)\n      }\n    }\n  }\n  return children;\n}\nsimpleNormalizeChildren(children); \n// result =>  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n### 2. 数组去重\n（1） ES6 `set`方法 (Set 对象允许你存储任何类型的唯一值)\n```javascript\nfunction unique (arr) {\n  return Array.from(new Set(arr))\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined,\n null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n //[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {}, {}] \n```\n<div class=\"tip\">\n  set方法无法识别重复的{}空对象\n</div> \n\n（2）双重for循环，splice去重\n```javascript\nfunction unique(arr){            \n        for(var i=0; i<arr.length; i++){\n            for(var j=i+1; j<arr.length; j++){\n                if(arr[i]==arr[j]){         //前者等于后者的时候，splice方法删除后者\n                    arr.splice(j,1);\n                    j--; \n                }\n            }\n        }\nreturn arr;\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined,\n     null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\n    console.log(unique(arr))\n    //[1, \"true\", 15, false, undefined, NaN, NaN, \"NaN\", \"a\", {…}, {…}]     \n\n```\n<div class=\"tip\">\nNaN和{}没有去重，两个null直接消失了\n</div>\n\n\n(3) indexOf（新建了一个空数组，遍历旧数组，如果空数组里没遇到重复的遍历项，则添加） \n```javascript\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var array = [];\n    for (var i = 0; i < arr.length; i++) {\n        if (array.indexOf(arr[i]) === -1) {\n            array.push(arr[i])\n        }\n    }\n    return array;\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined,\n           null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n   // [1, \"true\", true, 15, false, undefined, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, {…}]  \n```\n<div class=\"tip\">\nNaN、{}没有去重</div>\n\n(4) sort排序后再去重（sort后一样的元素的会在旁边，只需与身边的对比）高性能，推荐👍\n```javascript\n  function unique(arr) {\n    var seen; // 动态指针\n    // 浅拷贝后 排序targetArr 排序有要求的话，需要sort传入自定义的排序函数\n    var targetArr = Array.prototype.concat.call(arr).sort() \n    var result = [];\n    // 与上一位对比 因为index为0的时候没有上一位，所以直接插入结果数组返回\n    for (var i = 0; i <targetArr.length; i++) { \n       // 这里 0转为boolean是false，!0即true\n      // 这个if是，如果是第一位，或者，动态指针与遍历到的不一样，即是匹配到新元素\n      if (!i || seen !== targetArr[i]) {\n        result.push(targetArr[i])\n      }\n      // 更新指针\n      seen = targetArr[i]\n    }\n    return result\n  }\n\n  // test\n  var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined,\n           null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\n  console.log(unique(arr));\n```\n\n<div class=\"tip\">\n  sort方法需要注意看使用场景，特殊类型的时候，sort会有坑。\n</div>\n\n(5) underScore 思路版 （提供三个参数）这个思路杂糅上面的方法\n `array`： 必填参数，去重目标数组\n`isSorted`: 表示目标数组是否已经排序过了，true的话，将会采用方法（4）那样的高效对比。false的话，用indexOf\n`iteratee`: 自定义对目标数组的操作\n\n```javascript\nfunction unique(array, isSorted, iteratee) {\n    var res = [];\n    var seen = [];\n\n    for (var i = 0, len = array.length; i < len; i++) {\n        var value = array[i];\n        var computed = iteratee ? iteratee(value, i, array) : value;\n        if (isSorted) {\n            if (!i || seen !== computed) {\n                res.push(value)\n            }\n            seen = computed;\n        }\n        else if (iteratee) {\n            if (seen.indexOf(computed) === -1) {\n                seen.push(computed);\n                res.push(value);\n            }\n        }\n        else if (res.indexOf(value) === -1) {\n            res.push(value);\n        }        \n    }\n    return res;\n}\n\nconsole.log(unique(array3, false, function(item){\n    return typeof item == 'string' ? item.toLowerCase() : item\n})); // [1, \"a\", 2]\n```\n\n(6) 利用Object的key是唯一的\n```javascript\nfunction distinct(array) {\n    var obj = {};\n    return array.filter(function(item, index, array){\n        return obj.hasOwnProperty(typeof item + item) \n        ? false\n        : (obj[typeof item + item] = true)\n    })\n}\n```\n真是叹为观止，妙！妙在哪？\n+ `array.filter`本身就兼职`遍历，过滤，返回新数组`于一身，干净利落\n+ Object的`key确实是唯一`的，如果重复时候，只能是覆盖value的\n+ filter过滤条件需要的`true和false`就由 Obj是否包含这个`type+value`为key  来决定，\n如果之前没存进obj，可以任意设置一个value，就是三元运算符里的`obj[typeof item + item] = true`\n\n\n---\n\n###  API补充：\n1. `reduce`\n\n升序让数组每一项都调用传入函数，可以设置初始值。\n四个参数\n`Accumulator` (acc) (累计器)\n`Current Value` (cur) (当前值)\n`Current Index` (idx) (当前索引)\n`Source Array `(src) (源数组)\n\n```javascript\narr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])```\n```javascript\n// 统计出现次数\nvar names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];\n// allNames为Accumulator累积器，name为当前值\nvar countedNames = names.reduce(function (allNames, name) { \n  if (name in allNames) {\n    allNames[name]++;\n  }\n  else {\n    allNames[name] = 1;\n  }\n  return allNames;\n}, {});\n// countedNames is:\n// { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 }\n```\n\n\n```javascript\n  var pipe = (function(){ // proxy结合reduce实现 链式调用函数封装 需是get结尾\n        return function (value) { // value是参数 闭包缓存funcStack数组\n            var funcStack = [];\n            var oproxy = new Proxy({} , {\n                get : function (pipeObject, fnName) {\n                    console.log('fnName is:' + fnName)\n                    if (fnName === 'get') {\n                        return funcStack.reduce(function (val, fn) {\n                            return fn(val);\n                        },value);\n                    }\n                    funcStack.push(window[fnName]);\n                    console.log(funcStack)\n                    return oproxy;\n                }\n            });\n            return oproxy;\n        }\n    }());\n\n    var double = n => n * 2;\n    var pow    = n => n * n;\n    var reverseInt = n => n.toString().split(\"\").reverse().join(\"\") | 0;\n\n    console.log(pipe(3)['double'].pow.get);\n    // pipe(3).double.pow.reverseInt.get; // 63 \n```\n\n2. `slice`\n类数组 => 真数组\n```javascript\n    function list() {\n      // 也可以写成 [].slice.call(arguments) \n      return Array.prototype.slice.call(arguments); \n    }\n    \n    var list1 = list(1, 2, 3); // [1, 2, 3]\n```\n\n3. `Array.from`\n从一个类似数组或可迭代对象创建一个新的，`浅拷贝`的数组实例。\n```javascript\nArray.from(arrayLike[, mapFn[, thisArg]])\n```\n`arrayLike`：想要转换成数组的伪数组对象或可迭代对象。比如拥有一个 length 属性和若干索引属性的任意对象和Map、set等。\n`mapFn` 可选：如果指定了该参数，新数组中的每个元素会执行该回调函数。\n`thisArg` 可选：可选参数，执行回调函数 mapFn 时 this 对象。\n\n```javascript\nconst someNumbers = { '0': 10, '1': 15, length: 2 };\nArray.from(someNumbers, value => value * 2); // => [20, 30] 这里利用了mapFn的能力\n```\n```javascript\nfunction sumArguments() {\n    return Array.from(arguments).reduce((sum, num) => sum + num);\n}\nsumArguments(1, 2, 3); // => 6 //这里利用了转化伪数组成真数组的能力\n```\n\n4. `Array.concat()` 不传参数的时候，是一种浅拷贝的行为\n\n5. `Array.filter(function(){})`  如名，filter，过滤，该方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。不改变原数组\n\n```javascript\n  var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])\n```\n`callback`: 用来测试数组元素的函数 return true时 保留元素 否则不保留。\n`index`: 当前处理索引\n`array`: 调用了filter的数组本身\n\n\n```javascript\n // 创建了一个新数组，该数组的元素由原数组中值大于 10 的元素组成\nfunction isBigEnough(element) { \n  return element >= 10;\n}\nvar filtered = [12, 5, 8, 130, 44].filter(isBigEnough);\n```\n\n\n### 参考\n[MDN - slice](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n[MDN - reduce](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)\n[MDN - typeof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof)\n[MDN - Array.from](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from)\n[掘金 reduce](https://juejin.im/post/5b4d35406fb9a04fd55ac064)\n[掘金 Array.from](https://juejin.im/post/5d66b019f265da03a715e5d7)\n[拉钩博文](https://www.lagou.com/lgeduarticle/86449.html)\n[冴羽 Array去重 issue](https://github.com/mqyqingfeng/Blog/issues/27)\n[阮一峰 reduce transduce 关于 函数编程](http://www.ruanyifeng.com/blog/2017/03/reduce_transduce.html)\n","slug":"array","published":1,"updated":"2020-07-17T09:13:39.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr9p000cz5o80xz0cav5","content":"<h3 id=\"1-数组降维\"><a href=\"#1-数组降维\" class=\"headerlink\" title=\"1. 数组降维\"></a>1. 数组降维</h3><p>二维数组降维成一维数组（引自vue源码）</p>\n<blockquote>\n<p>利用原理：<br>(1) <code>concat</code>的属性 : 如果concat方法的参数是一个元素，该元素会被直接插入到新数组中；如果参数是一个数组，该数组的各个元素将被插入到新数组中；<br>(2) <code>apply</code>的优化：<code>Array.prototype.concat.apply</code>([], children) 等同于 [].concat(demoArr)</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> demoArr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,[<span class=\"number\">7</span>,<span class=\"number\">8</span>],[<span class=\"number\">22</span>,<span class=\"number\">23</span>,<span class=\"number\">43</span>]]</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">simpleNormalizeChildren</span> (<span class=\"params\">children</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; children.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(children[i])) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.concat.apply([], children)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> children</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">simpleNormalizeChildren(demoArr)  </span><br><span class=\"line\"><span class=\"comment\">// result =&gt;  [1, 2, 3, 4, 5, 7, 8, 22, 23, 43]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"扩展：\"><a href=\"#扩展：\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h4><p>多维数组递归降维(借助了<code>递归</code>的能力)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> children = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>,<span class=\"number\">3</span>], [<span class=\"number\">4</span>, [<span class=\"number\">5</span>, <span class=\"number\">6</span>, [<span class=\"number\">7</span>, <span class=\"number\">8</span>]]], [<span class=\"number\">9</span>, <span class=\"number\">10</span>]];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">simpleNormalizeChildren</span>(<span class=\"params\">children</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; children.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(children[i])) &#123;</span><br><span class=\"line\">      children = <span class=\"built_in\">Array</span>.prototype.concat.apply([], children);</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j =<span class=\"number\">0</span>; j&lt;children.length; j++) &#123;</span><br><span class=\"line\">        simpleNormalizeChildren(children)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> children;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">simpleNormalizeChildren(children); </span><br><span class=\"line\"><span class=\"comment\">// result =&gt;  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-数组去重\"><a href=\"#2-数组去重\" class=\"headerlink\" title=\"2. 数组去重\"></a>2. 数组去重</h3><p>（1） ES6 <code>set</code>方法 (Set 对象允许你存储任何类型的唯一值)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span> (<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"string\">'true'</span>,<span class=\"string\">'true'</span>,<span class=\"literal\">true</span>,<span class=\"literal\">true</span>,<span class=\"number\">15</span>,<span class=\"number\">15</span>,<span class=\"literal\">false</span>,<span class=\"literal\">false</span>, <span class=\"literal\">undefined</span>,<span class=\"literal\">undefined</span>,</span><br><span class=\"line\"> <span class=\"literal\">null</span>,<span class=\"literal\">null</span>, <span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>,<span class=\"string\">'NaN'</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unique(arr))</span><br><span class=\"line\"> <span class=\"comment\">//[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", &#123;&#125;, &#123;&#125;]</span></span><br></pre></td></tr></table></figure>\n<div class=\"tip\">\n  set方法无法识别重复的{}空对象\n</div> \n\n<p>（2）双重for循环，splice去重</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span>(<span class=\"params\">arr</span>)</span>&#123;            </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j=i+<span class=\"number\">1</span>; j&lt;arr.length; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(arr[i]==arr[j])&#123;         <span class=\"comment\">//前者等于后者的时候，splice方法删除后者</span></span><br><span class=\"line\">                    arr.splice(j,<span class=\"number\">1</span>);</span><br><span class=\"line\">                    j--; </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"string\">'true'</span>,<span class=\"string\">'true'</span>,<span class=\"literal\">true</span>,<span class=\"literal\">true</span>,<span class=\"number\">15</span>,<span class=\"number\">15</span>,<span class=\"literal\">false</span>,<span class=\"literal\">false</span>, <span class=\"literal\">undefined</span>,<span class=\"literal\">undefined</span>,</span><br><span class=\"line\">     <span class=\"literal\">null</span>,<span class=\"literal\">null</span>, <span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>,<span class=\"string\">'NaN'</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(unique(arr))</span><br><span class=\"line\">    <span class=\"comment\">//[1, \"true\", 15, false, undefined, NaN, NaN, \"NaN\", \"a\", &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>\n<div class=\"tip\">\nNaN和{}没有去重，两个null直接消失了\n</div>\n\n\n<p>(3) indexOf（新建了一个空数组，遍历旧数组，如果空数组里没遇到重复的遍历项，则添加） </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">Array</span>.isArray(arr)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'type error!'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> array = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array.indexOf(arr[i]) === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            array.push(arr[i])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"string\">'true'</span>,<span class=\"string\">'true'</span>,<span class=\"literal\">true</span>,<span class=\"literal\">true</span>,<span class=\"number\">15</span>,<span class=\"number\">15</span>,<span class=\"literal\">false</span>,<span class=\"literal\">false</span>, <span class=\"literal\">undefined</span>,<span class=\"literal\">undefined</span>,</span><br><span class=\"line\">           <span class=\"literal\">null</span>,<span class=\"literal\">null</span>, <span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>,<span class=\"string\">'NaN'</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unique(arr))</span><br><span class=\"line\">   <span class=\"comment\">// [1, \"true\", true, 15, false, undefined, null, NaN, NaN, \"NaN\", 0, \"a\", &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>\n<div class=\"tip\">\nNaN、{}没有去重</div>\n\n<p>(4) sort排序后再去重（sort后一样的元素的会在旁边，只需与身边的对比）高性能，推荐👍</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> seen; <span class=\"comment\">// 动态指针</span></span><br><span class=\"line\">  <span class=\"comment\">// 浅拷贝后 排序targetArr 排序有要求的话，需要sort传入自定义的排序函数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> targetArr = <span class=\"built_in\">Array</span>.prototype.concat.call(arr).sort() </span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\">  <span class=\"comment\">// 与上一位对比 因为index为0的时候没有上一位，所以直接插入结果数组返回</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt;targetArr.length; i++) &#123; </span><br><span class=\"line\">     <span class=\"comment\">// 这里 0转为boolean是false，!0即true</span></span><br><span class=\"line\">    <span class=\"comment\">// 这个if是，如果是第一位，或者，动态指针与遍历到的不一样，即是匹配到新元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!i || seen !== targetArr[i]) &#123;</span><br><span class=\"line\">      result.push(targetArr[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 更新指针</span></span><br><span class=\"line\">    seen = targetArr[i]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// test</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"string\">'true'</span>,<span class=\"string\">'true'</span>,<span class=\"literal\">true</span>,<span class=\"literal\">true</span>,<span class=\"number\">15</span>,<span class=\"number\">15</span>,<span class=\"literal\">false</span>,<span class=\"literal\">false</span>, <span class=\"literal\">undefined</span>,<span class=\"literal\">undefined</span>,</span><br><span class=\"line\">         <span class=\"literal\">null</span>,<span class=\"literal\">null</span>, <span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>,<span class=\"string\">'NaN'</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure>\n\n<div class=\"tip\">\n  sort方法需要注意看使用场景，特殊类型的时候，sort会有坑。\n</div>\n\n<p>(5) underScore 思路版 （提供三个参数）这个思路杂糅上面的方法<br> <code>array</code>： 必填参数，去重目标数组<br><code>isSorted</code>: 表示目标数组是否已经排序过了，true的话，将会采用方法（4）那样的高效对比。false的话，用indexOf<br><code>iteratee</code>: 自定义对目标数组的操作</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span>(<span class=\"params\">array, isSorted, iteratee</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> seen = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = array.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> value = array[i];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> computed = iteratee ? iteratee(value, i, array) : value;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isSorted) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!i || seen !== computed) &#123;</span><br><span class=\"line\">                res.push(value)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            seen = computed;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (iteratee) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (seen.indexOf(computed) === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                seen.push(computed);</span><br><span class=\"line\">                res.push(value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (res.indexOf(value) === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            res.push(value);</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unique(array3, <span class=\"literal\">false</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> item == <span class=\"string\">'string'</span> ? item.toLowerCase() : item</span><br><span class=\"line\">&#125;)); <span class=\"comment\">// [1, \"a\", 2]</span></span><br></pre></td></tr></table></figure>\n\n<p>(6) 利用Object的key是唯一的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">distinct</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item, index, array</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj.hasOwnProperty(<span class=\"keyword\">typeof</span> item + item) </span><br><span class=\"line\">        ? <span class=\"literal\">false</span></span><br><span class=\"line\">        : (obj[<span class=\"keyword\">typeof</span> item + item] = <span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>真是叹为观止，妙！妙在哪？</p>\n<ul>\n<li><code>array.filter</code>本身就兼职<code>遍历，过滤，返回新数组</code>于一身，干净利落</li>\n<li>Object的<code>key确实是唯一</code>的，如果重复时候，只能是覆盖value的</li>\n<li>filter过滤条件需要的<code>true和false</code>就由 Obj是否包含这个<code>type+value</code>为key  来决定，<br>如果之前没存进obj，可以任意设置一个value，就是三元运算符里的<code>obj[typeof item + item] = true</code></li>\n</ul>\n<hr>\n<h3 id=\"API补充：\"><a href=\"#API补充：\" class=\"headerlink\" title=\"API补充：\"></a>API补充：</h3><ol>\n<li><code>reduce</code></li>\n</ol>\n<p>升序让数组每一项都调用传入函数，可以设置初始值。<br>四个参数<br><code>Accumulator</code> (acc) (累计器)<br><code>Current Value</code> (cur) (当前值)<br><code>Current Index</code> (idx) (当前索引)<br><code>Source Array</code>(src) (源数组)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 统计出现次数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> names = [<span class=\"string\">'Alice'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Tiff'</span>, <span class=\"string\">'Bruce'</span>, <span class=\"string\">'Alice'</span>];</span><br><span class=\"line\"><span class=\"comment\">// allNames为Accumulator累积器，name为当前值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> countedNames = names.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">allNames, name</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (name <span class=\"keyword\">in</span> allNames) &#123;</span><br><span class=\"line\">    allNames[name]++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    allNames[name] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> allNames;</span><br><span class=\"line\">&#125;, &#123;&#125;);</span><br><span class=\"line\"><span class=\"comment\">// countedNames is:</span></span><br><span class=\"line\"><span class=\"comment\">// &#123; 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 &#125;</span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pipe = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// proxy结合reduce实现 链式调用函数封装 需是get结尾</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123; <span class=\"comment\">// value是参数 闭包缓存funcStack数组</span></span><br><span class=\"line\">          <span class=\"keyword\">var</span> funcStack = [];</span><br><span class=\"line\">          <span class=\"keyword\">var</span> oproxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125; , &#123;</span><br><span class=\"line\">              <span class=\"keyword\">get</span> : function (pipeObject, fnName) &#123;</span><br><span class=\"line\">                  <span class=\"built_in\">console</span>.log(<span class=\"string\">'fnName is:'</span> + fnName)</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (fnName === <span class=\"string\">'get'</span>) &#123;</span><br><span class=\"line\">                      <span class=\"keyword\">return</span> funcStack.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val, fn</span>) </span>&#123;</span><br><span class=\"line\">                          <span class=\"keyword\">return</span> fn(val);</span><br><span class=\"line\">                      &#125;,value);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  funcStack.push(<span class=\"built_in\">window</span>[fnName]);</span><br><span class=\"line\">                  <span class=\"built_in\">console</span>.log(funcStack)</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> oproxy;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> oproxy;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> double = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> pow    = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * n;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> reverseInt = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n.toString().split(<span class=\"string\">\"\"</span>).reverse().join(<span class=\"string\">\"\"</span>) | <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(pipe(<span class=\"number\">3</span>)[<span class=\"string\">'double'</span>].pow.get);</span><br><span class=\"line\">  <span class=\"comment\">// pipe(3).double.pow.reverseInt.get; // 63</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p><code>slice</code><br>类数组 =&gt; 真数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">list</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 也可以写成 [].slice.call(arguments) </span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list1 = list(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Array.from</code><br>从一个类似数组或可迭代对象创建一个新的，<code>浅拷贝</code>的数组实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.from(arrayLike[, mapFn[, thisArg]])</span><br></pre></td></tr></table></figure>\n<p><code>arrayLike</code>：想要转换成数组的伪数组对象或可迭代对象。比如拥有一个 length 属性和若干索引属性的任意对象和Map、set等。<br><code>mapFn</code> 可选：如果指定了该参数，新数组中的每个元素会执行该回调函数。<br><code>thisArg</code> 可选：可选参数，执行回调函数 mapFn 时 this 对象。</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> someNumbers = &#123; <span class=\"string\">'0'</span>: <span class=\"number\">10</span>, <span class=\"string\">'1'</span>: <span class=\"number\">15</span>, <span class=\"attr\">length</span>: <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(someNumbers, value =&gt; value * <span class=\"number\">2</span>); <span class=\"comment\">// =&gt; [20, 30] 这里利用了mapFn的能力</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumArguments</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>).reduce(<span class=\"function\">(<span class=\"params\">sum, num</span>) =&gt;</span> sum + num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sumArguments(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// =&gt; 6 //这里利用了转化伪数组成真数组的能力</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><p><code>Array.concat()</code> 不传参数的时候，是一种浅拷贝的行为</p>\n</li>\n<li><p><code>Array.filter(function(){})</code>  如名，filter，过滤，该方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。不改变原数组</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</span><br></pre></td></tr></table></figure>\n<p><code>callback</code>: 用来测试数组元素的函数 return true时 保留元素 否则不保留。<br><code>index</code>: 当前处理索引<br><code>array</code>: 调用了filter的数组本身</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 创建了一个新数组，该数组的元素由原数组中值大于 10 的元素组成</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isBigEnough</span>(<span class=\"params\">element</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> element &gt;= <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> filtered = [<span class=\"number\">12</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">130</span>, <span class=\"number\">44</span>].filter(isBigEnough);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\" target=\"_blank\" rel=\"noopener\">MDN - slice</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\" target=\"_blank\" rel=\"noopener\">MDN - reduce</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof\" target=\"_blank\" rel=\"noopener\">MDN - typeof</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from\" target=\"_blank\" rel=\"noopener\">MDN - Array.from</a><br><a href=\"https://juejin.im/post/5b4d35406fb9a04fd55ac064\" target=\"_blank\" rel=\"noopener\">掘金 reduce</a><br><a href=\"https://juejin.im/post/5d66b019f265da03a715e5d7\" target=\"_blank\" rel=\"noopener\">掘金 Array.from</a><br><a href=\"https://www.lagou.com/lgeduarticle/86449.html\" target=\"_blank\" rel=\"noopener\">拉钩博文</a><br><a href=\"https://github.com/mqyqingfeng/Blog/issues/27\" target=\"_blank\" rel=\"noopener\">冴羽 Array去重 issue</a><br><a href=\"http://www.ruanyifeng.com/blog/2017/03/reduce_transduce.html\" target=\"_blank\" rel=\"noopener\">阮一峰 reduce transduce 关于 函数编程</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-数组降维\"><a href=\"#1-数组降维\" class=\"headerlink\" title=\"1. 数组降维\"></a>1. 数组降维</h3><p>二维数组降维成一维数组（引自vue源码）</p>\n<blockquote>\n<p>利用原理：<br>(1) <code>concat</code>的属性 : 如果concat方法的参数是一个元素，该元素会被直接插入到新数组中；如果参数是一个数组，该数组的各个元素将被插入到新数组中；<br>(2) <code>apply</code>的优化：<code>Array.prototype.concat.apply</code>([], children) 等同于 [].concat(demoArr)</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> demoArr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,[<span class=\"number\">7</span>,<span class=\"number\">8</span>],[<span class=\"number\">22</span>,<span class=\"number\">23</span>,<span class=\"number\">43</span>]]</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">simpleNormalizeChildren</span> (<span class=\"params\">children</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; children.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(children[i])) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.concat.apply([], children)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> children</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">simpleNormalizeChildren(demoArr)  </span><br><span class=\"line\"><span class=\"comment\">// result =&gt;  [1, 2, 3, 4, 5, 7, 8, 22, 23, 43]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"扩展：\"><a href=\"#扩展：\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h4><p>多维数组递归降维(借助了<code>递归</code>的能力)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> children = [<span class=\"number\">1</span>, [<span class=\"number\">2</span>,<span class=\"number\">3</span>], [<span class=\"number\">4</span>, [<span class=\"number\">5</span>, <span class=\"number\">6</span>, [<span class=\"number\">7</span>, <span class=\"number\">8</span>]]], [<span class=\"number\">9</span>, <span class=\"number\">10</span>]];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">simpleNormalizeChildren</span>(<span class=\"params\">children</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; children.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(children[i])) &#123;</span><br><span class=\"line\">      children = <span class=\"built_in\">Array</span>.prototype.concat.apply([], children);</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j =<span class=\"number\">0</span>; j&lt;children.length; j++) &#123;</span><br><span class=\"line\">        simpleNormalizeChildren(children)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> children;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">simpleNormalizeChildren(children); </span><br><span class=\"line\"><span class=\"comment\">// result =&gt;  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-数组去重\"><a href=\"#2-数组去重\" class=\"headerlink\" title=\"2. 数组去重\"></a>2. 数组去重</h3><p>（1） ES6 <code>set</code>方法 (Set 对象允许你存储任何类型的唯一值)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span> (<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"string\">'true'</span>,<span class=\"string\">'true'</span>,<span class=\"literal\">true</span>,<span class=\"literal\">true</span>,<span class=\"number\">15</span>,<span class=\"number\">15</span>,<span class=\"literal\">false</span>,<span class=\"literal\">false</span>, <span class=\"literal\">undefined</span>,<span class=\"literal\">undefined</span>,</span><br><span class=\"line\"> <span class=\"literal\">null</span>,<span class=\"literal\">null</span>, <span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>,<span class=\"string\">'NaN'</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unique(arr))</span><br><span class=\"line\"> <span class=\"comment\">//[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", &#123;&#125;, &#123;&#125;]</span></span><br></pre></td></tr></table></figure>\n<div class=\"tip\">\n  set方法无法识别重复的{}空对象\n</div> \n\n<p>（2）双重for循环，splice去重</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span>(<span class=\"params\">arr</span>)</span>&#123;            </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j=i+<span class=\"number\">1</span>; j&lt;arr.length; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(arr[i]==arr[j])&#123;         <span class=\"comment\">//前者等于后者的时候，splice方法删除后者</span></span><br><span class=\"line\">                    arr.splice(j,<span class=\"number\">1</span>);</span><br><span class=\"line\">                    j--; </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"string\">'true'</span>,<span class=\"string\">'true'</span>,<span class=\"literal\">true</span>,<span class=\"literal\">true</span>,<span class=\"number\">15</span>,<span class=\"number\">15</span>,<span class=\"literal\">false</span>,<span class=\"literal\">false</span>, <span class=\"literal\">undefined</span>,<span class=\"literal\">undefined</span>,</span><br><span class=\"line\">     <span class=\"literal\">null</span>,<span class=\"literal\">null</span>, <span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>,<span class=\"string\">'NaN'</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(unique(arr))</span><br><span class=\"line\">    <span class=\"comment\">//[1, \"true\", 15, false, undefined, NaN, NaN, \"NaN\", \"a\", &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>\n<div class=\"tip\">\nNaN和{}没有去重，两个null直接消失了\n</div>\n\n\n<p>(3) indexOf（新建了一个空数组，遍历旧数组，如果空数组里没遇到重复的遍历项，则添加） </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">Array</span>.isArray(arr)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'type error!'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> array = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array.indexOf(arr[i]) === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            array.push(arr[i])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"string\">'true'</span>,<span class=\"string\">'true'</span>,<span class=\"literal\">true</span>,<span class=\"literal\">true</span>,<span class=\"number\">15</span>,<span class=\"number\">15</span>,<span class=\"literal\">false</span>,<span class=\"literal\">false</span>, <span class=\"literal\">undefined</span>,<span class=\"literal\">undefined</span>,</span><br><span class=\"line\">           <span class=\"literal\">null</span>,<span class=\"literal\">null</span>, <span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>,<span class=\"string\">'NaN'</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unique(arr))</span><br><span class=\"line\">   <span class=\"comment\">// [1, \"true\", true, 15, false, undefined, null, NaN, NaN, \"NaN\", 0, \"a\", &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>\n<div class=\"tip\">\nNaN、{}没有去重</div>\n\n<p>(4) sort排序后再去重（sort后一样的元素的会在旁边，只需与身边的对比）高性能，推荐👍</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> seen; <span class=\"comment\">// 动态指针</span></span><br><span class=\"line\">  <span class=\"comment\">// 浅拷贝后 排序targetArr 排序有要求的话，需要sort传入自定义的排序函数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> targetArr = <span class=\"built_in\">Array</span>.prototype.concat.call(arr).sort() </span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = [];</span><br><span class=\"line\">  <span class=\"comment\">// 与上一位对比 因为index为0的时候没有上一位，所以直接插入结果数组返回</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt;targetArr.length; i++) &#123; </span><br><span class=\"line\">     <span class=\"comment\">// 这里 0转为boolean是false，!0即true</span></span><br><span class=\"line\">    <span class=\"comment\">// 这个if是，如果是第一位，或者，动态指针与遍历到的不一样，即是匹配到新元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!i || seen !== targetArr[i]) &#123;</span><br><span class=\"line\">      result.push(targetArr[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 更新指针</span></span><br><span class=\"line\">    seen = targetArr[i]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// test</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"string\">'true'</span>,<span class=\"string\">'true'</span>,<span class=\"literal\">true</span>,<span class=\"literal\">true</span>,<span class=\"number\">15</span>,<span class=\"number\">15</span>,<span class=\"literal\">false</span>,<span class=\"literal\">false</span>, <span class=\"literal\">undefined</span>,<span class=\"literal\">undefined</span>,</span><br><span class=\"line\">         <span class=\"literal\">null</span>,<span class=\"literal\">null</span>, <span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>,<span class=\"string\">'NaN'</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure>\n\n<div class=\"tip\">\n  sort方法需要注意看使用场景，特殊类型的时候，sort会有坑。\n</div>\n\n<p>(5) underScore 思路版 （提供三个参数）这个思路杂糅上面的方法<br> <code>array</code>： 必填参数，去重目标数组<br><code>isSorted</code>: 表示目标数组是否已经排序过了，true的话，将会采用方法（4）那样的高效对比。false的话，用indexOf<br><code>iteratee</code>: 自定义对目标数组的操作</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span>(<span class=\"params\">array, isSorted, iteratee</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> seen = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = array.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> value = array[i];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> computed = iteratee ? iteratee(value, i, array) : value;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isSorted) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!i || seen !== computed) &#123;</span><br><span class=\"line\">                res.push(value)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            seen = computed;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (iteratee) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (seen.indexOf(computed) === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                seen.push(computed);</span><br><span class=\"line\">                res.push(value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (res.indexOf(value) === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            res.push(value);</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unique(array3, <span class=\"literal\">false</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> item == <span class=\"string\">'string'</span> ? item.toLowerCase() : item</span><br><span class=\"line\">&#125;)); <span class=\"comment\">// [1, \"a\", 2]</span></span><br></pre></td></tr></table></figure>\n\n<p>(6) 利用Object的key是唯一的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">distinct</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item, index, array</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj.hasOwnProperty(<span class=\"keyword\">typeof</span> item + item) </span><br><span class=\"line\">        ? <span class=\"literal\">false</span></span><br><span class=\"line\">        : (obj[<span class=\"keyword\">typeof</span> item + item] = <span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>真是叹为观止，妙！妙在哪？</p>\n<ul>\n<li><code>array.filter</code>本身就兼职<code>遍历，过滤，返回新数组</code>于一身，干净利落</li>\n<li>Object的<code>key确实是唯一</code>的，如果重复时候，只能是覆盖value的</li>\n<li>filter过滤条件需要的<code>true和false</code>就由 Obj是否包含这个<code>type+value</code>为key  来决定，<br>如果之前没存进obj，可以任意设置一个value，就是三元运算符里的<code>obj[typeof item + item] = true</code></li>\n</ul>\n<hr>\n<h3 id=\"API补充：\"><a href=\"#API补充：\" class=\"headerlink\" title=\"API补充：\"></a>API补充：</h3><ol>\n<li><code>reduce</code></li>\n</ol>\n<p>升序让数组每一项都调用传入函数，可以设置初始值。<br>四个参数<br><code>Accumulator</code> (acc) (累计器)<br><code>Current Value</code> (cur) (当前值)<br><code>Current Index</code> (idx) (当前索引)<br><code>Source Array</code>(src) (源数组)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 统计出现次数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> names = [<span class=\"string\">'Alice'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Tiff'</span>, <span class=\"string\">'Bruce'</span>, <span class=\"string\">'Alice'</span>];</span><br><span class=\"line\"><span class=\"comment\">// allNames为Accumulator累积器，name为当前值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> countedNames = names.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">allNames, name</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (name <span class=\"keyword\">in</span> allNames) &#123;</span><br><span class=\"line\">    allNames[name]++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    allNames[name] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> allNames;</span><br><span class=\"line\">&#125;, &#123;&#125;);</span><br><span class=\"line\"><span class=\"comment\">// countedNames is:</span></span><br><span class=\"line\"><span class=\"comment\">// &#123; 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 &#125;</span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pipe = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// proxy结合reduce实现 链式调用函数封装 需是get结尾</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123; <span class=\"comment\">// value是参数 闭包缓存funcStack数组</span></span><br><span class=\"line\">          <span class=\"keyword\">var</span> funcStack = [];</span><br><span class=\"line\">          <span class=\"keyword\">var</span> oproxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125; , &#123;</span><br><span class=\"line\">              <span class=\"keyword\">get</span> : function (pipeObject, fnName) &#123;</span><br><span class=\"line\">                  <span class=\"built_in\">console</span>.log(<span class=\"string\">'fnName is:'</span> + fnName)</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (fnName === <span class=\"string\">'get'</span>) &#123;</span><br><span class=\"line\">                      <span class=\"keyword\">return</span> funcStack.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val, fn</span>) </span>&#123;</span><br><span class=\"line\">                          <span class=\"keyword\">return</span> fn(val);</span><br><span class=\"line\">                      &#125;,value);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  funcStack.push(<span class=\"built_in\">window</span>[fnName]);</span><br><span class=\"line\">                  <span class=\"built_in\">console</span>.log(funcStack)</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> oproxy;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> oproxy;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> double = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> pow    = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n * n;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> reverseInt = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n.toString().split(<span class=\"string\">\"\"</span>).reverse().join(<span class=\"string\">\"\"</span>) | <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(pipe(<span class=\"number\">3</span>)[<span class=\"string\">'double'</span>].pow.get);</span><br><span class=\"line\">  <span class=\"comment\">// pipe(3).double.pow.reverseInt.get; // 63</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p><code>slice</code><br>类数组 =&gt; 真数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">list</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 也可以写成 [].slice.call(arguments) </span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> list1 = list(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Array.from</code><br>从一个类似数组或可迭代对象创建一个新的，<code>浅拷贝</code>的数组实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.from(arrayLike[, mapFn[, thisArg]])</span><br></pre></td></tr></table></figure>\n<p><code>arrayLike</code>：想要转换成数组的伪数组对象或可迭代对象。比如拥有一个 length 属性和若干索引属性的任意对象和Map、set等。<br><code>mapFn</code> 可选：如果指定了该参数，新数组中的每个元素会执行该回调函数。<br><code>thisArg</code> 可选：可选参数，执行回调函数 mapFn 时 this 对象。</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> someNumbers = &#123; <span class=\"string\">'0'</span>: <span class=\"number\">10</span>, <span class=\"string\">'1'</span>: <span class=\"number\">15</span>, <span class=\"attr\">length</span>: <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(someNumbers, value =&gt; value * <span class=\"number\">2</span>); <span class=\"comment\">// =&gt; [20, 30] 这里利用了mapFn的能力</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumArguments</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>).reduce(<span class=\"function\">(<span class=\"params\">sum, num</span>) =&gt;</span> sum + num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sumArguments(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// =&gt; 6 //这里利用了转化伪数组成真数组的能力</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><p><code>Array.concat()</code> 不传参数的时候，是一种浅拷贝的行为</p>\n</li>\n<li><p><code>Array.filter(function(){})</code>  如名，filter，过滤，该方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。不改变原数组</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</span><br></pre></td></tr></table></figure>\n<p><code>callback</code>: 用来测试数组元素的函数 return true时 保留元素 否则不保留。<br><code>index</code>: 当前处理索引<br><code>array</code>: 调用了filter的数组本身</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 创建了一个新数组，该数组的元素由原数组中值大于 10 的元素组成</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isBigEnough</span>(<span class=\"params\">element</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> element &gt;= <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> filtered = [<span class=\"number\">12</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">130</span>, <span class=\"number\">44</span>].filter(isBigEnough);</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\" target=\"_blank\" rel=\"noopener\">MDN - slice</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\" target=\"_blank\" rel=\"noopener\">MDN - reduce</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof\" target=\"_blank\" rel=\"noopener\">MDN - typeof</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from\" target=\"_blank\" rel=\"noopener\">MDN - Array.from</a><br><a href=\"https://juejin.im/post/5b4d35406fb9a04fd55ac064\" target=\"_blank\" rel=\"noopener\">掘金 reduce</a><br><a href=\"https://juejin.im/post/5d66b019f265da03a715e5d7\" target=\"_blank\" rel=\"noopener\">掘金 Array.from</a><br><a href=\"https://www.lagou.com/lgeduarticle/86449.html\" target=\"_blank\" rel=\"noopener\">拉钩博文</a><br><a href=\"https://github.com/mqyqingfeng/Blog/issues/27\" target=\"_blank\" rel=\"noopener\">冴羽 Array去重 issue</a><br><a href=\"http://www.ruanyifeng.com/blog/2017/03/reduce_transduce.html\" target=\"_blank\" rel=\"noopener\">阮一峰 reduce transduce 关于 函数编程</a></p>\n"},{"title":"nginx","date":"2018-06-17T07:48:45.000Z","_content":"\n\n #### nginx 是什么？\n```\n    静态资源HTTP 服务器。通过http协议将静态资源路径暴露给客户端。\n    反向代理服务器。介乎客户端和服务器的中间层，可以做虚拟主机，和负载均衡\n```\n\n #### 虚拟主机 是什么？（网站访问量小的情况）\n```\n    多域名对应同一服务器，对应同一ip，却可以打开不同网站。仿佛就像两个服务器，所以称为虚拟主机，也可以称为多开。\n```\n\n #### 负载均衡 是什么? （网站访问量大的情况）\n```\n    通过反向代理的身份，把自己写的应用部署在多个服务器上。其实说白了，就是一份nginx配置，上面很多ip地址，会自动轮询ip地址，并根据weight的值来判断分配给指定ip的服务器的权重。\n```\n\n#### nginx 怎么配置？\n\n\n<a href=\"https://blog.csdn.net/lihang_1994/article/details/72598955\">具体参考链接</a>\n\n","source":"_posts/nginx科普章.md","raw":"---\ntitle: nginx\ndate: 2018-06-17 15:48:45\ntags: nginx\n---\n\n\n #### nginx 是什么？\n```\n    静态资源HTTP 服务器。通过http协议将静态资源路径暴露给客户端。\n    反向代理服务器。介乎客户端和服务器的中间层，可以做虚拟主机，和负载均衡\n```\n\n #### 虚拟主机 是什么？（网站访问量小的情况）\n```\n    多域名对应同一服务器，对应同一ip，却可以打开不同网站。仿佛就像两个服务器，所以称为虚拟主机，也可以称为多开。\n```\n\n #### 负载均衡 是什么? （网站访问量大的情况）\n```\n    通过反向代理的身份，把自己写的应用部署在多个服务器上。其实说白了，就是一份nginx配置，上面很多ip地址，会自动轮询ip地址，并根据weight的值来判断分配给指定ip的服务器的权重。\n```\n\n#### nginx 怎么配置？\n\n\n<a href=\"https://blog.csdn.net/lihang_1994/article/details/72598955\">具体参考链接</a>\n\n","slug":"nginx科普章","published":1,"updated":"2018-06-17T08:13:34.814Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr9q000ez5o8av371vwt","content":"<h4 id=\"nginx-是什么？\"><a href=\"#nginx-是什么？\" class=\"headerlink\" title=\"nginx 是什么？\"></a>nginx 是什么？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">静态资源HTTP 服务器。通过http协议将静态资源路径暴露给客户端。</span><br><span class=\"line\">反向代理服务器。介乎客户端和服务器的中间层，可以做虚拟主机，和负载均衡</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"虚拟主机-是什么？（网站访问量小的情况）\"><a href=\"#虚拟主机-是什么？（网站访问量小的情况）\" class=\"headerlink\" title=\"虚拟主机 是什么？（网站访问量小的情况）\"></a>虚拟主机 是什么？（网站访问量小的情况）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多域名对应同一服务器，对应同一ip，却可以打开不同网站。仿佛就像两个服务器，所以称为虚拟主机，也可以称为多开。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"负载均衡-是什么-（网站访问量大的情况）\"><a href=\"#负载均衡-是什么-（网站访问量大的情况）\" class=\"headerlink\" title=\"负载均衡 是什么? （网站访问量大的情况）\"></a>负载均衡 是什么? （网站访问量大的情况）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过反向代理的身份，把自己写的应用部署在多个服务器上。其实说白了，就是一份nginx配置，上面很多ip地址，会自动轮询ip地址，并根据weight的值来判断分配给指定ip的服务器的权重。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"nginx-怎么配置？\"><a href=\"#nginx-怎么配置？\" class=\"headerlink\" title=\"nginx 怎么配置？\"></a>nginx 怎么配置？</h4><p><a href=\"https://blog.csdn.net/lihang_1994/article/details/72598955\" target=\"_blank\" rel=\"noopener\">具体参考链接</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"nginx-是什么？\"><a href=\"#nginx-是什么？\" class=\"headerlink\" title=\"nginx 是什么？\"></a>nginx 是什么？</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">静态资源HTTP 服务器。通过http协议将静态资源路径暴露给客户端。</span><br><span class=\"line\">反向代理服务器。介乎客户端和服务器的中间层，可以做虚拟主机，和负载均衡</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"虚拟主机-是什么？（网站访问量小的情况）\"><a href=\"#虚拟主机-是什么？（网站访问量小的情况）\" class=\"headerlink\" title=\"虚拟主机 是什么？（网站访问量小的情况）\"></a>虚拟主机 是什么？（网站访问量小的情况）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多域名对应同一服务器，对应同一ip，却可以打开不同网站。仿佛就像两个服务器，所以称为虚拟主机，也可以称为多开。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"负载均衡-是什么-（网站访问量大的情况）\"><a href=\"#负载均衡-是什么-（网站访问量大的情况）\" class=\"headerlink\" title=\"负载均衡 是什么? （网站访问量大的情况）\"></a>负载均衡 是什么? （网站访问量大的情况）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过反向代理的身份，把自己写的应用部署在多个服务器上。其实说白了，就是一份nginx配置，上面很多ip地址，会自动轮询ip地址，并根据weight的值来判断分配给指定ip的服务器的权重。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"nginx-怎么配置？\"><a href=\"#nginx-怎么配置？\" class=\"headerlink\" title=\"nginx 怎么配置？\"></a>nginx 怎么配置？</h4><p><a href=\"https://blog.csdn.net/lihang_1994/article/details/72598955\" target=\"_blank\" rel=\"noopener\">具体参考链接</a></p>\n"},{"title":"JS模块化","date":"2020-01-04T06:29:41.000Z","_content":"\n> 模块化的简单包装\n\n```javascript\nvar module = (function() { // 利用了自执行函数的封闭性\n    var _count = 0;\n    var m1 = function() {\n        alert(_count)\n    }\n    var m2 = function() {\n        alert(_count + 1)\n    }\n \n    return {\n        m1: m1,\n        m2: m2\n    }\n})()\n```\n\n\n###  1 JS模块化发展历史\n\n- CommonJS 和 AMD CMD 鼎足之势 （前） ES6 （后）\n（知名框架 Node.js、RequireJS前置加载 和 Seajs就近加载 分别对应前三个）\n- 谈谈现阶段：\n    + ES6标准发布后，module成为标准，标准使用是以`export`指令导出接口，以`import`引入模块。\n    + 在我们一贯的node模块中，我们依然采用的是`CommonJS`规范，使用`require`引入模块，使用`module.exports`导出接口。是`同步`加载 JS 脚本。这么做在服务端毫无问题，因为文件都存在磁盘上，然而浏览器的特性决定了 JS 脚本需要异步加载，否则就会失去响应，因此 CommonJS 规范`无法直接在浏览器`中使用。\n\n### 2 对于es6模块的看法（参考阮一峰老师）\n+ `es6标准`将成为服务器和浏览器端模块化的`通用解决方法` \n+ `运行时加载`：代码运行到这个语句的时候才会加载 \n+ `编译时加载`：打包工具编译js时，就会去分析模块之间的依赖关系，所以不能放在任何条件代码块里。层级最优先\n+ es6模块中的this指向是undefined，不要轻易用this, CommonJs中的this指向当前模块\n+ export的使用，如果需导出的模块前面没有export，那在export的时候就要加上{}\n    ```javascript\n    function fn() {}\n    export {fn}\n    ```\n+ export导出语句是动态绑定的，如果导出的值发生变化，那import进的值也会随之变化\n    ```javascript\n\n    // exportJs\n    export var foo = 'bar';\n    setTimeout(function(){ () => foo = 'baz'; },500);\n\n    那么foo变量值将在500ms后变成baz字符串，这点与`commonJS`不一样，commonJs是会缓存值。\n    ```\n+ `import`命令具有提升效果，会提升到整个模块的头部并首先执行，但还是建议放在头部写比较好。\n    ```javascript\n        foo();\n        import {foo} from 'module'; // right \n    ```\n+ *号指定整体输出的一个对象\n    ```javascript\n        // circle.js\n        export funciton fn1(){\n\n        }\n\n        export function fn2(){\n\n        }\n\n        // main.js 需要引入cilcle.js\n        import * as circle from './circle';\n        \n        // 调用：\n        circle.fn1();\n        circle.fn2();\n\n    ```\n+ export 的default输出，默认输出\n    ```javascript\n        // exportJs\n        export default function(){\n            console.log('foo')\n        }\n\n        // importJs\n        import customFn from './exportJS'\n        customFn();\n    ```\n+ import函数大括号的写法时机\n export后面接着default的时候，不用大括号，没接着的时候是要大括号的。\n    ```javascript\n    // 无 default\n    export function fn1() {}\n    import { fn1} from 'exportJs';\n    \n    // 有default\n    export default function fn2() {}\n    import fn2 from 'exportJs'\n    ```\n    \n+ 因为静态分析没有运行时加载那么“动态化”，所以，import有个提案，目前可以在webpack使用，可以动态输入一个较为狭窄的路径，然后返回一个promise对象\n这个情况下的import是支持`按需加载`，`条件加载`，和`动态的模块路径`。\n ```javascript\n    const main = document.querySelector('main')\n    import('./someModule/${someVariable}.js')\n        .then(module => {\n            module.loadPageInfo(main)\n        })\n        .catch(err => {\n            mian.textContent = err.message;                                                 \n        })\n ```\n\n+ script标签的defer和async属性差异，两者都是取消了js的同步属性。\n但是defer是`渲染完再执行`，而async是`下载完就执行`。\n\n+ 待验证：es6模块在网页上的加载\n    ```javascript\n        <script type=\"module\">\n            import utils from './util.js';\n        </script>\n    ```\n\n+ es6模块，导出的变量不可以重新赋值，但可以添加或修改属性，就是内存地址不能改，里面存的内容随你改，待验证。\n    ```javascript\n    // lib.js\n    export let obj = {}\n    \n    // main.js\n    import { obj } from 'lib'\n\n    obj.prop = 123; // right\n    obj = {}        // typeError\n    ```\n+ 使用`import`命令加载`commonJS`模块，Node会自动将`module.exports`当成模块的默认输出，即等同于`export default`\n  ```javascript\n    // b.js\n    module.exports = null;\n\n    // es.js\n    import foo from './b.js'\n\n    import * as bar from './b.js'\n    // bar = {default: null}\n\n    import { somethimg } from 'fs' // error！！！\n\n    import * as express from 'express'\n    const app = express.default() // right\n  ```\n\n+ `commonJs`的加载原理\ncommonJs每个模块都是一个脚本文件，Node内部用require命令第一次加载就会执行这个脚本，然生成一个对象，这个会缓存，即是多次require，不清缓存下，都取第一次。\n    ```javascript\n        {\n            id: '',         // 模块名\n            exports: {},    // 导出模块, \n            loaded: true    // 是否加载过\n        }\n    ```\n+ 循环加载：模块之间相互引用\nCommonJs会出现，输出已执行的部分，未执行的部分不会输出\nes6模块则不会报错\n\n参考文章：\n[掘金](https://juejin.im/post/58882a42128fe100684ad9de)\n阮一峰es6 模块篇章","source":"_posts/JS模块化.md","raw":"---\ntitle: JS模块化\ndate: 2020-01-04 14:29:41\ntags: 模块化\n---\n\n> 模块化的简单包装\n\n```javascript\nvar module = (function() { // 利用了自执行函数的封闭性\n    var _count = 0;\n    var m1 = function() {\n        alert(_count)\n    }\n    var m2 = function() {\n        alert(_count + 1)\n    }\n \n    return {\n        m1: m1,\n        m2: m2\n    }\n})()\n```\n\n\n###  1 JS模块化发展历史\n\n- CommonJS 和 AMD CMD 鼎足之势 （前） ES6 （后）\n（知名框架 Node.js、RequireJS前置加载 和 Seajs就近加载 分别对应前三个）\n- 谈谈现阶段：\n    + ES6标准发布后，module成为标准，标准使用是以`export`指令导出接口，以`import`引入模块。\n    + 在我们一贯的node模块中，我们依然采用的是`CommonJS`规范，使用`require`引入模块，使用`module.exports`导出接口。是`同步`加载 JS 脚本。这么做在服务端毫无问题，因为文件都存在磁盘上，然而浏览器的特性决定了 JS 脚本需要异步加载，否则就会失去响应，因此 CommonJS 规范`无法直接在浏览器`中使用。\n\n### 2 对于es6模块的看法（参考阮一峰老师）\n+ `es6标准`将成为服务器和浏览器端模块化的`通用解决方法` \n+ `运行时加载`：代码运行到这个语句的时候才会加载 \n+ `编译时加载`：打包工具编译js时，就会去分析模块之间的依赖关系，所以不能放在任何条件代码块里。层级最优先\n+ es6模块中的this指向是undefined，不要轻易用this, CommonJs中的this指向当前模块\n+ export的使用，如果需导出的模块前面没有export，那在export的时候就要加上{}\n    ```javascript\n    function fn() {}\n    export {fn}\n    ```\n+ export导出语句是动态绑定的，如果导出的值发生变化，那import进的值也会随之变化\n    ```javascript\n\n    // exportJs\n    export var foo = 'bar';\n    setTimeout(function(){ () => foo = 'baz'; },500);\n\n    那么foo变量值将在500ms后变成baz字符串，这点与`commonJS`不一样，commonJs是会缓存值。\n    ```\n+ `import`命令具有提升效果，会提升到整个模块的头部并首先执行，但还是建议放在头部写比较好。\n    ```javascript\n        foo();\n        import {foo} from 'module'; // right \n    ```\n+ *号指定整体输出的一个对象\n    ```javascript\n        // circle.js\n        export funciton fn1(){\n\n        }\n\n        export function fn2(){\n\n        }\n\n        // main.js 需要引入cilcle.js\n        import * as circle from './circle';\n        \n        // 调用：\n        circle.fn1();\n        circle.fn2();\n\n    ```\n+ export 的default输出，默认输出\n    ```javascript\n        // exportJs\n        export default function(){\n            console.log('foo')\n        }\n\n        // importJs\n        import customFn from './exportJS'\n        customFn();\n    ```\n+ import函数大括号的写法时机\n export后面接着default的时候，不用大括号，没接着的时候是要大括号的。\n    ```javascript\n    // 无 default\n    export function fn1() {}\n    import { fn1} from 'exportJs';\n    \n    // 有default\n    export default function fn2() {}\n    import fn2 from 'exportJs'\n    ```\n    \n+ 因为静态分析没有运行时加载那么“动态化”，所以，import有个提案，目前可以在webpack使用，可以动态输入一个较为狭窄的路径，然后返回一个promise对象\n这个情况下的import是支持`按需加载`，`条件加载`，和`动态的模块路径`。\n ```javascript\n    const main = document.querySelector('main')\n    import('./someModule/${someVariable}.js')\n        .then(module => {\n            module.loadPageInfo(main)\n        })\n        .catch(err => {\n            mian.textContent = err.message;                                                 \n        })\n ```\n\n+ script标签的defer和async属性差异，两者都是取消了js的同步属性。\n但是defer是`渲染完再执行`，而async是`下载完就执行`。\n\n+ 待验证：es6模块在网页上的加载\n    ```javascript\n        <script type=\"module\">\n            import utils from './util.js';\n        </script>\n    ```\n\n+ es6模块，导出的变量不可以重新赋值，但可以添加或修改属性，就是内存地址不能改，里面存的内容随你改，待验证。\n    ```javascript\n    // lib.js\n    export let obj = {}\n    \n    // main.js\n    import { obj } from 'lib'\n\n    obj.prop = 123; // right\n    obj = {}        // typeError\n    ```\n+ 使用`import`命令加载`commonJS`模块，Node会自动将`module.exports`当成模块的默认输出，即等同于`export default`\n  ```javascript\n    // b.js\n    module.exports = null;\n\n    // es.js\n    import foo from './b.js'\n\n    import * as bar from './b.js'\n    // bar = {default: null}\n\n    import { somethimg } from 'fs' // error！！！\n\n    import * as express from 'express'\n    const app = express.default() // right\n  ```\n\n+ `commonJs`的加载原理\ncommonJs每个模块都是一个脚本文件，Node内部用require命令第一次加载就会执行这个脚本，然生成一个对象，这个会缓存，即是多次require，不清缓存下，都取第一次。\n    ```javascript\n        {\n            id: '',         // 模块名\n            exports: {},    // 导出模块, \n            loaded: true    // 是否加载过\n        }\n    ```\n+ 循环加载：模块之间相互引用\nCommonJs会出现，输出已执行的部分，未执行的部分不会输出\nes6模块则不会报错\n\n参考文章：\n[掘金](https://juejin.im/post/58882a42128fe100684ad9de)\n阮一峰es6 模块篇章","slug":"JS模块化","published":1,"updated":"2020-07-23T10:52:28.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr9r000gz5o8cqenfck9","content":"<blockquote>\n<p>模块化的简单包装</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 利用了自执行函数的封闭性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> _count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> m1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(_count)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> m2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(_count + <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        m1: m1,</span><br><span class=\"line\">        m2: m2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"1-JS模块化发展历史\"><a href=\"#1-JS模块化发展历史\" class=\"headerlink\" title=\"1 JS模块化发展历史\"></a>1 JS模块化发展历史</h3><ul>\n<li>CommonJS 和 AMD CMD 鼎足之势 （前） ES6 （后）<br>（知名框架 Node.js、RequireJS前置加载 和 Seajs就近加载 分别对应前三个）</li>\n<li>谈谈现阶段：<ul>\n<li>ES6标准发布后，module成为标准，标准使用是以<code>export</code>指令导出接口，以<code>import</code>引入模块。</li>\n<li>在我们一贯的node模块中，我们依然采用的是<code>CommonJS</code>规范，使用<code>require</code>引入模块，使用<code>module.exports</code>导出接口。是<code>同步</code>加载 JS 脚本。这么做在服务端毫无问题，因为文件都存在磁盘上，然而浏览器的特性决定了 JS 脚本需要异步加载，否则就会失去响应，因此 CommonJS 规范<code>无法直接在浏览器</code>中使用。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-对于es6模块的看法（参考阮一峰老师）\"><a href=\"#2-对于es6模块的看法（参考阮一峰老师）\" class=\"headerlink\" title=\"2 对于es6模块的看法（参考阮一峰老师）\"></a>2 对于es6模块的看法（参考阮一峰老师）</h3><ul>\n<li><p><code>es6标准</code>将成为服务器和浏览器端模块化的<code>通用解决方法</code> </p>\n</li>\n<li><p><code>运行时加载</code>：代码运行到这个语句的时候才会加载 </p>\n</li>\n<li><p><code>编译时加载</code>：打包工具编译js时，就会去分析模块之间的依赖关系，所以不能放在任何条件代码块里。层级最优先</p>\n</li>\n<li><p>es6模块中的this指向是undefined，不要轻易用this, CommonJs中的this指向当前模块</p>\n</li>\n<li><p>export的使用，如果需导出的模块前面没有export，那在export的时候就要加上{}</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;fn&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>export导出语句是动态绑定的，如果导出的值发生变化，那import进的值也会随之变化</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// exportJs</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; () =&gt; foo = <span class=\"string\">'baz'</span>; &#125;,<span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">那么foo变量值将在<span class=\"number\">500</span>ms后变成baz字符串，这点与<span class=\"string\">`commonJS`</span>不一样，commonJs是会缓存值。</span><br></pre></td></tr></table></figure></li>\n<li><p><code>import</code>命令具有提升效果，会提升到整个模块的头部并首先执行，但还是建议放在头部写比较好。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo();</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;foo&#125; <span class=\"keyword\">from</span> <span class=\"string\">'module'</span>; <span class=\"comment\">// right</span></span><br></pre></td></tr></table></figure></li>\n<li><p>*号指定整体输出的一个对象</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// circle.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> funciton fn1()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js 需要引入cilcle.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> circle <span class=\"keyword\">from</span> <span class=\"string\">'./circle'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用：</span></span><br><span class=\"line\">circle.fn1();</span><br><span class=\"line\">circle.fn2();</span><br></pre></td></tr></table></figure></li>\n<li><p>export 的default输出，默认输出</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// exportJs</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// importJs</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> customFn <span class=\"keyword\">from</span> <span class=\"string\">'./exportJS'</span></span><br><span class=\"line\">customFn();</span><br></pre></td></tr></table></figure></li>\n<li><p>import函数大括号的写法时机<br>export后面接着default的时候，不用大括号，没接着的时候是要大括号的。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无 default</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; fn1&#125; <span class=\"keyword\">from</span> <span class=\"string\">'exportJs'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有default</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> fn2 <span class=\"keyword\">from</span> <span class=\"string\">'exportJs'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>因为静态分析没有运行时加载那么“动态化”，所以，import有个提案，目前可以在webpack使用，可以动态输入一个较为狭窄的路径，然后返回一个promise对象<br>这个情况下的import是支持<code>按需加载</code>，<code>条件加载</code>，和<code>动态的模块路径</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'main'</span>)</span><br><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"string\">'./someModule/$&#123;someVariable&#125;.js'</span>)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">module</span>.loadPageInfo(main)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">        mian.textContent = err.message;                                                 </span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>script标签的defer和async属性差异，两者都是取消了js的同步属性。<br>但是defer是<code>渲染完再执行</code>，而async是<code>下载完就执行</code>。</p>\n</li>\n<li><p>待验证：es6模块在网页上的加载</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"module\"</span>&gt;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> utils <span class=\"keyword\">from</span> <span class=\"string\">'./util.js'</span>;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>es6模块，导出的变量不可以重新赋值，但可以添加或修改属性，就是内存地址不能改，里面存的内容随你改，待验证。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lib.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; obj &#125; <span class=\"keyword\">from</span> <span class=\"string\">'lib'</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.prop = <span class=\"number\">123</span>; <span class=\"comment\">// right</span></span><br><span class=\"line\">obj = &#123;&#125;        <span class=\"comment\">// typeError</span></span><br></pre></td></tr></table></figure></li>\n<li><p>使用<code>import</code>命令加载<code>commonJS</code>模块，Node会自动将<code>module.exports</code>当成模块的默认输出，即等同于<code>export default</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// b.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// es.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> foo <span class=\"keyword\">from</span> <span class=\"string\">'./b.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> bar <span class=\"keyword\">from</span> <span class=\"string\">'./b.js'</span></span><br><span class=\"line\"><span class=\"comment\">// bar = &#123;default: null&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; somethimg &#125; <span class=\"keyword\">from</span> <span class=\"string\">'fs'</span> <span class=\"comment\">// error！！！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> express <span class=\"keyword\">from</span> <span class=\"string\">'express'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express.default() <span class=\"comment\">// right</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>commonJs</code>的加载原理<br>commonJs每个模块都是一个脚本文件，Node内部用require命令第一次加载就会执行这个脚本，然生成一个对象，这个会缓存，即是多次require，不清缓存下，都取第一次。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    id: <span class=\"string\">''</span>,         <span class=\"comment\">// 模块名</span></span><br><span class=\"line\">    exports: &#123;&#125;,    <span class=\"comment\">// 导出模块, </span></span><br><span class=\"line\">    loaded: <span class=\"literal\">true</span>    <span class=\"comment\">// 是否加载过</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>循环加载：模块之间相互引用<br>CommonJs会出现，输出已执行的部分，未执行的部分不会输出<br>es6模块则不会报错</p>\n</li>\n</ul>\n<p>参考文章：<br><a href=\"https://juejin.im/post/58882a42128fe100684ad9de\" target=\"_blank\" rel=\"noopener\">掘金</a><br>阮一峰es6 模块篇章</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>模块化的简单包装</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 利用了自执行函数的封闭性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> _count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> m1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(_count)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> m2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(_count + <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        m1: m1,</span><br><span class=\"line\">        m2: m2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"1-JS模块化发展历史\"><a href=\"#1-JS模块化发展历史\" class=\"headerlink\" title=\"1 JS模块化发展历史\"></a>1 JS模块化发展历史</h3><ul>\n<li>CommonJS 和 AMD CMD 鼎足之势 （前） ES6 （后）<br>（知名框架 Node.js、RequireJS前置加载 和 Seajs就近加载 分别对应前三个）</li>\n<li>谈谈现阶段：<ul>\n<li>ES6标准发布后，module成为标准，标准使用是以<code>export</code>指令导出接口，以<code>import</code>引入模块。</li>\n<li>在我们一贯的node模块中，我们依然采用的是<code>CommonJS</code>规范，使用<code>require</code>引入模块，使用<code>module.exports</code>导出接口。是<code>同步</code>加载 JS 脚本。这么做在服务端毫无问题，因为文件都存在磁盘上，然而浏览器的特性决定了 JS 脚本需要异步加载，否则就会失去响应，因此 CommonJS 规范<code>无法直接在浏览器</code>中使用。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-对于es6模块的看法（参考阮一峰老师）\"><a href=\"#2-对于es6模块的看法（参考阮一峰老师）\" class=\"headerlink\" title=\"2 对于es6模块的看法（参考阮一峰老师）\"></a>2 对于es6模块的看法（参考阮一峰老师）</h3><ul>\n<li><p><code>es6标准</code>将成为服务器和浏览器端模块化的<code>通用解决方法</code> </p>\n</li>\n<li><p><code>运行时加载</code>：代码运行到这个语句的时候才会加载 </p>\n</li>\n<li><p><code>编译时加载</code>：打包工具编译js时，就会去分析模块之间的依赖关系，所以不能放在任何条件代码块里。层级最优先</p>\n</li>\n<li><p>es6模块中的this指向是undefined，不要轻易用this, CommonJs中的this指向当前模块</p>\n</li>\n<li><p>export的使用，如果需导出的模块前面没有export，那在export的时候就要加上{}</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;fn&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>export导出语句是动态绑定的，如果导出的值发生变化，那import进的值也会随之变化</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// exportJs</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; () =&gt; foo = <span class=\"string\">'baz'</span>; &#125;,<span class=\"number\">500</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">那么foo变量值将在<span class=\"number\">500</span>ms后变成baz字符串，这点与<span class=\"string\">`commonJS`</span>不一样，commonJs是会缓存值。</span><br></pre></td></tr></table></figure></li>\n<li><p><code>import</code>命令具有提升效果，会提升到整个模块的头部并首先执行，但还是建议放在头部写比较好。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo();</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;foo&#125; <span class=\"keyword\">from</span> <span class=\"string\">'module'</span>; <span class=\"comment\">// right</span></span><br></pre></td></tr></table></figure></li>\n<li><p>*号指定整体输出的一个对象</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// circle.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> funciton fn1()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js 需要引入cilcle.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> circle <span class=\"keyword\">from</span> <span class=\"string\">'./circle'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用：</span></span><br><span class=\"line\">circle.fn1();</span><br><span class=\"line\">circle.fn2();</span><br></pre></td></tr></table></figure></li>\n<li><p>export 的default输出，默认输出</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// exportJs</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// importJs</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> customFn <span class=\"keyword\">from</span> <span class=\"string\">'./exportJS'</span></span><br><span class=\"line\">customFn();</span><br></pre></td></tr></table></figure></li>\n<li><p>import函数大括号的写法时机<br>export后面接着default的时候，不用大括号，没接着的时候是要大括号的。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无 default</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; fn1&#125; <span class=\"keyword\">from</span> <span class=\"string\">'exportJs'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有default</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> fn2 <span class=\"keyword\">from</span> <span class=\"string\">'exportJs'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>因为静态分析没有运行时加载那么“动态化”，所以，import有个提案，目前可以在webpack使用，可以动态输入一个较为狭窄的路径，然后返回一个promise对象<br>这个情况下的import是支持<code>按需加载</code>，<code>条件加载</code>，和<code>动态的模块路径</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'main'</span>)</span><br><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"string\">'./someModule/$&#123;someVariable&#125;.js'</span>)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">module</span>.loadPageInfo(main)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">        mian.textContent = err.message;                                                 </span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>script标签的defer和async属性差异，两者都是取消了js的同步属性。<br>但是defer是<code>渲染完再执行</code>，而async是<code>下载完就执行</code>。</p>\n</li>\n<li><p>待验证：es6模块在网页上的加载</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"module\"</span>&gt;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> utils <span class=\"keyword\">from</span> <span class=\"string\">'./util.js'</span>;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>es6模块，导出的变量不可以重新赋值，但可以添加或修改属性，就是内存地址不能改，里面存的内容随你改，待验证。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lib.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; obj &#125; <span class=\"keyword\">from</span> <span class=\"string\">'lib'</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.prop = <span class=\"number\">123</span>; <span class=\"comment\">// right</span></span><br><span class=\"line\">obj = &#123;&#125;        <span class=\"comment\">// typeError</span></span><br></pre></td></tr></table></figure></li>\n<li><p>使用<code>import</code>命令加载<code>commonJS</code>模块，Node会自动将<code>module.exports</code>当成模块的默认输出，即等同于<code>export default</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// b.js</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// es.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> foo <span class=\"keyword\">from</span> <span class=\"string\">'./b.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> bar <span class=\"keyword\">from</span> <span class=\"string\">'./b.js'</span></span><br><span class=\"line\"><span class=\"comment\">// bar = &#123;default: null&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; somethimg &#125; <span class=\"keyword\">from</span> <span class=\"string\">'fs'</span> <span class=\"comment\">// error！！！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> express <span class=\"keyword\">from</span> <span class=\"string\">'express'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express.default() <span class=\"comment\">// right</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>commonJs</code>的加载原理<br>commonJs每个模块都是一个脚本文件，Node内部用require命令第一次加载就会执行这个脚本，然生成一个对象，这个会缓存，即是多次require，不清缓存下，都取第一次。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    id: <span class=\"string\">''</span>,         <span class=\"comment\">// 模块名</span></span><br><span class=\"line\">    exports: &#123;&#125;,    <span class=\"comment\">// 导出模块, </span></span><br><span class=\"line\">    loaded: <span class=\"literal\">true</span>    <span class=\"comment\">// 是否加载过</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>循环加载：模块之间相互引用<br>CommonJs会出现，输出已执行的部分，未执行的部分不会输出<br>es6模块则不会报错</p>\n</li>\n</ul>\n<p>参考文章：<br><a href=\"https://juejin.im/post/58882a42128fe100684ad9de\" target=\"_blank\" rel=\"noopener\">掘金</a><br>阮一峰es6 模块篇章</p>\n"},{"title":"PWA","date":"2020-02-06T09:19:35.000Z","_content":"\n### 1.PWA是什么？（`Progressive Web App`）\n书面上意思：渐进式网络应用\n特点：\n+ 稳定：不好的网络环境下也有好的展现数据能力（`service worker`）\n+ 过渡自然的动画交互，良好的滚动，响应快\n+ 像原生一般丝滑，可以推送，可安装\n+ android支持度好，apple支持度差\n\n### 1.1 关键技术\n+ service worker : 一个存在于客户端和服务器之间的代理，可以控制缓存和应对资源请求,预缓存关键资源。所以它对安全的要求也很高，需要在Https环境下运行。\n+ manifest: （可以理解为一个可设置的入口文件）\n​              能够将你浏览的网页添加到你的手机屏幕上\n​              在 Android 上能够全屏启动，不显示地址栏 （ 由于 Iphone 手机的浏览器是 Safari ，所以不支持哦）\n​              控制屏幕 横屏 / 竖屏 展示\n​              定义启动画面\n​              可以设置你的应用启动是从主屏幕启动还是从 URL 启动\n​              可以设置你添加屏幕上的应用程序图标、名字、图标大小\n\n\n### 2.可以用来干嘛呢\n+ 推送，这点需要安卓去验证，目前PWA的支持度仅是安卓比较好。ios的google浏览器也不支持\n+ 离线缓存。 可以设置缓存的资源，即使离线也可以访问\n\n\n\n### 3. DEMO\ndemo已放在mineScript文件夹下\ngithub地址是：[demo](https://github.com/jonnzer/good_snippet/tree/master/PWA)\n\n+ 代码结构：\n- sw.js: 引入serviceWorker.js，定义缓存资源，部署整个sw的生命周期代码\n- manifest.json: 一个定义好背景颜色，展示图片，icon，的入口文件。\n- 建议部署在https环境下的cdn。\n\n参考链接：\n[官网](https://developers.google.com/web/progressive-web-apps/)\n[掘金1](https://juejin.im/post/5ae2f82f6fb9a07acd4d761e)\n[serviceWorker的调试](https://www.villainhr.com/page/2017/01/08/Service%20Worker%20%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6)","source":"_posts/PWA.md","raw":"---\ntitle: PWA\ndate: 2020-02-06 17:19:35\ntags: 工具\n---\n\n### 1.PWA是什么？（`Progressive Web App`）\n书面上意思：渐进式网络应用\n特点：\n+ 稳定：不好的网络环境下也有好的展现数据能力（`service worker`）\n+ 过渡自然的动画交互，良好的滚动，响应快\n+ 像原生一般丝滑，可以推送，可安装\n+ android支持度好，apple支持度差\n\n### 1.1 关键技术\n+ service worker : 一个存在于客户端和服务器之间的代理，可以控制缓存和应对资源请求,预缓存关键资源。所以它对安全的要求也很高，需要在Https环境下运行。\n+ manifest: （可以理解为一个可设置的入口文件）\n​              能够将你浏览的网页添加到你的手机屏幕上\n​              在 Android 上能够全屏启动，不显示地址栏 （ 由于 Iphone 手机的浏览器是 Safari ，所以不支持哦）\n​              控制屏幕 横屏 / 竖屏 展示\n​              定义启动画面\n​              可以设置你的应用启动是从主屏幕启动还是从 URL 启动\n​              可以设置你添加屏幕上的应用程序图标、名字、图标大小\n\n\n### 2.可以用来干嘛呢\n+ 推送，这点需要安卓去验证，目前PWA的支持度仅是安卓比较好。ios的google浏览器也不支持\n+ 离线缓存。 可以设置缓存的资源，即使离线也可以访问\n\n\n\n### 3. DEMO\ndemo已放在mineScript文件夹下\ngithub地址是：[demo](https://github.com/jonnzer/good_snippet/tree/master/PWA)\n\n+ 代码结构：\n- sw.js: 引入serviceWorker.js，定义缓存资源，部署整个sw的生命周期代码\n- manifest.json: 一个定义好背景颜色，展示图片，icon，的入口文件。\n- 建议部署在https环境下的cdn。\n\n参考链接：\n[官网](https://developers.google.com/web/progressive-web-apps/)\n[掘金1](https://juejin.im/post/5ae2f82f6fb9a07acd4d761e)\n[serviceWorker的调试](https://www.villainhr.com/page/2017/01/08/Service%20Worker%20%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6)","slug":"PWA","published":1,"updated":"2020-03-12T08:47:49.650Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr9s000iz5o86piu1qw0","content":"<h3 id=\"1-PWA是什么？（Progressive-Web-App）\"><a href=\"#1-PWA是什么？（Progressive-Web-App）\" class=\"headerlink\" title=\"1.PWA是什么？（Progressive Web App）\"></a>1.PWA是什么？（<code>Progressive Web App</code>）</h3><p>书面上意思：渐进式网络应用<br>特点：</p>\n<ul>\n<li>稳定：不好的网络环境下也有好的展现数据能力（<code>service worker</code>）</li>\n<li>过渡自然的动画交互，良好的滚动，响应快</li>\n<li>像原生一般丝滑，可以推送，可安装</li>\n<li>android支持度好，apple支持度差</li>\n</ul>\n<h3 id=\"1-1-关键技术\"><a href=\"#1-1-关键技术\" class=\"headerlink\" title=\"1.1 关键技术\"></a>1.1 关键技术</h3><ul>\n<li>service worker : 一个存在于客户端和服务器之间的代理，可以控制缓存和应对资源请求,预缓存关键资源。所以它对安全的要求也很高，需要在Https环境下运行。</li>\n<li>manifest: （可以理解为一个可设置的入口文件）<br>​              能够将你浏览的网页添加到你的手机屏幕上<br>​              在 Android 上能够全屏启动，不显示地址栏 （ 由于 Iphone 手机的浏览器是 Safari ，所以不支持哦）<br>​              控制屏幕 横屏 / 竖屏 展示<br>​              定义启动画面<br>​              可以设置你的应用启动是从主屏幕启动还是从 URL 启动<br>​              可以设置你添加屏幕上的应用程序图标、名字、图标大小</li>\n</ul>\n<h3 id=\"2-可以用来干嘛呢\"><a href=\"#2-可以用来干嘛呢\" class=\"headerlink\" title=\"2.可以用来干嘛呢\"></a>2.可以用来干嘛呢</h3><ul>\n<li>推送，这点需要安卓去验证，目前PWA的支持度仅是安卓比较好。ios的google浏览器也不支持</li>\n<li>离线缓存。 可以设置缓存的资源，即使离线也可以访问</li>\n</ul>\n<h3 id=\"3-DEMO\"><a href=\"#3-DEMO\" class=\"headerlink\" title=\"3. DEMO\"></a>3. DEMO</h3><p>demo已放在mineScript文件夹下<br>github地址是：<a href=\"https://github.com/jonnzer/good_snippet/tree/master/PWA\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n<ul>\n<li>代码结构：</li>\n</ul>\n<ul>\n<li>sw.js: 引入serviceWorker.js，定义缓存资源，部署整个sw的生命周期代码</li>\n<li>manifest.json: 一个定义好背景颜色，展示图片，icon，的入口文件。</li>\n<li>建议部署在https环境下的cdn。</li>\n</ul>\n<p>参考链接：<br><a href=\"https://developers.google.com/web/progressive-web-apps/\" target=\"_blank\" rel=\"noopener\">官网</a><br><a href=\"https://juejin.im/post/5ae2f82f6fb9a07acd4d761e\" target=\"_blank\" rel=\"noopener\">掘金1</a><br><a href=\"https://www.villainhr.com/page/2017/01/08/Service%20Worker%20%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6\" target=\"_blank\" rel=\"noopener\">serviceWorker的调试</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-PWA是什么？（Progressive-Web-App）\"><a href=\"#1-PWA是什么？（Progressive-Web-App）\" class=\"headerlink\" title=\"1.PWA是什么？（Progressive Web App）\"></a>1.PWA是什么？（<code>Progressive Web App</code>）</h3><p>书面上意思：渐进式网络应用<br>特点：</p>\n<ul>\n<li>稳定：不好的网络环境下也有好的展现数据能力（<code>service worker</code>）</li>\n<li>过渡自然的动画交互，良好的滚动，响应快</li>\n<li>像原生一般丝滑，可以推送，可安装</li>\n<li>android支持度好，apple支持度差</li>\n</ul>\n<h3 id=\"1-1-关键技术\"><a href=\"#1-1-关键技术\" class=\"headerlink\" title=\"1.1 关键技术\"></a>1.1 关键技术</h3><ul>\n<li>service worker : 一个存在于客户端和服务器之间的代理，可以控制缓存和应对资源请求,预缓存关键资源。所以它对安全的要求也很高，需要在Https环境下运行。</li>\n<li>manifest: （可以理解为一个可设置的入口文件）<br>​              能够将你浏览的网页添加到你的手机屏幕上<br>​              在 Android 上能够全屏启动，不显示地址栏 （ 由于 Iphone 手机的浏览器是 Safari ，所以不支持哦）<br>​              控制屏幕 横屏 / 竖屏 展示<br>​              定义启动画面<br>​              可以设置你的应用启动是从主屏幕启动还是从 URL 启动<br>​              可以设置你添加屏幕上的应用程序图标、名字、图标大小</li>\n</ul>\n<h3 id=\"2-可以用来干嘛呢\"><a href=\"#2-可以用来干嘛呢\" class=\"headerlink\" title=\"2.可以用来干嘛呢\"></a>2.可以用来干嘛呢</h3><ul>\n<li>推送，这点需要安卓去验证，目前PWA的支持度仅是安卓比较好。ios的google浏览器也不支持</li>\n<li>离线缓存。 可以设置缓存的资源，即使离线也可以访问</li>\n</ul>\n<h3 id=\"3-DEMO\"><a href=\"#3-DEMO\" class=\"headerlink\" title=\"3. DEMO\"></a>3. DEMO</h3><p>demo已放在mineScript文件夹下<br>github地址是：<a href=\"https://github.com/jonnzer/good_snippet/tree/master/PWA\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n<ul>\n<li>代码结构：</li>\n</ul>\n<ul>\n<li>sw.js: 引入serviceWorker.js，定义缓存资源，部署整个sw的生命周期代码</li>\n<li>manifest.json: 一个定义好背景颜色，展示图片，icon，的入口文件。</li>\n<li>建议部署在https环境下的cdn。</li>\n</ul>\n<p>参考链接：<br><a href=\"https://developers.google.com/web/progressive-web-apps/\" target=\"_blank\" rel=\"noopener\">官网</a><br><a href=\"https://juejin.im/post/5ae2f82f6fb9a07acd4d761e\" target=\"_blank\" rel=\"noopener\">掘金1</a><br><a href=\"https://www.villainhr.com/page/2017/01/08/Service%20Worker%20%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6\" target=\"_blank\" rel=\"noopener\">serviceWorker的调试</a></p>\n"},{"title":"sql","date":"2018-05-02T14:29:06.000Z","_content":"\n#### 为了新项目的sql存储，我觉得还是很有必要学下sql\n    so～～ 开始！\n\n    刚开始就报了错，Access denied for user 'root'@'localhost' (using password: NO)\n    用这个命令(登录MYSQL的意思)，mysql -uroot -p\n    然后重新输一遍密码\n\n\n#### 语法\n    (1) sql命令必须带;分号，否则提示sql语句错误。\n    (2) 退出mysql： exit;\n    (3) MYSQL删除表 语法：drop table 'table_name';\n    (4) 创建数据库： create database databaseNname;\n    (5) show databases;  是用来看登陆后的用户有多少关联的数据库\n    (6) use database's name; 进入该数据库\n    (7) show tables; 查看该数据库的表格\n    (8) desc table's name; 查看该表的结构\n\n\n\n\n#### 调试方案（基于mac os）\n\n```sql\n        mysql -u root -p\n        create database name;\n        use name;\n```\n        之后，可以在命令行 source (将sql文件拖拽进来，去掉file://)\n        所以你可以本地写好sql文件，在命令行执行并检验\n\n(2) 用sequel pro工具来查看sql图形化表格，对照看在命令行写的sql是否起效\n\n\n#### 数据类型\n<img src='./package.png' style=\"width:50%;height:60%;\">\n参考链接 http://www.runoob.com/mysql/mysql-data-types.html\n\n#### 常规操作\n```sql\n        CREATE TABLE IF NOT EXISTS `movie` (\n            `id` INT(11) NOT NULL  AUTO_INCREMENT,\n            `movie_name` CHAR(255) NOT NULL,\n            `high_image` CHAR(255) NOT NULL,\n            `content` CHAR(255) NOT NULL,\n            PRIMARY KEY (`id`)\n        ) ENGINE=InnoDB AUTO_INCREMENT = 3 DEFAULT CHARSET=utf8;\n```\n下面是增删改查，最重要的部分：\n### 增加，批量\n```sql (结构：INSERT INTO 表名 （要增加的列名）VALUES （对应的值）)\n        INSERT INTO movie (movie_name,high_image,content) VALUES\n            ('头号玩家','www.baidu.com/a.jpg','VR高级模拟现实游戏'),\n            ('斗破苍穹','www.baidu.com/b.jpg','热血国漫'),\n            ('仙剑奇侠传','www.baidu.com/c.jpg','良心国产仙侠');\n```\n\n### 改 (结构：UPDATE 表名 SET 要修改的列,逗号隔开 WHERE 匹配条件 )\n```sql\n     UPDATE movie SET high_image='www.touhaowanjia.com/1.jpg' WHERE movie_name='头号玩家';\n```\n\n### 删 (结构：DELETE FROM 表名 WHERE 匹配条件  )\n```sql\n    DELETE FROM movie WHERE id=9;\n\n```\n\n### 查 (结构：SELECT 列 FROM 表名 WHERE 匹配条件  )\n（1）查询所有列\n```sql\n    SELECT * FROM movie;\n```\n（2）查询指定列\n```sql\n   SELECT content FROM movie;\n\n```\n\n### 报错处理：\n    具体就看报错语句，提示在哪里附近报错，第几行，near 什么\n","source":"_posts/sql.md","raw":"---\ntitle: sql\ndate: 2018-05-02 22:29:06\ntags: sql\n\n---\n\n#### 为了新项目的sql存储，我觉得还是很有必要学下sql\n    so～～ 开始！\n\n    刚开始就报了错，Access denied for user 'root'@'localhost' (using password: NO)\n    用这个命令(登录MYSQL的意思)，mysql -uroot -p\n    然后重新输一遍密码\n\n\n#### 语法\n    (1) sql命令必须带;分号，否则提示sql语句错误。\n    (2) 退出mysql： exit;\n    (3) MYSQL删除表 语法：drop table 'table_name';\n    (4) 创建数据库： create database databaseNname;\n    (5) show databases;  是用来看登陆后的用户有多少关联的数据库\n    (6) use database's name; 进入该数据库\n    (7) show tables; 查看该数据库的表格\n    (8) desc table's name; 查看该表的结构\n\n\n\n\n#### 调试方案（基于mac os）\n\n```sql\n        mysql -u root -p\n        create database name;\n        use name;\n```\n        之后，可以在命令行 source (将sql文件拖拽进来，去掉file://)\n        所以你可以本地写好sql文件，在命令行执行并检验\n\n(2) 用sequel pro工具来查看sql图形化表格，对照看在命令行写的sql是否起效\n\n\n#### 数据类型\n<img src='./package.png' style=\"width:50%;height:60%;\">\n参考链接 http://www.runoob.com/mysql/mysql-data-types.html\n\n#### 常规操作\n```sql\n        CREATE TABLE IF NOT EXISTS `movie` (\n            `id` INT(11) NOT NULL  AUTO_INCREMENT,\n            `movie_name` CHAR(255) NOT NULL,\n            `high_image` CHAR(255) NOT NULL,\n            `content` CHAR(255) NOT NULL,\n            PRIMARY KEY (`id`)\n        ) ENGINE=InnoDB AUTO_INCREMENT = 3 DEFAULT CHARSET=utf8;\n```\n下面是增删改查，最重要的部分：\n### 增加，批量\n```sql (结构：INSERT INTO 表名 （要增加的列名）VALUES （对应的值）)\n        INSERT INTO movie (movie_name,high_image,content) VALUES\n            ('头号玩家','www.baidu.com/a.jpg','VR高级模拟现实游戏'),\n            ('斗破苍穹','www.baidu.com/b.jpg','热血国漫'),\n            ('仙剑奇侠传','www.baidu.com/c.jpg','良心国产仙侠');\n```\n\n### 改 (结构：UPDATE 表名 SET 要修改的列,逗号隔开 WHERE 匹配条件 )\n```sql\n     UPDATE movie SET high_image='www.touhaowanjia.com/1.jpg' WHERE movie_name='头号玩家';\n```\n\n### 删 (结构：DELETE FROM 表名 WHERE 匹配条件  )\n```sql\n    DELETE FROM movie WHERE id=9;\n\n```\n\n### 查 (结构：SELECT 列 FROM 表名 WHERE 匹配条件  )\n（1）查询所有列\n```sql\n    SELECT * FROM movie;\n```\n（2）查询指定列\n```sql\n   SELECT content FROM movie;\n\n```\n\n### 报错处理：\n    具体就看报错语句，提示在哪里附近报错，第几行，near 什么\n","slug":"sql","published":1,"updated":"2018-06-09T04:33:20.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr9u000kz5o89vqkck1g","content":"<h4 id=\"为了新项目的sql存储，我觉得还是很有必要学下sql\"><a href=\"#为了新项目的sql存储，我觉得还是很有必要学下sql\" class=\"headerlink\" title=\"为了新项目的sql存储，我觉得还是很有必要学下sql\"></a>为了新项目的sql存储，我觉得还是很有必要学下sql</h4><pre><code>so～～ 开始！\n\n刚开始就报了错，Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: NO)\n用这个命令(登录MYSQL的意思)，mysql -uroot -p\n然后重新输一遍密码</code></pre><h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><pre><code>(1) sql命令必须带;分号，否则提示sql语句错误。\n(2) 退出mysql： exit;\n(3) MYSQL删除表 语法：drop table &apos;table_name&apos;;\n(4) 创建数据库： create database databaseNname;\n(5) show databases;  是用来看登陆后的用户有多少关联的数据库\n(6) use database&apos;s name; 进入该数据库\n(7) show tables; 查看该数据库的表格\n(8) desc table&apos;s name; 查看该表的结构</code></pre><h4 id=\"调试方案（基于mac-os）\"><a href=\"#调试方案（基于mac-os）\" class=\"headerlink\" title=\"调试方案（基于mac os）\"></a>调试方案（基于mac os）</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u root -p</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">database</span> <span class=\"keyword\">name</span>;</span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"keyword\">name</span>;</span><br></pre></td></tr></table></figure>\n<pre><code>之后，可以在命令行 source (将sql文件拖拽进来，去掉file://)\n所以你可以本地写好sql文件，在命令行执行并检验</code></pre><p>(2) 用sequel pro工具来查看sql图形化表格，对照看在命令行写的sql是否起效</p>\n<h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><img src=\"/2018/05/02/sql/package.png\" style=\"width:50%;height:60%;\">\n参考链接 http://www.runoob.com/mysql/mysql-data-types.html\n\n<h4 id=\"常规操作\"><a href=\"#常规操作\" class=\"headerlink\" title=\"常规操作\"></a>常规操作</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`movie`</span> (</span><br><span class=\"line\">    <span class=\"string\">`id`</span> <span class=\"built_in\">INT</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>  AUTO_INCREMENT,</span><br><span class=\"line\">    <span class=\"string\">`movie_name`</span> <span class=\"built_in\">CHAR</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"string\">`high_image`</span> <span class=\"built_in\">CHAR</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"string\">`content`</span> <span class=\"built_in\">CHAR</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT = <span class=\"number\">3</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>\n<p>下面是增删改查，最重要的部分：</p>\n<h3 id=\"增加，批量\"><a href=\"#增加，批量\" class=\"headerlink\" title=\"增加，批量\"></a>增加，批量</h3><figure class=\"highlight sql\"><figcaption><span>(结构：INSERT INTO 表名 （要增加的列名）VALUES （对应的值）)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> movie (movie_name,high_image,<span class=\"keyword\">content</span>) <span class=\"keyword\">VALUES</span></span><br><span class=\"line\">    (<span class=\"string\">'头号玩家'</span>,<span class=\"string\">'www.baidu.com/a.jpg'</span>,<span class=\"string\">'VR高级模拟现实游戏'</span>),</span><br><span class=\"line\">    (<span class=\"string\">'斗破苍穹'</span>,<span class=\"string\">'www.baidu.com/b.jpg'</span>,<span class=\"string\">'热血国漫'</span>),</span><br><span class=\"line\">    (<span class=\"string\">'仙剑奇侠传'</span>,<span class=\"string\">'www.baidu.com/c.jpg'</span>,<span class=\"string\">'良心国产仙侠'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"改-结构：UPDATE-表名-SET-要修改的列-逗号隔开-WHERE-匹配条件\"><a href=\"#改-结构：UPDATE-表名-SET-要修改的列-逗号隔开-WHERE-匹配条件\" class=\"headerlink\" title=\"改 (结构：UPDATE 表名 SET 要修改的列,逗号隔开 WHERE 匹配条件 )\"></a>改 (结构：UPDATE 表名 SET 要修改的列,逗号隔开 WHERE 匹配条件 )</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> movie <span class=\"keyword\">SET</span> high_image=<span class=\"string\">'www.touhaowanjia.com/1.jpg'</span> <span class=\"keyword\">WHERE</span> movie_name=<span class=\"string\">'头号玩家'</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删-结构：DELETE-FROM-表名-WHERE-匹配条件\"><a href=\"#删-结构：DELETE-FROM-表名-WHERE-匹配条件\" class=\"headerlink\" title=\"删 (结构：DELETE FROM 表名 WHERE 匹配条件  )\"></a>删 (结构：DELETE FROM 表名 WHERE 匹配条件  )</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> movie <span class=\"keyword\">WHERE</span> <span class=\"keyword\">id</span>=<span class=\"number\">9</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查-结构：SELECT-列-FROM-表名-WHERE-匹配条件\"><a href=\"#查-结构：SELECT-列-FROM-表名-WHERE-匹配条件\" class=\"headerlink\" title=\"查 (结构：SELECT 列 FROM 表名 WHERE 匹配条件  )\"></a>查 (结构：SELECT 列 FROM 表名 WHERE 匹配条件  )</h3><p>（1）查询所有列</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> movie;</span><br></pre></td></tr></table></figure>\n<p>（2）查询指定列</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">content</span> <span class=\"keyword\">FROM</span> movie;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"报错处理：\"><a href=\"#报错处理：\" class=\"headerlink\" title=\"报错处理：\"></a>报错处理：</h3><pre><code>具体就看报错语句，提示在哪里附近报错，第几行，near 什么</code></pre>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"为了新项目的sql存储，我觉得还是很有必要学下sql\"><a href=\"#为了新项目的sql存储，我觉得还是很有必要学下sql\" class=\"headerlink\" title=\"为了新项目的sql存储，我觉得还是很有必要学下sql\"></a>为了新项目的sql存储，我觉得还是很有必要学下sql</h4><pre><code>so～～ 开始！\n\n刚开始就报了错，Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: NO)\n用这个命令(登录MYSQL的意思)，mysql -uroot -p\n然后重新输一遍密码</code></pre><h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><pre><code>(1) sql命令必须带;分号，否则提示sql语句错误。\n(2) 退出mysql： exit;\n(3) MYSQL删除表 语法：drop table &apos;table_name&apos;;\n(4) 创建数据库： create database databaseNname;\n(5) show databases;  是用来看登陆后的用户有多少关联的数据库\n(6) use database&apos;s name; 进入该数据库\n(7) show tables; 查看该数据库的表格\n(8) desc table&apos;s name; 查看该表的结构</code></pre><h4 id=\"调试方案（基于mac-os）\"><a href=\"#调试方案（基于mac-os）\" class=\"headerlink\" title=\"调试方案（基于mac os）\"></a>调试方案（基于mac os）</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u root -p</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">database</span> <span class=\"keyword\">name</span>;</span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"keyword\">name</span>;</span><br></pre></td></tr></table></figure>\n<pre><code>之后，可以在命令行 source (将sql文件拖拽进来，去掉file://)\n所以你可以本地写好sql文件，在命令行执行并检验</code></pre><p>(2) 用sequel pro工具来查看sql图形化表格，对照看在命令行写的sql是否起效</p>\n<h4 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h4><img src=\"/2018/05/02/sql/package.png\" style=\"width:50%;height:60%;\">\n参考链接 http://www.runoob.com/mysql/mysql-data-types.html\n\n<h4 id=\"常规操作\"><a href=\"#常规操作\" class=\"headerlink\" title=\"常规操作\"></a>常规操作</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`movie`</span> (</span><br><span class=\"line\">    <span class=\"string\">`id`</span> <span class=\"built_in\">INT</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>  AUTO_INCREMENT,</span><br><span class=\"line\">    <span class=\"string\">`movie_name`</span> <span class=\"built_in\">CHAR</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"string\">`high_image`</span> <span class=\"built_in\">CHAR</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"string\">`content`</span> <span class=\"built_in\">CHAR</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT = <span class=\"number\">3</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>\n<p>下面是增删改查，最重要的部分：</p>\n<h3 id=\"增加，批量\"><a href=\"#增加，批量\" class=\"headerlink\" title=\"增加，批量\"></a>增加，批量</h3><figure class=\"highlight sql\"><figcaption><span>(结构：INSERT INTO 表名 （要增加的列名）VALUES （对应的值）)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> movie (movie_name,high_image,<span class=\"keyword\">content</span>) <span class=\"keyword\">VALUES</span></span><br><span class=\"line\">    (<span class=\"string\">'头号玩家'</span>,<span class=\"string\">'www.baidu.com/a.jpg'</span>,<span class=\"string\">'VR高级模拟现实游戏'</span>),</span><br><span class=\"line\">    (<span class=\"string\">'斗破苍穹'</span>,<span class=\"string\">'www.baidu.com/b.jpg'</span>,<span class=\"string\">'热血国漫'</span>),</span><br><span class=\"line\">    (<span class=\"string\">'仙剑奇侠传'</span>,<span class=\"string\">'www.baidu.com/c.jpg'</span>,<span class=\"string\">'良心国产仙侠'</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"改-结构：UPDATE-表名-SET-要修改的列-逗号隔开-WHERE-匹配条件\"><a href=\"#改-结构：UPDATE-表名-SET-要修改的列-逗号隔开-WHERE-匹配条件\" class=\"headerlink\" title=\"改 (结构：UPDATE 表名 SET 要修改的列,逗号隔开 WHERE 匹配条件 )\"></a>改 (结构：UPDATE 表名 SET 要修改的列,逗号隔开 WHERE 匹配条件 )</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> movie <span class=\"keyword\">SET</span> high_image=<span class=\"string\">'www.touhaowanjia.com/1.jpg'</span> <span class=\"keyword\">WHERE</span> movie_name=<span class=\"string\">'头号玩家'</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删-结构：DELETE-FROM-表名-WHERE-匹配条件\"><a href=\"#删-结构：DELETE-FROM-表名-WHERE-匹配条件\" class=\"headerlink\" title=\"删 (结构：DELETE FROM 表名 WHERE 匹配条件  )\"></a>删 (结构：DELETE FROM 表名 WHERE 匹配条件  )</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> movie <span class=\"keyword\">WHERE</span> <span class=\"keyword\">id</span>=<span class=\"number\">9</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查-结构：SELECT-列-FROM-表名-WHERE-匹配条件\"><a href=\"#查-结构：SELECT-列-FROM-表名-WHERE-匹配条件\" class=\"headerlink\" title=\"查 (结构：SELECT 列 FROM 表名 WHERE 匹配条件  )\"></a>查 (结构：SELECT 列 FROM 表名 WHERE 匹配条件  )</h3><p>（1）查询所有列</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> movie;</span><br></pre></td></tr></table></figure>\n<p>（2）查询指定列</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">content</span> <span class=\"keyword\">FROM</span> movie;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"报错处理：\"><a href=\"#报错处理：\" class=\"headerlink\" title=\"报错处理：\"></a>报错处理：</h3><pre><code>具体就看报错语句，提示在哪里附近报错，第几行，near 什么</code></pre>"},{"title":"proxy","date":"2020-06-14T06:50:21.000Z","_content":"\n`vue`源码的render部分，曾用到`proxy`来代理vue的实例。\n\n### 1 概念：\n`proxy` 原意就有代理的意思。它是外界访问对象的一层`代理控制`，也是对访问的一种`改写和过滤`。属于一种`元编程`。\n\n### 2 作用：\n可以从获取和设置两种时机去代理指定对象\n\n### 3 代码结构：\n\n标准结构：\n> var proxy = new Proxy (target, handler);  // target是拦截的目标  handler是拦截行为\n\n\n```javascript\n    var obj = new Proxy({\n        get: function(target, key, receiver) {\n            console.log(`getting ${key}`)\n            return Reflect.get(target, key, receiver)\n        },\n        set: function(target, key, value, receiver) {\n            console.log(`setting ${key}`)\n            return Reflect.set(target, key, value, receiver)\n        }\n    })\n\n    obj // 默认是{}    \n    obj.a = 1 // setting a\n    obj.a = 2 // setting a\n    console.log(obj.a) // getting a\n```\n\n### 4. 要注意的点：\n+ 要使proxy起作用，需对proxy的实例 进行操作，而不是针对原目标对象。\n\n+ 与原型的应用：\n```javascript\nvar proxy = new Proxy({}, {\n    get: function(target, property) {\n      return 35\n    },\n})\nlet _obj = Object.create(proxy)\n_obj.time // 35\n\n// proxy对象是_obj的原型，_obj上没有time这个属性，就顺着原型链找到proxy，proxy上的任何属性都会返回35\n```\n\n### 5. proxy还支持get、set之外的api补充\n\n```javascript\n    var handler = {\n      get: function(target, name) {\n        if (name === 'prototype') {\n          return Object.prototype;\n        }\n        return 'Hello, ' + name;\n      },\n    \n      apply: function(target, thisBinding, args) { // proxy实例作为函数调用时触发\n        return args[0];\n      },\n    \n      construct: function(target, args) { // proxy作为构造函数时触发\n        return {value: args[1]};\n      }\n    };\n    \n    var fproxy = new Proxy(function(x, y) {\n      return x + y;\n    }, handler);\n    \n    fproxy(1, 2) // 1\n    new fproxy(1, 2) // {value: 2}\n    fproxy.prototype === Object.prototype // true\n    fproxy.foo === \"Hello, foo\" // true\n```\n\n```javascript\n    // get 拦截 负数索引\n    function createArray(...elements) {\n      let handler = {\n         get: function(target, property, receiver) { \n             let index = Number(property) // -1 会作为属性传进来\n             if (index < 0) {\n                 property = String(target.length + index) // property\\target 是可以修改的 奇怪...\n             }\n             return Reflect.get(target, property, receiver) // Reflect is what\n         }\n     }\n     let target = []\n     target.push(...elements)\n     return new Proxy(target, handler)\n    }\n    arr = createArray('a', 'b', 'c')\n    arr[-1] // 'c'\n```\n\n### 6. 属性需可配置，configuable 和 可写writable，否则proxy实例访问代理这个属性会报错 (也是一条可以阻止proxy的法子)\n```javascript\n    const target = Object.defineProperties({}, {\n      foo: {\n        value: 123,\n        writable: false,\n        configurable: false\n      },\n    });\n    \n    const handler = {\n      get(target, propKey) {\n        return 'abc';\n      }\n    };\n    \n    const proxy = new Proxy(target, handler);\n    \n    proxy.foo\n    // Uncaught TypeError: 'get' on proxy: property 'foo' is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected '123' but got 'abc')\n```\n\n--- \n引申了解：\n+ 元编程的概念\n+ proxy的get和set，与 Object.defineProperty 相比，有什么区别\n    - 答：[jueim](https://juejin.im/post/5be4f7cfe51d453339084530) proxy的应用场景更多，但是define的兼容性更好\n    - 答：[issue](https://github.com/YvetteLau/Blog/issues/25)\n    - 答：[两者实现双向绑定差异](https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf)\n---\n参考文章：\n[阮一峰es6 proxy章节](https://es6.ruanyifeng.com/#docs/proxy)\n[深入浅出es6系列](https://www.infoq.cn/article/es6-in-depth-proxies-and-reflect)\n[segmentFault](https://www.infoq.cn/article/es6-in-depth-proxies-and-reflect)\n[元编程](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Meta_programming)","source":"_posts/proxy.md","raw":"---\ntitle: proxy\ndate: 2020-06-14 14:50:21\ntags: ES6\n---\n\n`vue`源码的render部分，曾用到`proxy`来代理vue的实例。\n\n### 1 概念：\n`proxy` 原意就有代理的意思。它是外界访问对象的一层`代理控制`，也是对访问的一种`改写和过滤`。属于一种`元编程`。\n\n### 2 作用：\n可以从获取和设置两种时机去代理指定对象\n\n### 3 代码结构：\n\n标准结构：\n> var proxy = new Proxy (target, handler);  // target是拦截的目标  handler是拦截行为\n\n\n```javascript\n    var obj = new Proxy({\n        get: function(target, key, receiver) {\n            console.log(`getting ${key}`)\n            return Reflect.get(target, key, receiver)\n        },\n        set: function(target, key, value, receiver) {\n            console.log(`setting ${key}`)\n            return Reflect.set(target, key, value, receiver)\n        }\n    })\n\n    obj // 默认是{}    \n    obj.a = 1 // setting a\n    obj.a = 2 // setting a\n    console.log(obj.a) // getting a\n```\n\n### 4. 要注意的点：\n+ 要使proxy起作用，需对proxy的实例 进行操作，而不是针对原目标对象。\n\n+ 与原型的应用：\n```javascript\nvar proxy = new Proxy({}, {\n    get: function(target, property) {\n      return 35\n    },\n})\nlet _obj = Object.create(proxy)\n_obj.time // 35\n\n// proxy对象是_obj的原型，_obj上没有time这个属性，就顺着原型链找到proxy，proxy上的任何属性都会返回35\n```\n\n### 5. proxy还支持get、set之外的api补充\n\n```javascript\n    var handler = {\n      get: function(target, name) {\n        if (name === 'prototype') {\n          return Object.prototype;\n        }\n        return 'Hello, ' + name;\n      },\n    \n      apply: function(target, thisBinding, args) { // proxy实例作为函数调用时触发\n        return args[0];\n      },\n    \n      construct: function(target, args) { // proxy作为构造函数时触发\n        return {value: args[1]};\n      }\n    };\n    \n    var fproxy = new Proxy(function(x, y) {\n      return x + y;\n    }, handler);\n    \n    fproxy(1, 2) // 1\n    new fproxy(1, 2) // {value: 2}\n    fproxy.prototype === Object.prototype // true\n    fproxy.foo === \"Hello, foo\" // true\n```\n\n```javascript\n    // get 拦截 负数索引\n    function createArray(...elements) {\n      let handler = {\n         get: function(target, property, receiver) { \n             let index = Number(property) // -1 会作为属性传进来\n             if (index < 0) {\n                 property = String(target.length + index) // property\\target 是可以修改的 奇怪...\n             }\n             return Reflect.get(target, property, receiver) // Reflect is what\n         }\n     }\n     let target = []\n     target.push(...elements)\n     return new Proxy(target, handler)\n    }\n    arr = createArray('a', 'b', 'c')\n    arr[-1] // 'c'\n```\n\n### 6. 属性需可配置，configuable 和 可写writable，否则proxy实例访问代理这个属性会报错 (也是一条可以阻止proxy的法子)\n```javascript\n    const target = Object.defineProperties({}, {\n      foo: {\n        value: 123,\n        writable: false,\n        configurable: false\n      },\n    });\n    \n    const handler = {\n      get(target, propKey) {\n        return 'abc';\n      }\n    };\n    \n    const proxy = new Proxy(target, handler);\n    \n    proxy.foo\n    // Uncaught TypeError: 'get' on proxy: property 'foo' is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected '123' but got 'abc')\n```\n\n--- \n引申了解：\n+ 元编程的概念\n+ proxy的get和set，与 Object.defineProperty 相比，有什么区别\n    - 答：[jueim](https://juejin.im/post/5be4f7cfe51d453339084530) proxy的应用场景更多，但是define的兼容性更好\n    - 答：[issue](https://github.com/YvetteLau/Blog/issues/25)\n    - 答：[两者实现双向绑定差异](https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf)\n---\n参考文章：\n[阮一峰es6 proxy章节](https://es6.ruanyifeng.com/#docs/proxy)\n[深入浅出es6系列](https://www.infoq.cn/article/es6-in-depth-proxies-and-reflect)\n[segmentFault](https://www.infoq.cn/article/es6-in-depth-proxies-and-reflect)\n[元编程](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Meta_programming)","slug":"proxy","published":1,"updated":"2020-06-17T06:35:05.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr9v000mz5o83fx436le","content":"<p><code>vue</code>源码的render部分，曾用到<code>proxy</code>来代理vue的实例。</p>\n<h3 id=\"1-概念：\"><a href=\"#1-概念：\" class=\"headerlink\" title=\"1 概念：\"></a>1 概念：</h3><p><code>proxy</code> 原意就有代理的意思。它是外界访问对象的一层<code>代理控制</code>，也是对访问的一种<code>改写和过滤</code>。属于一种<code>元编程</code>。</p>\n<h3 id=\"2-作用：\"><a href=\"#2-作用：\" class=\"headerlink\" title=\"2 作用：\"></a>2 作用：</h3><p>可以从获取和设置两种时机去代理指定对象</p>\n<h3 id=\"3-代码结构：\"><a href=\"#3-代码结构：\" class=\"headerlink\" title=\"3 代码结构：\"></a>3 代码结构：</h3><p>标准结构：</p>\n<blockquote>\n<p>var proxy = new Proxy (target, handler);  // target是拦截的目标  handler是拦截行为</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function(target, key, receiver) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>`</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key, receiver)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span>: function(target, key, value, receiver) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting <span class=\"subst\">$&#123;key&#125;</span>`</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, value, receiver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">obj <span class=\"comment\">// 默认是&#123;&#125;    </span></span><br><span class=\"line\">obj.a = <span class=\"number\">1</span> <span class=\"comment\">// setting a</span></span><br><span class=\"line\">obj.a = <span class=\"number\">2</span> <span class=\"comment\">// setting a</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.a) <span class=\"comment\">// getting a</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-要注意的点：\"><a href=\"#4-要注意的点：\" class=\"headerlink\" title=\"4. 要注意的点：\"></a>4. 要注意的点：</h3><ul>\n<li><p>要使proxy起作用，需对proxy的实例 进行操作，而不是针对原目标对象。</p>\n</li>\n<li><p>与原型的应用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function(target, property) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">35</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> _obj = <span class=\"built_in\">Object</span>.create(proxy)</span><br><span class=\"line\">_obj.time <span class=\"comment\">// 35</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// proxy对象是_obj的原型，_obj上没有time这个属性，就顺着原型链找到proxy，proxy上的任何属性都会返回35</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"5-proxy还支持get、set之外的api补充\"><a href=\"#5-proxy还支持get、set之外的api补充\" class=\"headerlink\" title=\"5. proxy还支持get、set之外的api补充\"></a>5. proxy还支持get、set之外的api补充</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> handler = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: function(target, name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name === <span class=\"string\">'prototype'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + name;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  apply: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, thisBinding, args</span>) </span>&#123; <span class=\"comment\">// proxy实例作为函数调用时触发</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> args[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  construct: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, args</span>) </span>&#123; <span class=\"comment\">// proxy作为构造函数时触发</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">value</span>: args[<span class=\"number\">1</span>]&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fproxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;, handler);</span><br><span class=\"line\"></span><br><span class=\"line\">fproxy(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> fproxy(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// &#123;value: 2&#125;</span></span><br><span class=\"line\">fproxy.prototype === <span class=\"built_in\">Object</span>.prototype <span class=\"comment\">// true</span></span><br><span class=\"line\">fproxy.foo === <span class=\"string\">\"Hello, foo\"</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// get 拦截 负数索引</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createArray</span>(<span class=\"params\">...elements</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">     <span class=\"keyword\">get</span>: function(target, property, receiver) &#123; </span><br><span class=\"line\">         <span class=\"keyword\">let</span> index = <span class=\"built_in\">Number</span>(property) <span class=\"comment\">// -1 会作为属性传进来</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">             property = <span class=\"built_in\">String</span>(target.length + index) <span class=\"comment\">// property\\target 是可以修改的 奇怪...</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, property, receiver) <span class=\"comment\">// Reflect is what</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">let</span> target = []</span><br><span class=\"line\"> target.push(...elements)</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr = createArray(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>)</span><br><span class=\"line\">arr[<span class=\"number\">-1</span>] <span class=\"comment\">// 'c'</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-属性需可配置，configuable-和-可写writable，否则proxy实例访问代理这个属性会报错-也是一条可以阻止proxy的法子\"><a href=\"#6-属性需可配置，configuable-和-可写writable，否则proxy实例访问代理这个属性会报错-也是一条可以阻止proxy的法子\" class=\"headerlink\" title=\"6. 属性需可配置，configuable 和 可写writable，否则proxy实例访问代理这个属性会报错 (也是一条可以阻止proxy的法子)\"></a>6. 属性需可配置，configuable 和 可写writable，否则proxy实例访问代理这个属性会报错 (也是一条可以阻止proxy的法子)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = <span class=\"built_in\">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class=\"line\">  foo: &#123;</span><br><span class=\"line\">    value: <span class=\"number\">123</span>,</span><br><span class=\"line\">    writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> handler = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>(target, propKey) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'abc'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\"></span><br><span class=\"line\">proxy.foo</span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: 'get' on proxy: property 'foo' is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected '123' but got 'abc')</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>引申了解：</p>\n<ul>\n<li>元编程的概念</li>\n<li>proxy的get和set，与 Object.defineProperty 相比，有什么区别<ul>\n<li>答：<a href=\"https://juejin.im/post/5be4f7cfe51d453339084530\" target=\"_blank\" rel=\"noopener\">jueim</a> proxy的应用场景更多，但是define的兼容性更好</li>\n<li>答：<a href=\"https://github.com/YvetteLau/Blog/issues/25\" target=\"_blank\" rel=\"noopener\">issue</a></li>\n<li>答：<a href=\"https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf\" target=\"_blank\" rel=\"noopener\">两者实现双向绑定差异</a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>参考文章：<br><a href=\"https://es6.ruanyifeng.com/#docs/proxy\" target=\"_blank\" rel=\"noopener\">阮一峰es6 proxy章节</a><br><a href=\"https://www.infoq.cn/article/es6-in-depth-proxies-and-reflect\" target=\"_blank\" rel=\"noopener\">深入浅出es6系列</a><br><a href=\"https://www.infoq.cn/article/es6-in-depth-proxies-and-reflect\" target=\"_blank\" rel=\"noopener\">segmentFault</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Meta_programming\" target=\"_blank\" rel=\"noopener\">元编程</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>vue</code>源码的render部分，曾用到<code>proxy</code>来代理vue的实例。</p>\n<h3 id=\"1-概念：\"><a href=\"#1-概念：\" class=\"headerlink\" title=\"1 概念：\"></a>1 概念：</h3><p><code>proxy</code> 原意就有代理的意思。它是外界访问对象的一层<code>代理控制</code>，也是对访问的一种<code>改写和过滤</code>。属于一种<code>元编程</code>。</p>\n<h3 id=\"2-作用：\"><a href=\"#2-作用：\" class=\"headerlink\" title=\"2 作用：\"></a>2 作用：</h3><p>可以从获取和设置两种时机去代理指定对象</p>\n<h3 id=\"3-代码结构：\"><a href=\"#3-代码结构：\" class=\"headerlink\" title=\"3 代码结构：\"></a>3 代码结构：</h3><p>标准结构：</p>\n<blockquote>\n<p>var proxy = new Proxy (target, handler);  // target是拦截的目标  handler是拦截行为</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function(target, key, receiver) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>`</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key, receiver)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span>: function(target, key, value, receiver) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting <span class=\"subst\">$&#123;key&#125;</span>`</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, value, receiver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">obj <span class=\"comment\">// 默认是&#123;&#125;    </span></span><br><span class=\"line\">obj.a = <span class=\"number\">1</span> <span class=\"comment\">// setting a</span></span><br><span class=\"line\">obj.a = <span class=\"number\">2</span> <span class=\"comment\">// setting a</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.a) <span class=\"comment\">// getting a</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-要注意的点：\"><a href=\"#4-要注意的点：\" class=\"headerlink\" title=\"4. 要注意的点：\"></a>4. 要注意的点：</h3><ul>\n<li><p>要使proxy起作用，需对proxy的实例 进行操作，而不是针对原目标对象。</p>\n</li>\n<li><p>与原型的应用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function(target, property) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">35</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> _obj = <span class=\"built_in\">Object</span>.create(proxy)</span><br><span class=\"line\">_obj.time <span class=\"comment\">// 35</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// proxy对象是_obj的原型，_obj上没有time这个属性，就顺着原型链找到proxy，proxy上的任何属性都会返回35</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"5-proxy还支持get、set之外的api补充\"><a href=\"#5-proxy还支持get、set之外的api补充\" class=\"headerlink\" title=\"5. proxy还支持get、set之外的api补充\"></a>5. proxy还支持get、set之外的api补充</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> handler = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: function(target, name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name === <span class=\"string\">'prototype'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Hello, '</span> + name;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  apply: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, thisBinding, args</span>) </span>&#123; <span class=\"comment\">// proxy实例作为函数调用时触发</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> args[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  construct: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target, args</span>) </span>&#123; <span class=\"comment\">// proxy作为构造函数时触发</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">value</span>: args[<span class=\"number\">1</span>]&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fproxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;, handler);</span><br><span class=\"line\"></span><br><span class=\"line\">fproxy(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> fproxy(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// &#123;value: 2&#125;</span></span><br><span class=\"line\">fproxy.prototype === <span class=\"built_in\">Object</span>.prototype <span class=\"comment\">// true</span></span><br><span class=\"line\">fproxy.foo === <span class=\"string\">\"Hello, foo\"</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// get 拦截 负数索引</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createArray</span>(<span class=\"params\">...elements</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">     <span class=\"keyword\">get</span>: function(target, property, receiver) &#123; </span><br><span class=\"line\">         <span class=\"keyword\">let</span> index = <span class=\"built_in\">Number</span>(property) <span class=\"comment\">// -1 会作为属性传进来</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">             property = <span class=\"built_in\">String</span>(target.length + index) <span class=\"comment\">// property\\target 是可以修改的 奇怪...</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, property, receiver) <span class=\"comment\">// Reflect is what</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">let</span> target = []</span><br><span class=\"line\"> target.push(...elements)</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr = createArray(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>)</span><br><span class=\"line\">arr[<span class=\"number\">-1</span>] <span class=\"comment\">// 'c'</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-属性需可配置，configuable-和-可写writable，否则proxy实例访问代理这个属性会报错-也是一条可以阻止proxy的法子\"><a href=\"#6-属性需可配置，configuable-和-可写writable，否则proxy实例访问代理这个属性会报错-也是一条可以阻止proxy的法子\" class=\"headerlink\" title=\"6. 属性需可配置，configuable 和 可写writable，否则proxy实例访问代理这个属性会报错 (也是一条可以阻止proxy的法子)\"></a>6. 属性需可配置，configuable 和 可写writable，否则proxy实例访问代理这个属性会报错 (也是一条可以阻止proxy的法子)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = <span class=\"built_in\">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class=\"line\">  foo: &#123;</span><br><span class=\"line\">    value: <span class=\"number\">123</span>,</span><br><span class=\"line\">    writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    configurable: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> handler = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>(target, propKey) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'abc'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\"></span><br><span class=\"line\">proxy.foo</span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: 'get' on proxy: property 'foo' is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected '123' but got 'abc')</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>引申了解：</p>\n<ul>\n<li>元编程的概念</li>\n<li>proxy的get和set，与 Object.defineProperty 相比，有什么区别<ul>\n<li>答：<a href=\"https://juejin.im/post/5be4f7cfe51d453339084530\" target=\"_blank\" rel=\"noopener\">jueim</a> proxy的应用场景更多，但是define的兼容性更好</li>\n<li>答：<a href=\"https://github.com/YvetteLau/Blog/issues/25\" target=\"_blank\" rel=\"noopener\">issue</a></li>\n<li>答：<a href=\"https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf\" target=\"_blank\" rel=\"noopener\">两者实现双向绑定差异</a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>参考文章：<br><a href=\"https://es6.ruanyifeng.com/#docs/proxy\" target=\"_blank\" rel=\"noopener\">阮一峰es6 proxy章节</a><br><a href=\"https://www.infoq.cn/article/es6-in-depth-proxies-and-reflect\" target=\"_blank\" rel=\"noopener\">深入浅出es6系列</a><br><a href=\"https://www.infoq.cn/article/es6-in-depth-proxies-and-reflect\" target=\"_blank\" rel=\"noopener\">segmentFault</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Meta_programming\" target=\"_blank\" rel=\"noopener\">元编程</a></p>\n"},{"title":"vue源码分析","date":"2020-04-26T17:27:25.000Z","_content":"\n网址：\n[勾三股四](https://jiongks.name/blog/vue-code-review/)\n[授之以渔](https://github.com/HcySunYang/vue-design)\n[vue大概讲解](https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/update.html#%E6%80%BB%E7%BB%93)\n[染陌电子书](https://github.com/answershuto/learnVue)\n[patch原理](https://www.cnblogs.com/QH-Jimmy/p/7210363.html)\n[victual dom diff](https://github.com/aooy/blog/issues/2)\n[书栈网](https://www.bookstack.cn/books/5865c0921b69e6006b3145a1)\n[vue中的AST](http://caibaojian.com/vue-design/art/81vue-lexical-analysis.html)\n\n","source":"_posts/vue源码分析.md","raw":"---\ntitle: vue源码分析\ndate: 2020-04-27 01:27:25\ntags: vue\n---\n\n网址：\n[勾三股四](https://jiongks.name/blog/vue-code-review/)\n[授之以渔](https://github.com/HcySunYang/vue-design)\n[vue大概讲解](https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/update.html#%E6%80%BB%E7%BB%93)\n[染陌电子书](https://github.com/answershuto/learnVue)\n[patch原理](https://www.cnblogs.com/QH-Jimmy/p/7210363.html)\n[victual dom diff](https://github.com/aooy/blog/issues/2)\n[书栈网](https://www.bookstack.cn/books/5865c0921b69e6006b3145a1)\n[vue中的AST](http://caibaojian.com/vue-design/art/81vue-lexical-analysis.html)\n\n","slug":"vue源码分析","published":1,"updated":"2020-07-06T05:10:49.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr9w000nz5o8238o6h9g","content":"<p>网址：<br><a href=\"https://jiongks.name/blog/vue-code-review/\" target=\"_blank\" rel=\"noopener\">勾三股四</a><br><a href=\"https://github.com/HcySunYang/vue-design\" target=\"_blank\" rel=\"noopener\">授之以渔</a><br><a href=\"https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/update.html#%E6%80%BB%E7%BB%93\" target=\"_blank\" rel=\"noopener\">vue大概讲解</a><br><a href=\"https://github.com/answershuto/learnVue\" target=\"_blank\" rel=\"noopener\">染陌电子书</a><br><a href=\"https://www.cnblogs.com/QH-Jimmy/p/7210363.html\" target=\"_blank\" rel=\"noopener\">patch原理</a><br><a href=\"https://github.com/aooy/blog/issues/2\" target=\"_blank\" rel=\"noopener\">victual dom diff</a><br><a href=\"https://www.bookstack.cn/books/5865c0921b69e6006b3145a1\" target=\"_blank\" rel=\"noopener\">书栈网</a><br><a href=\"http://caibaojian.com/vue-design/art/81vue-lexical-analysis.html\" target=\"_blank\" rel=\"noopener\">vue中的AST</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>网址：<br><a href=\"https://jiongks.name/blog/vue-code-review/\" target=\"_blank\" rel=\"noopener\">勾三股四</a><br><a href=\"https://github.com/HcySunYang/vue-design\" target=\"_blank\" rel=\"noopener\">授之以渔</a><br><a href=\"https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/update.html#%E6%80%BB%E7%BB%93\" target=\"_blank\" rel=\"noopener\">vue大概讲解</a><br><a href=\"https://github.com/answershuto/learnVue\" target=\"_blank\" rel=\"noopener\">染陌电子书</a><br><a href=\"https://www.cnblogs.com/QH-Jimmy/p/7210363.html\" target=\"_blank\" rel=\"noopener\">patch原理</a><br><a href=\"https://github.com/aooy/blog/issues/2\" target=\"_blank\" rel=\"noopener\">victual dom diff</a><br><a href=\"https://www.bookstack.cn/books/5865c0921b69e6006b3145a1\" target=\"_blank\" rel=\"noopener\">书栈网</a><br><a href=\"http://caibaojian.com/vue-design/art/81vue-lexical-analysis.html\" target=\"_blank\" rel=\"noopener\">vue中的AST</a></p>\n"},{"title":"test加密","date":"2020-07-03T09:54:10.000Z","password":"123","abstract":"该篇文章博主不想让其他人看见哟~","message":"您好, 这里需要密码😊","wrong_pass_message":"抱歉, 这个密码看着不太对, 请再试试.","_content":"\ntest \ntest\ntest","source":"_posts/test.md","raw":"---\ntitle: test加密\ndate: 2020-07-03 17:54:10\npassword: '123'\nabstract: \"该篇文章博主不想让其他人看见哟~\"\nmessage: \"您好, 这里需要密码😊\"\nwrong_pass_message: \"抱歉, 这个密码看着不太对, 请再试试.\"\n---\n\ntest \ntest\ntest","slug":"test","published":1,"updated":"2020-07-23T10:52:38.649Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr9x000qz5o8hv8fanhn","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"抱歉, 这个密码看着不太对, 请再试试.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">您好, 这里需要密码😊</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"2178b67a31e04e98a6d5640f8120c88e6daf169d966b5834e802f4a9199af9a7\">f1589d5d3bccaa9f6c29aaaf98e142b8d01af2777bb28c6d6efc96edc55df4ac</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"该篇文章博主不想让其他人看见哟~","more":"该篇文章博主不想让其他人看见哟~","origin":"<p>test<br>test<br>test</p>\n","encrypt":true},{"title":"upload之初探","date":"2018-01-04T15:03:21.000Z","_content":"\n\n#### 来由 \n\n   > 产品有做能多选的上传这个功能，开始倒腾。事实也踩了不少坑。现就开始梳理今天的思路。\n\n\n#### 框架选取\n\n * 微信上传接口:\n  先上图 : 我们可以看到的是，它的接口 chooseImage 确是有这番作用。直接把朋友圈发照片的流程给调出来。可以预览，可以原图，很全面了。然而，它需要传到微信服务器走一遭，这是最让人难受的\n\n > 弃用原因：本身我项目的图片存储是放在阿里云oss里，如今还得再经过微信服务器上传下载，就把这事搞麻烦了...\n\n<img src='/upload/1.png' style=\"width:50%;height:60%;\"><img src='/upload/2.png' style=\"width:50%;height:60%;\">\n\n* eleme-UI   \n  还是先上图：它也是极好的，从UI美观角度看，或是它的功能性，都很接近理想了。可惜，它的上传只有一次，就是它的请求服务器Url只有一个，而且是在vue的html里渲染，这就更不好改了\n  >  弃用原因: 还是因为oss里的判断，有引进了两次请求，第一次是请求 下次请求要用上的地址和id 第二次则是真正和oss请求上传图。\n  <img src='/upload/3.png' style=\"width:50%;height:60%;\">\n  \n* plupload\n  还在研究中...是后台同事推荐的一个插件，据说oss就是官方支持这个，大喜之余就看看它文档。\n  \n  #### 嗯。加油，明天继续倒腾！^_^","source":"_posts/upload.md","raw":"---\ntitle: upload之初探\ndate: 2018-01-04 23:03:21\ntags: upload\n---\n\n\n#### 来由 \n\n   > 产品有做能多选的上传这个功能，开始倒腾。事实也踩了不少坑。现就开始梳理今天的思路。\n\n\n#### 框架选取\n\n * 微信上传接口:\n  先上图 : 我们可以看到的是，它的接口 chooseImage 确是有这番作用。直接把朋友圈发照片的流程给调出来。可以预览，可以原图，很全面了。然而，它需要传到微信服务器走一遭，这是最让人难受的\n\n > 弃用原因：本身我项目的图片存储是放在阿里云oss里，如今还得再经过微信服务器上传下载，就把这事搞麻烦了...\n\n<img src='/upload/1.png' style=\"width:50%;height:60%;\"><img src='/upload/2.png' style=\"width:50%;height:60%;\">\n\n* eleme-UI   \n  还是先上图：它也是极好的，从UI美观角度看，或是它的功能性，都很接近理想了。可惜，它的上传只有一次，就是它的请求服务器Url只有一个，而且是在vue的html里渲染，这就更不好改了\n  >  弃用原因: 还是因为oss里的判断，有引进了两次请求，第一次是请求 下次请求要用上的地址和id 第二次则是真正和oss请求上传图。\n  <img src='/upload/3.png' style=\"width:50%;height:60%;\">\n  \n* plupload\n  还在研究中...是后台同事推荐的一个插件，据说oss就是官方支持这个，大喜之余就看看它文档。\n  \n  #### 嗯。加油，明天继续倒腾！^_^","slug":"upload","published":1,"updated":"2018-01-11T12:36:04.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr9y000rz5o81fqxfoca","content":"<h4 id=\"来由\"><a href=\"#来由\" class=\"headerlink\" title=\"来由\"></a>来由</h4><blockquote>\n<p>产品有做能多选的上传这个功能，开始倒腾。事实也踩了不少坑。现就开始梳理今天的思路。</p>\n</blockquote>\n<h4 id=\"框架选取\"><a href=\"#框架选取\" class=\"headerlink\" title=\"框架选取\"></a>框架选取</h4><ul>\n<li><p>微信上传接口:<br>先上图 : 我们可以看到的是，它的接口 chooseImage 确是有这番作用。直接把朋友圈发照片的流程给调出来。可以预览，可以原图，很全面了。然而，它需要传到微信服务器走一遭，这是最让人难受的</p>\n<blockquote>\n<p>弃用原因：本身我项目的图片存储是放在阿里云oss里，如今还得再经过微信服务器上传下载，就把这事搞麻烦了…</p>\n</blockquote>\n</li>\n</ul>\n<p><img src=\"/2018/01/04/upload/1.png\" style=\"width:50%;height:60%;\"><img src=\"/2018/01/04/upload/2.png\" style=\"width:50%;height:60%;\"></p>\n<ul>\n<li><p>eleme-UI<br>还是先上图：它也是极好的，从UI美观角度看，或是它的功能性，都很接近理想了。可惜，它的上传只有一次，就是它的请求服务器Url只有一个，而且是在vue的html里渲染，这就更不好改了</p>\n<blockquote>\n<p> 弃用原因: 还是因为oss里的判断，有引进了两次请求，第一次是请求 下次请求要用上的地址和id 第二次则是真正和oss请求上传图。</p>\n<img src=\"/2018/01/04/upload/3.png\" style=\"width:50%;height:60%;\">\n</blockquote>\n</li>\n<li><p>plupload<br>还在研究中…是后台同事推荐的一个插件，据说oss就是官方支持这个，大喜之余就看看它文档。</p>\n<h4 id=\"嗯。加油，明天继续倒腾！\"><a href=\"#嗯。加油，明天继续倒腾！\" class=\"headerlink\" title=\"嗯。加油，明天继续倒腾！^_^\"></a>嗯。加油，明天继续倒腾！^_^</h4></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"来由\"><a href=\"#来由\" class=\"headerlink\" title=\"来由\"></a>来由</h4><blockquote>\n<p>产品有做能多选的上传这个功能，开始倒腾。事实也踩了不少坑。现就开始梳理今天的思路。</p>\n</blockquote>\n<h4 id=\"框架选取\"><a href=\"#框架选取\" class=\"headerlink\" title=\"框架选取\"></a>框架选取</h4><ul>\n<li><p>微信上传接口:<br>先上图 : 我们可以看到的是，它的接口 chooseImage 确是有这番作用。直接把朋友圈发照片的流程给调出来。可以预览，可以原图，很全面了。然而，它需要传到微信服务器走一遭，这是最让人难受的</p>\n<blockquote>\n<p>弃用原因：本身我项目的图片存储是放在阿里云oss里，如今还得再经过微信服务器上传下载，就把这事搞麻烦了…</p>\n</blockquote>\n</li>\n</ul>\n<p><img src=\"/2018/01/04/upload/1.png\" style=\"width:50%;height:60%;\"><img src=\"/2018/01/04/upload/2.png\" style=\"width:50%;height:60%;\"></p>\n<ul>\n<li><p>eleme-UI<br>还是先上图：它也是极好的，从UI美观角度看，或是它的功能性，都很接近理想了。可惜，它的上传只有一次，就是它的请求服务器Url只有一个，而且是在vue的html里渲染，这就更不好改了</p>\n<blockquote>\n<p> 弃用原因: 还是因为oss里的判断，有引进了两次请求，第一次是请求 下次请求要用上的地址和id 第二次则是真正和oss请求上传图。</p>\n<img src=\"/2018/01/04/upload/3.png\" style=\"width:50%;height:60%;\">\n</blockquote>\n</li>\n<li><p>plupload<br>还在研究中…是后台同事推荐的一个插件，据说oss就是官方支持这个，大喜之余就看看它文档。</p>\n<h4 id=\"嗯。加油，明天继续倒腾！\"><a href=\"#嗯。加油，明天继续倒腾！\" class=\"headerlink\" title=\"嗯。加油，明天继续倒腾！^_^\"></a>嗯。加油，明天继续倒腾！^_^</h4></li>\n</ul>\n"},{"title":"偏函数","date":"2020-07-02T13:15:36.000Z","_content":"\n我的理解是，传入并缓存固定的参数，返回指定的函数。\n而且是一种特别的柯里化。\n柯里化是一参变多参。\n偏函数是前面的参数会导致后来return的函数不一样。书面点讲，就是指定部分参数，来产生一个新的定制函数。\n\n\n\n参考：\n[blog](https://blog.csdn.net/qq_15241071/article/details/80036346)","source":"_posts/偏函数.md","raw":"---\ntitle: 偏函数\ndate: 2020-07-02 21:15:36\ntags: JS\n---\n\n我的理解是，传入并缓存固定的参数，返回指定的函数。\n而且是一种特别的柯里化。\n柯里化是一参变多参。\n偏函数是前面的参数会导致后来return的函数不一样。书面点讲，就是指定部分参数，来产生一个新的定制函数。\n\n\n\n参考：\n[blog](https://blog.csdn.net/qq_15241071/article/details/80036346)","slug":"偏函数","published":1,"updated":"2020-07-02T13:22:28.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmr9z000tz5o8cgxc1unj","content":"<p>我的理解是，传入并缓存固定的参数，返回指定的函数。<br>而且是一种特别的柯里化。<br>柯里化是一参变多参。<br>偏函数是前面的参数会导致后来return的函数不一样。书面点讲，就是指定部分参数，来产生一个新的定制函数。</p>\n<p>参考：<br><a href=\"https://blog.csdn.net/qq_15241071/article/details/80036346\" target=\"_blank\" rel=\"noopener\">blog</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>我的理解是，传入并缓存固定的参数，返回指定的函数。<br>而且是一种特别的柯里化。<br>柯里化是一参变多参。<br>偏函数是前面的参数会导致后来return的函数不一样。书面点讲，就是指定部分参数，来产生一个新的定制函数。</p>\n<p>参考：<br><a href=\"https://blog.csdn.net/qq_15241071/article/details/80036346\" target=\"_blank\" rel=\"noopener\">blog</a></p>\n"},{"title":"克隆对象&&数组（一）","date":"2020-07-13T07:12:00.000Z","_content":"\n#### 1 从数据类型说起\n`JavaScript`的数据类型：\n+ 基本类型： `Null，undefined，number，string，Boolean` 存放在`栈内存`的简单数据，可以直接访问\n+ 引用类型：`Array，Object，Function` 存放在`堆内存`，存放的是该对象的`地址指针`\n\n#### 2 深浅拷贝由来\n引用类型的数据，因为指向指针的问题，`浅拷贝`就会导致指向同一处，那么修改拷贝的任一者，都会`导致全部都改`了。\n这时候，就需要`深拷贝`，它可以开辟新的内存地址，让拷贝的对象们指向不同，这样就`不会互相影响`了。\n\n#### 3 浅拷贝CODE\n`浅拷贝`就是拷贝`第一层的基本类型值`，以及`第一层的引用类型地址`。\n（1）for...in...遍历属性\n```javascript\nfunction shallowClone(copyObj) {\n  var obj = {};\n  for ( var i in copyObj) {\n    obj[i] = copyObj[i];\n  }\n  return obj;\n}\nvar x = {\n  a: 1,\n  b: { f: { g: 1 } },\n  c: [ 1, 2, 3 ]\n};\nvar y = shallowClone(x);\nconsole.log(y.b.f === x.b.f);     // true\n```\n（2）Object.assign()\n将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。只遍历一层\n基础用法\n```javascript\nconst target = { a: 1, b: 2 };\nconst source = { b: 4, c: 5 };\n\nconst returnedTarget = Object.assign(target, source);\n\nconsole.log(target);\n// expected output: Object { a: 1, b: 4, c: 5 }\n\nconsole.log(returnedTarget);\n// expected output: Object { a: 1, b: 4, c: 5 }\n```\n\n复制对象（浅）\n```javascript\n    const obj = { a: 1 };\n    const copy = Object.assign({}, obj);\n    console.log(copy); // { a: 1 }\n```\n\n(3) `Array`的`slice&concat`方法\n它们虽然在demo里看起来像深，其实也是浅拷贝\n```javascript\nvar array = [1,2,3]; \nvar array_shallow = array; \nvar array_concat = array.concat(); \nvar array_slice = array.slice(0); \nconsole.log(array === array_shallow); //true \nconsole.log(array === array_slice); //false，“看起来”像深拷贝\nconsole.log(array === array_concat); //false，“看起来”像深拷贝\n```\n\n(4) 展开语法`...`\n对数组和对象的浅拷贝，类似Object.assign的功能。只能用于可迭代对象。\n```javascript\n// 数组\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\narr1 = [...arr2, ...arr1]; // arr1 现在为 [3, 4, 5, 0, 1, 2]\n\n// 对象\nvar obj1 = { foo: 'bar', x: 42 };\nvar obj2 = { foo: 'baz', y: 13 };\nvar clonedObj = { ...obj1 };\n// 克隆后的对象: { foo: \"bar\", x: 42 }\nvar mergedObj = { ...obj1, ...obj2 };\n// 合并后的对象: { foo: \"baz\", x: 42, y: 13 }\n```\n","source":"_posts/克隆对象&&数组（一）.md","raw":"---\n   title: 克隆对象&&数组（一）\n   date: 2020-07-13 15:12:00\n   tags: JS 拷贝\n---\n\n#### 1 从数据类型说起\n`JavaScript`的数据类型：\n+ 基本类型： `Null，undefined，number，string，Boolean` 存放在`栈内存`的简单数据，可以直接访问\n+ 引用类型：`Array，Object，Function` 存放在`堆内存`，存放的是该对象的`地址指针`\n\n#### 2 深浅拷贝由来\n引用类型的数据，因为指向指针的问题，`浅拷贝`就会导致指向同一处，那么修改拷贝的任一者，都会`导致全部都改`了。\n这时候，就需要`深拷贝`，它可以开辟新的内存地址，让拷贝的对象们指向不同，这样就`不会互相影响`了。\n\n#### 3 浅拷贝CODE\n`浅拷贝`就是拷贝`第一层的基本类型值`，以及`第一层的引用类型地址`。\n（1）for...in...遍历属性\n```javascript\nfunction shallowClone(copyObj) {\n  var obj = {};\n  for ( var i in copyObj) {\n    obj[i] = copyObj[i];\n  }\n  return obj;\n}\nvar x = {\n  a: 1,\n  b: { f: { g: 1 } },\n  c: [ 1, 2, 3 ]\n};\nvar y = shallowClone(x);\nconsole.log(y.b.f === x.b.f);     // true\n```\n（2）Object.assign()\n将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。只遍历一层\n基础用法\n```javascript\nconst target = { a: 1, b: 2 };\nconst source = { b: 4, c: 5 };\n\nconst returnedTarget = Object.assign(target, source);\n\nconsole.log(target);\n// expected output: Object { a: 1, b: 4, c: 5 }\n\nconsole.log(returnedTarget);\n// expected output: Object { a: 1, b: 4, c: 5 }\n```\n\n复制对象（浅）\n```javascript\n    const obj = { a: 1 };\n    const copy = Object.assign({}, obj);\n    console.log(copy); // { a: 1 }\n```\n\n(3) `Array`的`slice&concat`方法\n它们虽然在demo里看起来像深，其实也是浅拷贝\n```javascript\nvar array = [1,2,3]; \nvar array_shallow = array; \nvar array_concat = array.concat(); \nvar array_slice = array.slice(0); \nconsole.log(array === array_shallow); //true \nconsole.log(array === array_slice); //false，“看起来”像深拷贝\nconsole.log(array === array_concat); //false，“看起来”像深拷贝\n```\n\n(4) 展开语法`...`\n对数组和对象的浅拷贝，类似Object.assign的功能。只能用于可迭代对象。\n```javascript\n// 数组\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\narr1 = [...arr2, ...arr1]; // arr1 现在为 [3, 4, 5, 0, 1, 2]\n\n// 对象\nvar obj1 = { foo: 'bar', x: 42 };\nvar obj2 = { foo: 'baz', y: 13 };\nvar clonedObj = { ...obj1 };\n// 克隆后的对象: { foo: \"bar\", x: 42 }\nvar mergedObj = { ...obj1, ...obj2 };\n// 合并后的对象: { foo: \"baz\", x: 42, y: 13 }\n```\n","slug":"克隆对象&&数组（一）","published":1,"updated":"2020-07-14T11:33:11.129Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmra0000vz5o87h727ops","content":"<h4 id=\"1-从数据类型说起\"><a href=\"#1-从数据类型说起\" class=\"headerlink\" title=\"1 从数据类型说起\"></a>1 从数据类型说起</h4><p><code>JavaScript</code>的数据类型：</p>\n<ul>\n<li>基本类型： <code>Null，undefined，number，string，Boolean</code> 存放在<code>栈内存</code>的简单数据，可以直接访问</li>\n<li>引用类型：<code>Array，Object，Function</code> 存放在<code>堆内存</code>，存放的是该对象的<code>地址指针</code></li>\n</ul>\n<h4 id=\"2-深浅拷贝由来\"><a href=\"#2-深浅拷贝由来\" class=\"headerlink\" title=\"2 深浅拷贝由来\"></a>2 深浅拷贝由来</h4><p>引用类型的数据，因为指向指针的问题，<code>浅拷贝</code>就会导致指向同一处，那么修改拷贝的任一者，都会<code>导致全部都改</code>了。<br>这时候，就需要<code>深拷贝</code>，它可以开辟新的内存地址，让拷贝的对象们指向不同，这样就<code>不会互相影响</code>了。</p>\n<h4 id=\"3-浅拷贝CODE\"><a href=\"#3-浅拷贝CODE\" class=\"headerlink\" title=\"3 浅拷贝CODE\"></a>3 浅拷贝CODE</h4><p><code>浅拷贝</code>就是拷贝<code>第一层的基本类型值</code>，以及<code>第一层的引用类型地址</code>。<br>（1）for…in…遍历属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shallowClone</span>(<span class=\"params\">copyObj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( <span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> copyObj) &#123;</span><br><span class=\"line\">    obj[i] = copyObj[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> x = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: &#123; <span class=\"attr\">f</span>: &#123; <span class=\"attr\">g</span>: <span class=\"number\">1</span> &#125; &#125;,</span><br><span class=\"line\">  c: [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> ]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> y = shallowClone(x);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(y.b.f === x.b.f);     <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>（2）Object.assign()<br>将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。只遍历一层<br>基础用法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source = &#123; <span class=\"attr\">b</span>: <span class=\"number\">4</span>, <span class=\"attr\">c</span>: <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> returnedTarget = <span class=\"built_in\">Object</span>.assign(target, source);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target);</span><br><span class=\"line\"><span class=\"comment\">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(returnedTarget);</span><br><span class=\"line\"><span class=\"comment\">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>复制对象（浅）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> copy = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(copy); <span class=\"comment\">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>(3) <code>Array</code>的<code>slice&amp;concat</code>方法<br>它们虽然在demo里看起来像深，其实也是浅拷贝</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]; </span><br><span class=\"line\"><span class=\"keyword\">var</span> array_shallow = array; </span><br><span class=\"line\"><span class=\"keyword\">var</span> array_concat = array.concat(); </span><br><span class=\"line\"><span class=\"keyword\">var</span> array_slice = array.slice(<span class=\"number\">0</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array === array_shallow); <span class=\"comment\">//true </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array === array_slice); <span class=\"comment\">//false，“看起来”像深拷贝</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array === array_concat); <span class=\"comment\">//false，“看起来”像深拷贝</span></span><br></pre></td></tr></table></figure>\n\n<p>(4) 展开语法<code>...</code><br>对数组和对象的浅拷贝，类似Object.assign的功能。只能用于可迭代对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">arr1 = [...arr2, ...arr1]; <span class=\"comment\">// arr1 现在为 [3, 4, 5, 0, 1, 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>, <span class=\"attr\">x</span>: <span class=\"number\">42</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'baz'</span>, <span class=\"attr\">y</span>: <span class=\"number\">13</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> clonedObj = &#123; ...obj1 &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 克隆后的对象: &#123; foo: \"bar\", x: 42 &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 合并后的对象: &#123; foo: \"baz\", x: 42, y: 13 &#125;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1-从数据类型说起\"><a href=\"#1-从数据类型说起\" class=\"headerlink\" title=\"1 从数据类型说起\"></a>1 从数据类型说起</h4><p><code>JavaScript</code>的数据类型：</p>\n<ul>\n<li>基本类型： <code>Null，undefined，number，string，Boolean</code> 存放在<code>栈内存</code>的简单数据，可以直接访问</li>\n<li>引用类型：<code>Array，Object，Function</code> 存放在<code>堆内存</code>，存放的是该对象的<code>地址指针</code></li>\n</ul>\n<h4 id=\"2-深浅拷贝由来\"><a href=\"#2-深浅拷贝由来\" class=\"headerlink\" title=\"2 深浅拷贝由来\"></a>2 深浅拷贝由来</h4><p>引用类型的数据，因为指向指针的问题，<code>浅拷贝</code>就会导致指向同一处，那么修改拷贝的任一者，都会<code>导致全部都改</code>了。<br>这时候，就需要<code>深拷贝</code>，它可以开辟新的内存地址，让拷贝的对象们指向不同，这样就<code>不会互相影响</code>了。</p>\n<h4 id=\"3-浅拷贝CODE\"><a href=\"#3-浅拷贝CODE\" class=\"headerlink\" title=\"3 浅拷贝CODE\"></a>3 浅拷贝CODE</h4><p><code>浅拷贝</code>就是拷贝<code>第一层的基本类型值</code>，以及<code>第一层的引用类型地址</code>。<br>（1）for…in…遍历属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shallowClone</span>(<span class=\"params\">copyObj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( <span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> copyObj) &#123;</span><br><span class=\"line\">    obj[i] = copyObj[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> x = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">1</span>,</span><br><span class=\"line\">  b: &#123; <span class=\"attr\">f</span>: &#123; <span class=\"attr\">g</span>: <span class=\"number\">1</span> &#125; &#125;,</span><br><span class=\"line\">  c: [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> ]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> y = shallowClone(x);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(y.b.f === x.b.f);     <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>（2）Object.assign()<br>将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。只遍历一层<br>基础用法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source = &#123; <span class=\"attr\">b</span>: <span class=\"number\">4</span>, <span class=\"attr\">c</span>: <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> returnedTarget = <span class=\"built_in\">Object</span>.assign(target, source);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target);</span><br><span class=\"line\"><span class=\"comment\">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(returnedTarget);</span><br><span class=\"line\"><span class=\"comment\">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>复制对象（浅）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> copy = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(copy); <span class=\"comment\">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>(3) <code>Array</code>的<code>slice&amp;concat</code>方法<br>它们虽然在demo里看起来像深，其实也是浅拷贝</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]; </span><br><span class=\"line\"><span class=\"keyword\">var</span> array_shallow = array; </span><br><span class=\"line\"><span class=\"keyword\">var</span> array_concat = array.concat(); </span><br><span class=\"line\"><span class=\"keyword\">var</span> array_slice = array.slice(<span class=\"number\">0</span>); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array === array_shallow); <span class=\"comment\">//true </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array === array_slice); <span class=\"comment\">//false，“看起来”像深拷贝</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array === array_concat); <span class=\"comment\">//false，“看起来”像深拷贝</span></span><br></pre></td></tr></table></figure>\n\n<p>(4) 展开语法<code>...</code><br>对数组和对象的浅拷贝，类似Object.assign的功能。只能用于可迭代对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">arr1 = [...arr2, ...arr1]; <span class=\"comment\">// arr1 现在为 [3, 4, 5, 0, 1, 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'bar'</span>, <span class=\"attr\">x</span>: <span class=\"number\">42</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">'baz'</span>, <span class=\"attr\">y</span>: <span class=\"number\">13</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> clonedObj = &#123; ...obj1 &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 克隆后的对象: &#123; foo: \"bar\", x: 42 &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 合并后的对象: &#123; foo: \"baz\", x: 42, y: 13 &#125;</span></span><br></pre></td></tr></table></figure>\n"},{"title":"webpack的后花园","date":"2019-12-11T09:17:00.000Z","_content":"\n### 1.webpack底层\n    它是一个打包工具。\n    webpack本身，在不借助loader的情况下，只会打包js。\n    \n    （引用）webpack处理应用程序时，会递归的构建一个依赖关系图，其中包括应用程序需要的每个模块，然后把所有模块打包成一个或多个bundle。\n### 2.几个核心概念\n+ 入口\n+ 出口\n    - 入口和出口很好理解，入口就是打包谁，出口就是要输出的文件。\n     entry:\n     output:{ path, filename }\n+ loader\n    - 帮助webpack识别非js文件，包括css，图片等。\n    - 示例：\n        test: 作用等同于正则里面的匹配\n        use: 使用loader\n    ```javascript\n        rules: [\n                {\n                    test: /\\.js$/,\n                    use: [\n                        'babel-loader',\n                        {\n                            loader: 'eslint-loader',\n                            options: {\n                                emitWarning: true,\n                                emitError: true,\n                                failOnError: true\n                            }\n                        },\n                    ],\n                    exclude: /node_modules/\n                },\n                {\n                    test: /\\.css$/, use: [\"style-loader\",\"css-loader\"]\n                },\n                {\n                    test: /\\.(png|jpg)$/,\n                    loader: 'url-loader?limit=8192'\n                },\n                {\n                    test: /\\.vue$/,\n                    use:[\n                        {\n                            loader: 'vue-loader',\n                            options: {\n                                cssSourceMap:false,\n                                transformToRequire:{},\n                            },\n                        },\n                        {\n                            loader: 'eslint-loader',\n                            options: {\n                                emitWarning: true,\n                                emitError: true,\n                                failOnError: true,\n\n                            }\n                        },\n                    ],\n                    exclude: /node_modules/\n                },\n            ]\n    ```\n+ plugins\n我还没认真弄懂plugins，它好像有很多好用的功能。比如压缩js或者生成好的静态资源增加版本号。待研究 ***@todo***\n--- \n常见问题：\n1、webpack打包原理？\n2、loader，plugins分别是？\n3、热更新原理是？\n4、webpack性能优化的方法？\n\n--- \n+ webpack的打包原理：(树状依赖)\n    - 利用babel完成代码转换,并生成单个文件的依赖.\n    - 从入口开始递归分析，并生成依赖图谱\n    - 将各个引用模块打包为一个`立即执行`函数\n    - 将最终的bundle文件写入bundle.js中\n\n+ loader其实就是一个`Node.js` 模块，这个模块需要导出一个函数\n\n\n\n\n\n\n\n    ","source":"_posts/webpack.md","raw":"---\ntitle: webpack的后花园\ndate: 2019-12-11 17:17:00\ntags: 工具 webpack\n---\n\n### 1.webpack底层\n    它是一个打包工具。\n    webpack本身，在不借助loader的情况下，只会打包js。\n    \n    （引用）webpack处理应用程序时，会递归的构建一个依赖关系图，其中包括应用程序需要的每个模块，然后把所有模块打包成一个或多个bundle。\n### 2.几个核心概念\n+ 入口\n+ 出口\n    - 入口和出口很好理解，入口就是打包谁，出口就是要输出的文件。\n     entry:\n     output:{ path, filename }\n+ loader\n    - 帮助webpack识别非js文件，包括css，图片等。\n    - 示例：\n        test: 作用等同于正则里面的匹配\n        use: 使用loader\n    ```javascript\n        rules: [\n                {\n                    test: /\\.js$/,\n                    use: [\n                        'babel-loader',\n                        {\n                            loader: 'eslint-loader',\n                            options: {\n                                emitWarning: true,\n                                emitError: true,\n                                failOnError: true\n                            }\n                        },\n                    ],\n                    exclude: /node_modules/\n                },\n                {\n                    test: /\\.css$/, use: [\"style-loader\",\"css-loader\"]\n                },\n                {\n                    test: /\\.(png|jpg)$/,\n                    loader: 'url-loader?limit=8192'\n                },\n                {\n                    test: /\\.vue$/,\n                    use:[\n                        {\n                            loader: 'vue-loader',\n                            options: {\n                                cssSourceMap:false,\n                                transformToRequire:{},\n                            },\n                        },\n                        {\n                            loader: 'eslint-loader',\n                            options: {\n                                emitWarning: true,\n                                emitError: true,\n                                failOnError: true,\n\n                            }\n                        },\n                    ],\n                    exclude: /node_modules/\n                },\n            ]\n    ```\n+ plugins\n我还没认真弄懂plugins，它好像有很多好用的功能。比如压缩js或者生成好的静态资源增加版本号。待研究 ***@todo***\n--- \n常见问题：\n1、webpack打包原理？\n2、loader，plugins分别是？\n3、热更新原理是？\n4、webpack性能优化的方法？\n\n--- \n+ webpack的打包原理：(树状依赖)\n    - 利用babel完成代码转换,并生成单个文件的依赖.\n    - 从入口开始递归分析，并生成依赖图谱\n    - 将各个引用模块打包为一个`立即执行`函数\n    - 将最终的bundle文件写入bundle.js中\n\n+ loader其实就是一个`Node.js` 模块，这个模块需要导出一个函数\n\n\n\n\n\n\n\n    ","slug":"webpack","published":1,"updated":"2020-01-04T06:13:16.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmra1000xz5o82zgdeywj","content":"<h3 id=\"1-webpack底层\"><a href=\"#1-webpack底层\" class=\"headerlink\" title=\"1.webpack底层\"></a>1.webpack底层</h3><pre><code>它是一个打包工具。\nwebpack本身，在不借助loader的情况下，只会打包js。\n\n（引用）webpack处理应用程序时，会递归的构建一个依赖关系图，其中包括应用程序需要的每个模块，然后把所有模块打包成一个或多个bundle。</code></pre><h3 id=\"2-几个核心概念\"><a href=\"#2-几个核心概念\" class=\"headerlink\" title=\"2.几个核心概念\"></a>2.几个核心概念</h3><ul>\n<li>入口</li>\n<li>出口<ul>\n<li>入口和出口很好理解，入口就是打包谁，出口就是要输出的文件。<br>entry:<br>output:{ path, filename }</li>\n</ul>\n</li>\n<li>loader<ul>\n<li>帮助webpack识别非js文件，包括css，图片等。</li>\n<li>示例：<br>  test: 作用等同于正则里面的匹配<br>  use: 使用loader<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rules: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">            use: [</span><br><span class=\"line\">                <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    loader: <span class=\"string\">'eslint-loader'</span>,</span><br><span class=\"line\">                    options: &#123;</span><br><span class=\"line\">                        emitWarning: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                        emitError: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                        failOnError: <span class=\"literal\">true</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            exclude: <span class=\"regexp\">/node_modules/</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.css$/</span>, <span class=\"attr\">use</span>: [<span class=\"string\">\"style-loader\"</span>,<span class=\"string\">\"css-loader\"</span>]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.(png|jpg)$/</span>,</span><br><span class=\"line\">            loader: <span class=\"string\">'url-loader?limit=8192'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.vue$/</span>,</span><br><span class=\"line\">            use:[</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    loader: <span class=\"string\">'vue-loader'</span>,</span><br><span class=\"line\">                    options: &#123;</span><br><span class=\"line\">                        cssSourceMap:<span class=\"literal\">false</span>,</span><br><span class=\"line\">                        transformToRequire:&#123;&#125;,</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    loader: <span class=\"string\">'eslint-loader'</span>,</span><br><span class=\"line\">                    options: &#123;</span><br><span class=\"line\">                        emitWarning: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                        emitError: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                        failOnError: <span class=\"literal\">true</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            exclude: <span class=\"regexp\">/node_modules/</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    ]</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>plugins<br>我还没认真弄懂plugins，它好像有很多好用的功能。比如压缩js或者生成好的静态资源增加版本号。待研究 <strong><em>@todo</em></strong></li>\n</ul>\n<hr>\n<p>常见问题：<br>1、webpack打包原理？<br>2、loader，plugins分别是？<br>3、热更新原理是？<br>4、webpack性能优化的方法？</p>\n<hr>\n<ul>\n<li><p>webpack的打包原理：(树状依赖)</p>\n<ul>\n<li>利用babel完成代码转换,并生成单个文件的依赖.</li>\n<li>从入口开始递归分析，并生成依赖图谱</li>\n<li>将各个引用模块打包为一个<code>立即执行</code>函数</li>\n<li>将最终的bundle文件写入bundle.js中</li>\n</ul>\n</li>\n<li><p>loader其实就是一个<code>Node.js</code> 模块，这个模块需要导出一个函数</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-webpack底层\"><a href=\"#1-webpack底层\" class=\"headerlink\" title=\"1.webpack底层\"></a>1.webpack底层</h3><pre><code>它是一个打包工具。\nwebpack本身，在不借助loader的情况下，只会打包js。\n\n（引用）webpack处理应用程序时，会递归的构建一个依赖关系图，其中包括应用程序需要的每个模块，然后把所有模块打包成一个或多个bundle。</code></pre><h3 id=\"2-几个核心概念\"><a href=\"#2-几个核心概念\" class=\"headerlink\" title=\"2.几个核心概念\"></a>2.几个核心概念</h3><ul>\n<li>入口</li>\n<li>出口<ul>\n<li>入口和出口很好理解，入口就是打包谁，出口就是要输出的文件。<br>entry:<br>output:{ path, filename }</li>\n</ul>\n</li>\n<li>loader<ul>\n<li>帮助webpack识别非js文件，包括css，图片等。</li>\n<li>示例：<br>  test: 作用等同于正则里面的匹配<br>  use: 使用loader<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rules: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">            use: [</span><br><span class=\"line\">                <span class=\"string\">'babel-loader'</span>,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    loader: <span class=\"string\">'eslint-loader'</span>,</span><br><span class=\"line\">                    options: &#123;</span><br><span class=\"line\">                        emitWarning: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                        emitError: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                        failOnError: <span class=\"literal\">true</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            exclude: <span class=\"regexp\">/node_modules/</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.css$/</span>, <span class=\"attr\">use</span>: [<span class=\"string\">\"style-loader\"</span>,<span class=\"string\">\"css-loader\"</span>]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.(png|jpg)$/</span>,</span><br><span class=\"line\">            loader: <span class=\"string\">'url-loader?limit=8192'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test: <span class=\"regexp\">/\\.vue$/</span>,</span><br><span class=\"line\">            use:[</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    loader: <span class=\"string\">'vue-loader'</span>,</span><br><span class=\"line\">                    options: &#123;</span><br><span class=\"line\">                        cssSourceMap:<span class=\"literal\">false</span>,</span><br><span class=\"line\">                        transformToRequire:&#123;&#125;,</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    loader: <span class=\"string\">'eslint-loader'</span>,</span><br><span class=\"line\">                    options: &#123;</span><br><span class=\"line\">                        emitWarning: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                        emitError: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                        failOnError: <span class=\"literal\">true</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">            ],</span><br><span class=\"line\">            exclude: <span class=\"regexp\">/node_modules/</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    ]</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>plugins<br>我还没认真弄懂plugins，它好像有很多好用的功能。比如压缩js或者生成好的静态资源增加版本号。待研究 <strong><em>@todo</em></strong></li>\n</ul>\n<hr>\n<p>常见问题：<br>1、webpack打包原理？<br>2、loader，plugins分别是？<br>3、热更新原理是？<br>4、webpack性能优化的方法？</p>\n<hr>\n<ul>\n<li><p>webpack的打包原理：(树状依赖)</p>\n<ul>\n<li>利用babel完成代码转换,并生成单个文件的依赖.</li>\n<li>从入口开始递归分析，并生成依赖图谱</li>\n<li>将各个引用模块打包为一个<code>立即执行</code>函数</li>\n<li>将最终的bundle文件写入bundle.js中</li>\n</ul>\n</li>\n<li><p>loader其实就是一个<code>Node.js</code> 模块，这个模块需要导出一个函数</p>\n</li>\n</ul>\n"},{"title":"函数柯里化","date":"2020-05-27T07:12:29.000Z","_content":"### 1. 是什么？\n\n柯里化是一种将使用`多个参数`的一个函数`转换成`一系列使用`一个参数`的函数的编程技术。\n简单示例：\n```javascript\nfunction add(a, b) { return a + b; }\n\n// 执行 add 函数，一次传入两个参数即可\nadd(1, 2) // 3\n\n// 假设有一个 curry 函数可以做到柯里化\nvar addCurry = curry(add);\n\naddCurry(1)(2) // 调用跟 add (1，2)是一样的\n```\n\n### 2. curry函数的编写\n\n```javascript\n/**\n@feature 普通curry函数的编写\n arguments 对象是内部函数的。\n 当调用(返回的函数)时，它会在给定环境中执行被传入的函数并给出所有参数。\n arguments会视为每次传的参数而定\n*\n*/\nfunction curry(fn, args) {\n    var length = fn.length;\n    args = args || []; // 直到这个时候的arguments都是类数组，arguments[0] = function(a,b,c)\n    return function() {\n        var _args = args.slice(0),\n            arg, i;\n        for (i = 0; i < arguments.length; i++) {\n            arg = arguments[i];\n            _args.push(arg);\n        }\n        if (_args.length < length) { // 这个if else是关键，让curry函数一直循环到，实参数满足形参的个数\n            console.log(this)\n            return curry.call(this, fn, _args);\n        }\n        else {\n            return fn.apply(this, _args);\n        }\n    }\n}\n\nvar fn = curry(function(a, b, c) {\n    console.log([a, b, c]);\n});\n\nfn(\"a\", \"b\", \"c\")\nfn(\"a\", \"b\")(\"c\")\nfn(\"a\")(\"b\")(\"c\")\nfn(\"a\")(\"b\", \"c\")\n\n// 上面四种都会得出这样的结果： [\"a\", \"b\", \"c\"]\n```\n\n```javascript\n// 提前返回的例子\nvar addEvent = (function() {\n    if(window.addEventListener) {\n        return function(el, type, fn, capture) { // 提前返回\n            el.addEventListener(type, function(e) {\n                fn.call(el, e);\n            }, capture);\n        }\n    }else {\n        return function(ele, type, fn) { // 提前返回\n            el.attachEvent('on' + type, function(e) { \n                fn.call(el, e);\n            })\n        }\n    }\n})()\n```\n\n### 3. curry函数写法的引申思考\n\n```javascript\n// 简易版，理解 fn1 中 return fn2的执行\n function testFn() {\n        for (let i = 0; i < 3; i++ ) {\n            console.log(i)\n        }\n        return function () {\n            return 123\n        }\n    }\n    var k = testFn()\n    console.log(k())\n    console.log(k())\n    console.log(k())\n    // k函数表达式的执行，仅仅只有第一次会执行testFn里的for循环，其他次数都已经解析成里面return 123 的函数了\n```\n\n\n```javascript\n// vue 识别html标签的函数\nfunction makeMap(tagStr) {\n  const tagArr = tagStr.split(',');\n  const tagObj = {};\n  for (const tag of tagArr) {\n    tagObj[tag] = true;\n  }\n  return function (tagName) { // 此处还运用了闭包去存储tagObj，仅运行一次就缓存好tagObj，降低了遍历带来的性能消耗\n    return !!tagObj[tagName];\n  }\n}\n\nconst isHTMLTag = makeMap('div,p,span,h1');\nconsole.log(isHTMLTag('div')); // true\n```\n\n### 4. curry函数的特点与作用\n+ 参数复用，提前固定参数\n+ 提前返回\n \n---\n参考文章：\n[javascript.Info](https://zh.javascript.info/currying-partials)\n[冴羽github文章](https://github.com/mqyqingfeng/Blog/issues/42)\n[`arguments`和`function.length`的区别](https://my.oschina.net/u/4400687/blog/3660259)\n[Function.length](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length)\n[github闭包论坛](https://github.com/YvetteLau/Step-By-Step/issues/24)\n\n\n","source":"_posts/函数柯里化.md","raw":"---\n   title: 函数柯里化\n   date: 2020-05-27 15:12:29\n   tags: JS\n---\n### 1. 是什么？\n\n柯里化是一种将使用`多个参数`的一个函数`转换成`一系列使用`一个参数`的函数的编程技术。\n简单示例：\n```javascript\nfunction add(a, b) { return a + b; }\n\n// 执行 add 函数，一次传入两个参数即可\nadd(1, 2) // 3\n\n// 假设有一个 curry 函数可以做到柯里化\nvar addCurry = curry(add);\n\naddCurry(1)(2) // 调用跟 add (1，2)是一样的\n```\n\n### 2. curry函数的编写\n\n```javascript\n/**\n@feature 普通curry函数的编写\n arguments 对象是内部函数的。\n 当调用(返回的函数)时，它会在给定环境中执行被传入的函数并给出所有参数。\n arguments会视为每次传的参数而定\n*\n*/\nfunction curry(fn, args) {\n    var length = fn.length;\n    args = args || []; // 直到这个时候的arguments都是类数组，arguments[0] = function(a,b,c)\n    return function() {\n        var _args = args.slice(0),\n            arg, i;\n        for (i = 0; i < arguments.length; i++) {\n            arg = arguments[i];\n            _args.push(arg);\n        }\n        if (_args.length < length) { // 这个if else是关键，让curry函数一直循环到，实参数满足形参的个数\n            console.log(this)\n            return curry.call(this, fn, _args);\n        }\n        else {\n            return fn.apply(this, _args);\n        }\n    }\n}\n\nvar fn = curry(function(a, b, c) {\n    console.log([a, b, c]);\n});\n\nfn(\"a\", \"b\", \"c\")\nfn(\"a\", \"b\")(\"c\")\nfn(\"a\")(\"b\")(\"c\")\nfn(\"a\")(\"b\", \"c\")\n\n// 上面四种都会得出这样的结果： [\"a\", \"b\", \"c\"]\n```\n\n```javascript\n// 提前返回的例子\nvar addEvent = (function() {\n    if(window.addEventListener) {\n        return function(el, type, fn, capture) { // 提前返回\n            el.addEventListener(type, function(e) {\n                fn.call(el, e);\n            }, capture);\n        }\n    }else {\n        return function(ele, type, fn) { // 提前返回\n            el.attachEvent('on' + type, function(e) { \n                fn.call(el, e);\n            })\n        }\n    }\n})()\n```\n\n### 3. curry函数写法的引申思考\n\n```javascript\n// 简易版，理解 fn1 中 return fn2的执行\n function testFn() {\n        for (let i = 0; i < 3; i++ ) {\n            console.log(i)\n        }\n        return function () {\n            return 123\n        }\n    }\n    var k = testFn()\n    console.log(k())\n    console.log(k())\n    console.log(k())\n    // k函数表达式的执行，仅仅只有第一次会执行testFn里的for循环，其他次数都已经解析成里面return 123 的函数了\n```\n\n\n```javascript\n// vue 识别html标签的函数\nfunction makeMap(tagStr) {\n  const tagArr = tagStr.split(',');\n  const tagObj = {};\n  for (const tag of tagArr) {\n    tagObj[tag] = true;\n  }\n  return function (tagName) { // 此处还运用了闭包去存储tagObj，仅运行一次就缓存好tagObj，降低了遍历带来的性能消耗\n    return !!tagObj[tagName];\n  }\n}\n\nconst isHTMLTag = makeMap('div,p,span,h1');\nconsole.log(isHTMLTag('div')); // true\n```\n\n### 4. curry函数的特点与作用\n+ 参数复用，提前固定参数\n+ 提前返回\n \n---\n参考文章：\n[javascript.Info](https://zh.javascript.info/currying-partials)\n[冴羽github文章](https://github.com/mqyqingfeng/Blog/issues/42)\n[`arguments`和`function.length`的区别](https://my.oschina.net/u/4400687/blog/3660259)\n[Function.length](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length)\n[github闭包论坛](https://github.com/YvetteLau/Step-By-Step/issues/24)\n\n\n","slug":"函数柯里化","published":1,"updated":"2020-07-15T13:13:19.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmra2000zz5o8fy8t6npt","content":"<h3 id=\"1-是什么？\"><a href=\"#1-是什么？\" class=\"headerlink\" title=\"1. 是什么？\"></a>1. 是什么？</h3><p>柯里化是一种将使用<code>多个参数</code>的一个函数<code>转换成</code>一系列使用<code>一个参数</code>的函数的编程技术。<br>简单示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123; <span class=\"keyword\">return</span> a + b; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行 add 函数，一次传入两个参数即可</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设有一个 curry 函数可以做到柯里化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> addCurry = curry(add);</span><br><span class=\"line\"></span><br><span class=\"line\">addCurry(<span class=\"number\">1</span>)(<span class=\"number\">2</span>) <span class=\"comment\">// 调用跟 add (1，2)是一样的</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-curry函数的编写\"><a href=\"#2-curry函数的编写\" class=\"headerlink\" title=\"2. curry函数的编写\"></a>2. curry函数的编写</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">@feature </span>普通curry函数的编写</span></span><br><span class=\"line\"><span class=\"comment\"> arguments 对象是内部函数的。</span></span><br><span class=\"line\"><span class=\"comment\"> 当调用(返回的函数)时，它会在给定环境中执行被传入的函数并给出所有参数。</span></span><br><span class=\"line\"><span class=\"comment\"> arguments会视为每次传的参数而定</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn, args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> length = fn.length;</span><br><span class=\"line\">    args = args || []; <span class=\"comment\">// 直到这个时候的arguments都是类数组，arguments[0] = function(a,b,c)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> _args = args.slice(<span class=\"number\">0</span>),</span><br><span class=\"line\">            arg, i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">            arg = <span class=\"built_in\">arguments</span>[i];</span><br><span class=\"line\">            _args.push(arg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_args.length &lt; length) &#123; <span class=\"comment\">// 这个if else是关键，让curry函数一直循环到，实参数满足形参的个数</span></span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> curry.call(<span class=\"keyword\">this</span>, fn, _args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, _args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log([a, b, c]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>)</span><br><span class=\"line\">fn(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>)(<span class=\"string\">\"c\"</span>)</span><br><span class=\"line\">fn(<span class=\"string\">\"a\"</span>)(<span class=\"string\">\"b\"</span>)(<span class=\"string\">\"c\"</span>)</span><br><span class=\"line\">fn(<span class=\"string\">\"a\"</span>)(<span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上面四种都会得出这样的结果： [\"a\", \"b\", \"c\"]</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 提前返回的例子</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> addEvent = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.addEventListener) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">el, type, fn, capture</span>) </span>&#123; <span class=\"comment\">// 提前返回</span></span><br><span class=\"line\">            el.addEventListener(type, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;, capture);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele, type, fn</span>) </span>&#123; <span class=\"comment\">// 提前返回</span></span><br><span class=\"line\">            el.attachEvent(<span class=\"string\">'on'</span> + type, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; </span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-curry函数写法的引申思考\"><a href=\"#3-curry函数写法的引申思考\" class=\"headerlink\" title=\"3. curry函数写法的引申思考\"></a>3. curry函数写法的引申思考</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简易版，理解 fn1 中 return fn2的执行</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++ ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">123</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> k = testFn()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(k())</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(k())</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(k())</span><br><span class=\"line\">    <span class=\"comment\">// k函数表达式的执行，仅仅只有第一次会执行testFn里的for循环，其他次数都已经解析成里面return 123 的函数了</span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vue 识别html标签的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeMap</span>(<span class=\"params\">tagStr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> tagArr = tagStr.split(<span class=\"string\">','</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> tagObj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> tag <span class=\"keyword\">of</span> tagArr) &#123;</span><br><span class=\"line\">    tagObj[tag] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">tagName</span>) </span>&#123; <span class=\"comment\">// 此处还运用了闭包去存储tagObj，仅运行一次就缓存好tagObj，降低了遍历带来的性能消耗</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> !!tagObj[tagName];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isHTMLTag = makeMap(<span class=\"string\">'div,p,span,h1'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(isHTMLTag(<span class=\"string\">'div'</span>)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-curry函数的特点与作用\"><a href=\"#4-curry函数的特点与作用\" class=\"headerlink\" title=\"4. curry函数的特点与作用\"></a>4. curry函数的特点与作用</h3><ul>\n<li>参数复用，提前固定参数</li>\n<li>提前返回</li>\n</ul>\n<hr>\n<p>参考文章：<br><a href=\"https://zh.javascript.info/currying-partials\" target=\"_blank\" rel=\"noopener\">javascript.Info</a><br><a href=\"https://github.com/mqyqingfeng/Blog/issues/42\" target=\"_blank\" rel=\"noopener\">冴羽github文章</a><br><a href=\"https://my.oschina.net/u/4400687/blog/3660259\" target=\"_blank\" rel=\"noopener\"><code>arguments</code>和<code>function.length</code>的区别</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length\" target=\"_blank\" rel=\"noopener\">Function.length</a><br><a href=\"https://github.com/YvetteLau/Step-By-Step/issues/24\" target=\"_blank\" rel=\"noopener\">github闭包论坛</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-是什么？\"><a href=\"#1-是什么？\" class=\"headerlink\" title=\"1. 是什么？\"></a>1. 是什么？</h3><p>柯里化是一种将使用<code>多个参数</code>的一个函数<code>转换成</code>一系列使用<code>一个参数</code>的函数的编程技术。<br>简单示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123; <span class=\"keyword\">return</span> a + b; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行 add 函数，一次传入两个参数即可</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设有一个 curry 函数可以做到柯里化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> addCurry = curry(add);</span><br><span class=\"line\"></span><br><span class=\"line\">addCurry(<span class=\"number\">1</span>)(<span class=\"number\">2</span>) <span class=\"comment\">// 调用跟 add (1，2)是一样的</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-curry函数的编写\"><a href=\"#2-curry函数的编写\" class=\"headerlink\" title=\"2. curry函数的编写\"></a>2. curry函数的编写</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">@feature </span>普通curry函数的编写</span></span><br><span class=\"line\"><span class=\"comment\"> arguments 对象是内部函数的。</span></span><br><span class=\"line\"><span class=\"comment\"> 当调用(返回的函数)时，它会在给定环境中执行被传入的函数并给出所有参数。</span></span><br><span class=\"line\"><span class=\"comment\"> arguments会视为每次传的参数而定</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn, args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> length = fn.length;</span><br><span class=\"line\">    args = args || []; <span class=\"comment\">// 直到这个时候的arguments都是类数组，arguments[0] = function(a,b,c)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> _args = args.slice(<span class=\"number\">0</span>),</span><br><span class=\"line\">            arg, i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">            arg = <span class=\"built_in\">arguments</span>[i];</span><br><span class=\"line\">            _args.push(arg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_args.length &lt; length) &#123; <span class=\"comment\">// 这个if else是关键，让curry函数一直循环到，实参数满足形参的个数</span></span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> curry.call(<span class=\"keyword\">this</span>, fn, _args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, _args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log([a, b, c]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>)</span><br><span class=\"line\">fn(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>)(<span class=\"string\">\"c\"</span>)</span><br><span class=\"line\">fn(<span class=\"string\">\"a\"</span>)(<span class=\"string\">\"b\"</span>)(<span class=\"string\">\"c\"</span>)</span><br><span class=\"line\">fn(<span class=\"string\">\"a\"</span>)(<span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上面四种都会得出这样的结果： [\"a\", \"b\", \"c\"]</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 提前返回的例子</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> addEvent = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">window</span>.addEventListener) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">el, type, fn, capture</span>) </span>&#123; <span class=\"comment\">// 提前返回</span></span><br><span class=\"line\">            el.addEventListener(type, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;, capture);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele, type, fn</span>) </span>&#123; <span class=\"comment\">// 提前返回</span></span><br><span class=\"line\">            el.attachEvent(<span class=\"string\">'on'</span> + type, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; </span><br><span class=\"line\">                fn.call(el, e);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-curry函数写法的引申思考\"><a href=\"#3-curry函数写法的引申思考\" class=\"headerlink\" title=\"3. curry函数写法的引申思考\"></a>3. curry函数写法的引申思考</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简易版，理解 fn1 中 return fn2的执行</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++ ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(i)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">123</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> k = testFn()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(k())</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(k())</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(k())</span><br><span class=\"line\">    <span class=\"comment\">// k函数表达式的执行，仅仅只有第一次会执行testFn里的for循环，其他次数都已经解析成里面return 123 的函数了</span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// vue 识别html标签的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeMap</span>(<span class=\"params\">tagStr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> tagArr = tagStr.split(<span class=\"string\">','</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> tagObj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> tag <span class=\"keyword\">of</span> tagArr) &#123;</span><br><span class=\"line\">    tagObj[tag] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">tagName</span>) </span>&#123; <span class=\"comment\">// 此处还运用了闭包去存储tagObj，仅运行一次就缓存好tagObj，降低了遍历带来的性能消耗</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> !!tagObj[tagName];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> isHTMLTag = makeMap(<span class=\"string\">'div,p,span,h1'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(isHTMLTag(<span class=\"string\">'div'</span>)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-curry函数的特点与作用\"><a href=\"#4-curry函数的特点与作用\" class=\"headerlink\" title=\"4. curry函数的特点与作用\"></a>4. curry函数的特点与作用</h3><ul>\n<li>参数复用，提前固定参数</li>\n<li>提前返回</li>\n</ul>\n<hr>\n<p>参考文章：<br><a href=\"https://zh.javascript.info/currying-partials\" target=\"_blank\" rel=\"noopener\">javascript.Info</a><br><a href=\"https://github.com/mqyqingfeng/Blog/issues/42\" target=\"_blank\" rel=\"noopener\">冴羽github文章</a><br><a href=\"https://my.oschina.net/u/4400687/blog/3660259\" target=\"_blank\" rel=\"noopener\"><code>arguments</code>和<code>function.length</code>的区别</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length\" target=\"_blank\" rel=\"noopener\">Function.length</a><br><a href=\"https://github.com/YvetteLau/Step-By-Step/issues/24\" target=\"_blank\" rel=\"noopener\">github闭包论坛</a></p>\n"},{"title":"合成图片","date":"2019-02-15T09:32:27.000Z","_content":"\n###### 应用场景 \n    H5的分享海报，需要从后台获取数据，绘制DOM，并且可以长按保存。也就是要求所有DOM都要转为image元素。\n    \n###### 需要引用的库\n    html2Canvas: Screenshots with JavaScript 等于是用js去转换指定的DOM成为image。\n    \n###### 需要注意的地方\n    html2Canvas执行渲染时 ，需等待DOM本身获取后台数据的渲染完成。否则会出现黑背景\n    \n###### 示例代码\n```javascript\n    $(window).load(function() {\n        setTimeout(function () { // 关键在这里，延时进行html2Canvas操作\n            drawCanvas('#sharePoster_bg_img').then(canvas => {\n                const img = new Image();\n                img.style.display = \"block\";\n                // 将 canvas 导出成 base64\n                img.src = canvas.toDataURL('image/jpeg', 0.92);\n                img.crossOrigin = \"Anonymous\";\n                // 添加图片到预览\n                $('#sharePoster_bg_img').html(img); // 生成的base64图片填充到dom里\n                $('.save_text').show();\n            })\n        },500)\n    });\n```\n--- \n\n###### 优化细节 以及 要用到的工具函数\n```js\n/**\n* 根据像素比绘制canvas，使生成图片更加高清。\n* @param DomSelector\n* @returns html2Canvas\n**/\nasync function drawCanvas(selector) {\n    // 获取想要转换的 DOM 节点\n    const dom = document.querySelector(selector);\n    const box = window.getComputedStyle(dom);\n    // DOM 节点计算后宽高\n    const width = parseValue(box.width);\n    const height = parseValue(box.height);\n    // 获取像素比\n    const scaleBy = DPR();\n    // 创建自定义 canvas 元素\n    const canvas = document.createElement('canvas');\n\n    // 设定 canvas 元素属性宽高为 DOM 节点宽高 * 像素比\n    canvas.width = width * scaleBy;\n    canvas.height = height * scaleBy;\n    // 设定 canvas css宽高为 DOM 节点宽高\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    // 获取画笔\n    const context = canvas.getContext('2d');\n\n    // 将所有绘制内容放大像素比倍 \n    context.scale(scaleBy, scaleBy);\n\n    // 将自定义 canvas 作为配置项传入，开始绘制\n    return await html2canvas(dom, {canvas,\n        allowTaint: false,\n        useCORS: true,\n        async: false,\n        width: width,\n        height: height\n    });\n}\n```\n\n```js\n/**\n* 根据window.devicePixelRatio获取像素比\n* @returns 像素比\n*/\nfunction DPR() {\n    if (window.devicePixelRatio && window.devicePixelRatio > 1) {\n        return window.devicePixelRatio;\n    }\n    return 1;\n}\n\n```\n\n```js\n/**\n*  将传入值转为整数\n* @param value\n* @returns {number}\n*/\nfunction parseValue(value) {\n    return parseInt(value, 10);\n}\n```\n\n###### 注意细节：\n    需绘制的DOM所用到的css属性值最好不用最新的属性，html2Canvas不支持最新的css属性解析，会造成生成的图片有黑色背景。\n    \n###### 参考链接：\n   [html2Canvas官网](https://html2canvas.hertzen.com/)\n   [js资源](http://cdn.huodongxing.com/Content/v2.0/plugin/html2canvas/html2canvas.min.js)\n   \n\n\n","source":"_posts/合成图片.md","raw":"---\ntitle: 合成图片\ndate: 2019-02-15 17:32:27\ntags: JS\n---\n\n###### 应用场景 \n    H5的分享海报，需要从后台获取数据，绘制DOM，并且可以长按保存。也就是要求所有DOM都要转为image元素。\n    \n###### 需要引用的库\n    html2Canvas: Screenshots with JavaScript 等于是用js去转换指定的DOM成为image。\n    \n###### 需要注意的地方\n    html2Canvas执行渲染时 ，需等待DOM本身获取后台数据的渲染完成。否则会出现黑背景\n    \n###### 示例代码\n```javascript\n    $(window).load(function() {\n        setTimeout(function () { // 关键在这里，延时进行html2Canvas操作\n            drawCanvas('#sharePoster_bg_img').then(canvas => {\n                const img = new Image();\n                img.style.display = \"block\";\n                // 将 canvas 导出成 base64\n                img.src = canvas.toDataURL('image/jpeg', 0.92);\n                img.crossOrigin = \"Anonymous\";\n                // 添加图片到预览\n                $('#sharePoster_bg_img').html(img); // 生成的base64图片填充到dom里\n                $('.save_text').show();\n            })\n        },500)\n    });\n```\n--- \n\n###### 优化细节 以及 要用到的工具函数\n```js\n/**\n* 根据像素比绘制canvas，使生成图片更加高清。\n* @param DomSelector\n* @returns html2Canvas\n**/\nasync function drawCanvas(selector) {\n    // 获取想要转换的 DOM 节点\n    const dom = document.querySelector(selector);\n    const box = window.getComputedStyle(dom);\n    // DOM 节点计算后宽高\n    const width = parseValue(box.width);\n    const height = parseValue(box.height);\n    // 获取像素比\n    const scaleBy = DPR();\n    // 创建自定义 canvas 元素\n    const canvas = document.createElement('canvas');\n\n    // 设定 canvas 元素属性宽高为 DOM 节点宽高 * 像素比\n    canvas.width = width * scaleBy;\n    canvas.height = height * scaleBy;\n    // 设定 canvas css宽高为 DOM 节点宽高\n    canvas.style.width = `${width}px`;\n    canvas.style.height = `${height}px`;\n    // 获取画笔\n    const context = canvas.getContext('2d');\n\n    // 将所有绘制内容放大像素比倍 \n    context.scale(scaleBy, scaleBy);\n\n    // 将自定义 canvas 作为配置项传入，开始绘制\n    return await html2canvas(dom, {canvas,\n        allowTaint: false,\n        useCORS: true,\n        async: false,\n        width: width,\n        height: height\n    });\n}\n```\n\n```js\n/**\n* 根据window.devicePixelRatio获取像素比\n* @returns 像素比\n*/\nfunction DPR() {\n    if (window.devicePixelRatio && window.devicePixelRatio > 1) {\n        return window.devicePixelRatio;\n    }\n    return 1;\n}\n\n```\n\n```js\n/**\n*  将传入值转为整数\n* @param value\n* @returns {number}\n*/\nfunction parseValue(value) {\n    return parseInt(value, 10);\n}\n```\n\n###### 注意细节：\n    需绘制的DOM所用到的css属性值最好不用最新的属性，html2Canvas不支持最新的css属性解析，会造成生成的图片有黑色背景。\n    \n###### 参考链接：\n   [html2Canvas官网](https://html2canvas.hertzen.com/)\n   [js资源](http://cdn.huodongxing.com/Content/v2.0/plugin/html2canvas/html2canvas.min.js)\n   \n\n\n","slug":"合成图片","published":1,"updated":"2019-03-16T07:32:27.018Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmra30011z5o87xvb4des","content":"<h6 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h6><pre><code>H5的分享海报，需要从后台获取数据，绘制DOM，并且可以长按保存。也就是要求所有DOM都要转为image元素。</code></pre><h6 id=\"需要引用的库\"><a href=\"#需要引用的库\" class=\"headerlink\" title=\"需要引用的库\"></a>需要引用的库</h6><pre><code>html2Canvas: Screenshots with JavaScript 等于是用js去转换指定的DOM成为image。</code></pre><h6 id=\"需要注意的地方\"><a href=\"#需要注意的地方\" class=\"headerlink\" title=\"需要注意的地方\"></a>需要注意的地方</h6><pre><code>html2Canvas执行渲染时 ，需等待DOM本身获取后台数据的渲染完成。否则会出现黑背景</code></pre><h6 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"built_in\">window</span>).load(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 关键在这里，延时进行html2Canvas操作</span></span><br><span class=\"line\">        drawCanvas(<span class=\"string\">'#sharePoster_bg_img'</span>).then(<span class=\"function\"><span class=\"params\">canvas</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> img = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">            img.style.display = <span class=\"string\">\"block\"</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 将 canvas 导出成 base64</span></span><br><span class=\"line\">            img.src = canvas.toDataURL(<span class=\"string\">'image/jpeg'</span>, <span class=\"number\">0.92</span>);</span><br><span class=\"line\">            img.crossOrigin = <span class=\"string\">\"Anonymous\"</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 添加图片到预览</span></span><br><span class=\"line\">            $(<span class=\"string\">'#sharePoster_bg_img'</span>).html(img); <span class=\"comment\">// 生成的base64图片填充到dom里</span></span><br><span class=\"line\">            $(<span class=\"string\">'.save_text'</span>).show();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;,<span class=\"number\">500</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<h6 id=\"优化细节-以及-要用到的工具函数\"><a href=\"#优化细节-以及-要用到的工具函数\" class=\"headerlink\" title=\"优化细节 以及 要用到的工具函数\"></a>优化细节 以及 要用到的工具函数</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 根据像素比绘制canvas，使生成图片更加高清。</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param <span class=\"variable\">DomSelector</span></span></span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@returns <span class=\"variable\">html2Canvas</span></span></span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">drawCanvas</span>(<span class=\"params\">selector</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取想要转换的 DOM 节点</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> dom = <span class=\"built_in\">document</span>.querySelector(selector);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> box = <span class=\"built_in\">window</span>.getComputedStyle(dom);</span><br><span class=\"line\">    <span class=\"comment\">// DOM 节点计算后宽高</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> width = parseValue(box.width);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> height = parseValue(box.height);</span><br><span class=\"line\">    <span class=\"comment\">// 获取像素比</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> scaleBy = DPR();</span><br><span class=\"line\">    <span class=\"comment\">// 创建自定义 canvas 元素</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> canvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设定 canvas 元素属性宽高为 DOM 节点宽高 * 像素比</span></span><br><span class=\"line\">    canvas.width = width * scaleBy;</span><br><span class=\"line\">    canvas.height = height * scaleBy;</span><br><span class=\"line\">    <span class=\"comment\">// 设定 canvas css宽高为 DOM 节点宽高</span></span><br><span class=\"line\">    canvas.style.width = <span class=\"string\">`<span class=\"subst\">$&#123;width&#125;</span>px`</span>;</span><br><span class=\"line\">    canvas.style.height = <span class=\"string\">`<span class=\"subst\">$&#123;height&#125;</span>px`</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取画笔</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> context = canvas.getContext(<span class=\"string\">'2d'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将所有绘制内容放大像素比倍 </span></span><br><span class=\"line\">    context.scale(scaleBy, scaleBy);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将自定义 canvas 作为配置项传入，开始绘制</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> html2canvas(dom, &#123;canvas,</span><br><span class=\"line\">        allowTaint: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        useCORS: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"keyword\">async</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        width: width,</span><br><span class=\"line\">        height: height</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 根据window.devicePixelRatio获取像素比</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@returns </span>像素比</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DPR</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.devicePixelRatio &amp;&amp; <span class=\"built_in\">window</span>.devicePixelRatio &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.devicePixelRatio;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*  将传入值转为整数</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param <span class=\"variable\">value</span></span></span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@returns <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseValue</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">parseInt</span>(value, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"注意细节：\"><a href=\"#注意细节：\" class=\"headerlink\" title=\"注意细节：\"></a>注意细节：</h6><pre><code>需绘制的DOM所用到的css属性值最好不用最新的属性，html2Canvas不支持最新的css属性解析，会造成生成的图片有黑色背景。</code></pre><h6 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h6><p>   <a href=\"https://html2canvas.hertzen.com/\" target=\"_blank\" rel=\"noopener\">html2Canvas官网</a><br>   <a href=\"http://cdn.huodongxing.com/Content/v2.0/plugin/html2canvas/html2canvas.min.js\" target=\"_blank\" rel=\"noopener\">js资源</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h6 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h6><pre><code>H5的分享海报，需要从后台获取数据，绘制DOM，并且可以长按保存。也就是要求所有DOM都要转为image元素。</code></pre><h6 id=\"需要引用的库\"><a href=\"#需要引用的库\" class=\"headerlink\" title=\"需要引用的库\"></a>需要引用的库</h6><pre><code>html2Canvas: Screenshots with JavaScript 等于是用js去转换指定的DOM成为image。</code></pre><h6 id=\"需要注意的地方\"><a href=\"#需要注意的地方\" class=\"headerlink\" title=\"需要注意的地方\"></a>需要注意的地方</h6><pre><code>html2Canvas执行渲染时 ，需等待DOM本身获取后台数据的渲染完成。否则会出现黑背景</code></pre><h6 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h6><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"built_in\">window</span>).load(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 关键在这里，延时进行html2Canvas操作</span></span><br><span class=\"line\">        drawCanvas(<span class=\"string\">'#sharePoster_bg_img'</span>).then(<span class=\"function\"><span class=\"params\">canvas</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> img = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">            img.style.display = <span class=\"string\">\"block\"</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 将 canvas 导出成 base64</span></span><br><span class=\"line\">            img.src = canvas.toDataURL(<span class=\"string\">'image/jpeg'</span>, <span class=\"number\">0.92</span>);</span><br><span class=\"line\">            img.crossOrigin = <span class=\"string\">\"Anonymous\"</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 添加图片到预览</span></span><br><span class=\"line\">            $(<span class=\"string\">'#sharePoster_bg_img'</span>).html(img); <span class=\"comment\">// 生成的base64图片填充到dom里</span></span><br><span class=\"line\">            $(<span class=\"string\">'.save_text'</span>).show();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;,<span class=\"number\">500</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<h6 id=\"优化细节-以及-要用到的工具函数\"><a href=\"#优化细节-以及-要用到的工具函数\" class=\"headerlink\" title=\"优化细节 以及 要用到的工具函数\"></a>优化细节 以及 要用到的工具函数</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 根据像素比绘制canvas，使生成图片更加高清。</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param <span class=\"variable\">DomSelector</span></span></span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@returns <span class=\"variable\">html2Canvas</span></span></span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">drawCanvas</span>(<span class=\"params\">selector</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取想要转换的 DOM 节点</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> dom = <span class=\"built_in\">document</span>.querySelector(selector);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> box = <span class=\"built_in\">window</span>.getComputedStyle(dom);</span><br><span class=\"line\">    <span class=\"comment\">// DOM 节点计算后宽高</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> width = parseValue(box.width);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> height = parseValue(box.height);</span><br><span class=\"line\">    <span class=\"comment\">// 获取像素比</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> scaleBy = DPR();</span><br><span class=\"line\">    <span class=\"comment\">// 创建自定义 canvas 元素</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> canvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设定 canvas 元素属性宽高为 DOM 节点宽高 * 像素比</span></span><br><span class=\"line\">    canvas.width = width * scaleBy;</span><br><span class=\"line\">    canvas.height = height * scaleBy;</span><br><span class=\"line\">    <span class=\"comment\">// 设定 canvas css宽高为 DOM 节点宽高</span></span><br><span class=\"line\">    canvas.style.width = <span class=\"string\">`<span class=\"subst\">$&#123;width&#125;</span>px`</span>;</span><br><span class=\"line\">    canvas.style.height = <span class=\"string\">`<span class=\"subst\">$&#123;height&#125;</span>px`</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取画笔</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> context = canvas.getContext(<span class=\"string\">'2d'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将所有绘制内容放大像素比倍 </span></span><br><span class=\"line\">    context.scale(scaleBy, scaleBy);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将自定义 canvas 作为配置项传入，开始绘制</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> html2canvas(dom, &#123;canvas,</span><br><span class=\"line\">        allowTaint: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        useCORS: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"keyword\">async</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        width: width,</span><br><span class=\"line\">        height: height</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 根据window.devicePixelRatio获取像素比</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@returns </span>像素比</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DPR</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.devicePixelRatio &amp;&amp; <span class=\"built_in\">window</span>.devicePixelRatio &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.devicePixelRatio;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*  将传入值转为整数</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param <span class=\"variable\">value</span></span></span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@returns <span class=\"type\">&#123;number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseValue</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">parseInt</span>(value, <span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"注意细节：\"><a href=\"#注意细节：\" class=\"headerlink\" title=\"注意细节：\"></a>注意细节：</h6><pre><code>需绘制的DOM所用到的css属性值最好不用最新的属性，html2Canvas不支持最新的css属性解析，会造成生成的图片有黑色背景。</code></pre><h6 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h6><p>   <a href=\"https://html2canvas.hertzen.com/\" target=\"_blank\" rel=\"noopener\">html2Canvas官网</a><br>   <a href=\"http://cdn.huodongxing.com/Content/v2.0/plugin/html2canvas/html2canvas.min.js\" target=\"_blank\" rel=\"noopener\">js资源</a></p>\n"},{"title":"复制内容","date":"2019-03-02T14:18:40.000Z","_content":"\n###### 常用场景：\n有时候需要复制内容，比如复制链接，需要用js实现，那么，可以这么解决\n    \n###### 核心原理：\n利用input的`选择属性`，获取input的值，选择它，并且执行`document.execCommand(\"Copy\")` 。而且因为往往值是隐藏的，所以这个input也是不外露的。\n    \n###### 上些代码：\n\n```html\n   <input type=\"text\" id=\"inviteHideInput\" value=\"\" style=\"height: 1px;width: 1px;\"> <!-- 这是隐藏的input -->\n    <input type=\"text\" name=\"name\" value=\"复制邀请函链接\" class=\"copyInviteUrl\" /> <!-- 这是触发的Dom -->\n```\n\n```js\n     $('.copyInviteUrl').click(function () {\n            var eid = getQueryString('id');\n            var newUrl = location.host + '/invitation?eid=' + eid;\n            $('#inviteHideInput').attr('value', newUrl);\n            $('#inviteHideInput').select();\n            document.execCommand(\"Copy\"); // 执行浏览器复制命令\n            PopupMessage(0, \"已复制，您可以使用Ctrl+V粘贴。\", 1000)\n    });\n```","source":"_posts/复制内容.md","raw":"---\ntitle: 复制内容\ndate: 2019-03-02 22:18:40\ntags: JS\n---\n\n###### 常用场景：\n有时候需要复制内容，比如复制链接，需要用js实现，那么，可以这么解决\n    \n###### 核心原理：\n利用input的`选择属性`，获取input的值，选择它，并且执行`document.execCommand(\"Copy\")` 。而且因为往往值是隐藏的，所以这个input也是不外露的。\n    \n###### 上些代码：\n\n```html\n   <input type=\"text\" id=\"inviteHideInput\" value=\"\" style=\"height: 1px;width: 1px;\"> <!-- 这是隐藏的input -->\n    <input type=\"text\" name=\"name\" value=\"复制邀请函链接\" class=\"copyInviteUrl\" /> <!-- 这是触发的Dom -->\n```\n\n```js\n     $('.copyInviteUrl').click(function () {\n            var eid = getQueryString('id');\n            var newUrl = location.host + '/invitation?eid=' + eid;\n            $('#inviteHideInput').attr('value', newUrl);\n            $('#inviteHideInput').select();\n            document.execCommand(\"Copy\"); // 执行浏览器复制命令\n            PopupMessage(0, \"已复制，您可以使用Ctrl+V粘贴。\", 1000)\n    });\n```","slug":"复制内容","published":1,"updated":"2019-03-17T14:37:05.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmra50013z5o8hnjlejtx","content":"<h6 id=\"常用场景：\"><a href=\"#常用场景：\" class=\"headerlink\" title=\"常用场景：\"></a>常用场景：</h6><p>有时候需要复制内容，比如复制链接，需要用js实现，那么，可以这么解决</p>\n<h6 id=\"核心原理：\"><a href=\"#核心原理：\" class=\"headerlink\" title=\"核心原理：\"></a>核心原理：</h6><p>利用input的<code>选择属性</code>，获取input的值，选择它，并且执行<code>document.execCommand(&quot;Copy&quot;)</code> 。而且因为往往值是隐藏的，所以这个input也是不外露的。</p>\n<h6 id=\"上些代码：\"><a href=\"#上些代码：\" class=\"headerlink\" title=\"上些代码：\"></a>上些代码：</h6><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"inviteHideInput\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"height: 1px;width: 1px;\"</span>&gt;</span> <span class=\"comment\">&lt;!-- 这是隐藏的input --&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"复制邀请函链接\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"copyInviteUrl\"</span> /&gt;</span> <span class=\"comment\">&lt;!-- 这是触发的Dom --&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> $(<span class=\"string\">'.copyInviteUrl'</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> eid = getQueryString(<span class=\"string\">'id'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> newUrl = location.host + <span class=\"string\">'/invitation?eid='</span> + eid;</span><br><span class=\"line\">        $(<span class=\"string\">'#inviteHideInput'</span>).attr(<span class=\"string\">'value'</span>, newUrl);</span><br><span class=\"line\">        $(<span class=\"string\">'#inviteHideInput'</span>).select();</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.execCommand(<span class=\"string\">\"Copy\"</span>); <span class=\"comment\">// 执行浏览器复制命令</span></span><br><span class=\"line\">        PopupMessage(<span class=\"number\">0</span>, <span class=\"string\">\"已复制，您可以使用Ctrl+V粘贴。\"</span>, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h6 id=\"常用场景：\"><a href=\"#常用场景：\" class=\"headerlink\" title=\"常用场景：\"></a>常用场景：</h6><p>有时候需要复制内容，比如复制链接，需要用js实现，那么，可以这么解决</p>\n<h6 id=\"核心原理：\"><a href=\"#核心原理：\" class=\"headerlink\" title=\"核心原理：\"></a>核心原理：</h6><p>利用input的<code>选择属性</code>，获取input的值，选择它，并且执行<code>document.execCommand(&quot;Copy&quot;)</code> 。而且因为往往值是隐藏的，所以这个input也是不外露的。</p>\n<h6 id=\"上些代码：\"><a href=\"#上些代码：\" class=\"headerlink\" title=\"上些代码：\"></a>上些代码：</h6><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"inviteHideInput\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"height: 1px;width: 1px;\"</span>&gt;</span> <span class=\"comment\">&lt;!-- 这是隐藏的input --&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"复制邀请函链接\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"copyInviteUrl\"</span> /&gt;</span> <span class=\"comment\">&lt;!-- 这是触发的Dom --&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> $(<span class=\"string\">'.copyInviteUrl'</span>).click(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> eid = getQueryString(<span class=\"string\">'id'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> newUrl = location.host + <span class=\"string\">'/invitation?eid='</span> + eid;</span><br><span class=\"line\">        $(<span class=\"string\">'#inviteHideInput'</span>).attr(<span class=\"string\">'value'</span>, newUrl);</span><br><span class=\"line\">        $(<span class=\"string\">'#inviteHideInput'</span>).select();</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.execCommand(<span class=\"string\">\"Copy\"</span>); <span class=\"comment\">// 执行浏览器复制命令</span></span><br><span class=\"line\">        PopupMessage(<span class=\"number\">0</span>, <span class=\"string\">\"已复制，您可以使用Ctrl+V粘贴。\"</span>, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"克隆对象&&数组（二）","date":"2020-07-13T07:12:29.000Z","_content":"\n#### 4. 深拷贝CODE\n`深拷贝 = 浅拷贝 + 遇到对象时递归拷贝`\n（1）最简单莫过于字符序列化，再parse反序列化\n语法：JSON.parse(JSON.stringify) \n<div class=\"tip\">\n后端传回的变量一般用它来拷贝足以应对。只是，\n1、会忽略 undefined\n                      \n2、会忽略 symbol\n                      \n3、不能序列化函数\n\n4、不能解决循环引用的对象\n\n5、不能正确处理new Date()\n\n6、不能处理正则\n                      \nundefined、symbol 和函数这三种情况，会直接忽略。拷贝函数会undefined，拷贝正则会Object{}，没拷完整。\n</div>\n\n```javascript \n// undefined symbol 函数示例\nlet obj = {\n    name: 'muyiy',\n    a: undefined,\n    b: Symbol('muyiy'),\n    c: function() {}\n}\nconsole.log(obj);\n// {\n// \tname: \"muyiy\", \n// \ta: undefined, \n//  b: Symbol(muyiy), \n//  c: ƒ ()\n// }\n\nlet b = JSON.parse(JSON.stringify(obj));\nconsole.log(b);\n// {name: \"muyiy\"}\n```\n\n```javascript\n// 循环引用\nlet obj = {\n    a: 1,\n    b: {\n        c: 2,\n   \t\td: 3\n    }\n}\nobj.a = obj.b;\nobj.b.c = obj.a;\n\nlet b = JSON.parse(JSON.stringify(obj));\n// Uncaught TypeError: Converting circular structure to JSON\n```\n\n```javascript\n// new Date转化结果不正确 结果方案是转为时间戳\nlet date = (new Date()).valueOf();\nJSON.stringify(date); \nJSON.parse(JSON.stringify(date)); // 和上面的输出是同一个值\n```\n\n```javascript\n// 正则\nlet obj = {\n    name: \"muyiy\",\n    a: /'123'/\n}\nconsole.log(obj);\n// {name: \"muyiy\", a: /'123'/}\n\nlet b = JSON.parse(JSON.stringify(obj));\nconsole.log(b); // {name: \"muyiy\", a: {}}\n```\n\n(2) 简易深拷贝\n\n第一版\n```javascript\n// 这个虽然能简单实现 却有以下问题\n// 1、没有对传入参数进行校验，传入 null 时应该返回 null 而不是 {}\n// 2、对于对象的判断逻辑不严谨，因为 typeof null === 'object'\n// 3、没有考虑数组的兼容\nfunction cloneDeep1(source) {\n    var target = {};\n    for(var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (typeof source[key] === 'object') {\n                target[key] = cloneDeep1(source[key]); // 注意这里 如果是对象的时候递归调用\n            } else {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n}\n\n```\n\n第二版 （非对象的返回自身以及数组的支持）\n```javascript\nfunction isObject(obj) {// 非对象返回自身\n\treturn typeof obj === 'object' && obj != null; \n}\nfunction cloneDeep2(source) {\n    if (!isObject(source)) return source; // 非对象返回自身\n    var target = Array.isArray(source) ? [] : {}; // 初始值为空数组或空对象\n    for(var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (isObject(source[key])) {\n                target[key] = cloneDeep2(source[key]); // 注意这里\n            } else {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n}\n\n// 使用上面测试用例测试一下\nvar b = cloneDeep2(a);\nconsole.log(b);\n// { \n//   name: 'muyiy', \n//   book: { title: 'You Don\\'t Know JS', price: '45' },\n//   a1: undefined,\n//   a2: null,\n//   a3: 123\n// }\n```\n\n第三版 （支持对象循环引用）\n```javascript\nfunction cloneDeep3(source, hash = new WeakMap()) {\n\n    if (!isObject(source)) return source; \n    if (hash.has(source)) return hash.get(source); // 新增代码，查哈希表\n      \n    var target = Array.isArray(source) ? [] : {};\n    hash.set(source, target); // 新增代码，哈希表设值\n    \n    for(var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (isObject(source[key])) {\n                target[key] = cloneDeep3(source[key], hash); // 新增代码，传入哈希表\n            } else {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n}\n\nconst a = {\n        name: \"muyiy\",\n        a1: undefined,\n        a2: null,\n        a3: 123,\n        book: {title: \"You Don't Know JS\", price: \"45\"},\n    }\n    a.circleRef = a // circleRef是个很奇特的属性，它能在自身存自己，并永久循环，\n    var b = cloneDeep3(a)\n    console.log(b)\n```\n\n第四版 （保存引用关系）\n```javascript\n   // 数组版\n    function cloneDeep3(source, uniqueList) {\n        if (!isObject(source)) return source\n        if (!uniqueList) uniqueList = []\n\n        var target = Array.isArray(source) ? [] : {}\n\n        var uniqueData = find(uniqueList, source)\n        \n        // 数据已经存在，返回保存的数据 如果return这一步，会跳到下方的return target\n        if(uniqueData) {\n            return uniqueData.target\n        }\n        \n        // 数据不存在，保存源数据，以及对应的引用\n        uniqueList.push({ // 用数组存储键值对\n            source: source,\n            target: target\n        })\n\n        for (var key in source) {\n            if(Object.prototype.hasOwnProperty.call(source,key)) {\n                if (isObject(source[key])) {\n                    target[key] = cloneDeep3(source[key], uniqueList)\n                } else {\n                    target[key] = source[key]\n                }\n            }\n        }\n        return target // target很值得玩味，递归完了后的callStack让人惊奇\n    }\n\n    var obj1 = {};\n    var obj2 = {a: obj1, b: obj1};\n\n    console.log(obj2.a === obj2.b);\n    // true\n\n    var obj3 = cloneDeep3(obj2);\n    console.log(obj3.a === obj3.b)\n    // true\n```\n\n第五版 （拷贝Symbol类型）\n思路就是先查找有没有 Symbol 属性，如果查找到则先遍历处理 Symbol 情况，然后再处理正常情况，\n```javascript\n// 逻辑代码\nfunction cloneDeep4(source, hash = new WeakMap()) {\n\n    if (!isObject(source)) return source; \n    if (hash.has(source)) return hash.get(source); \n      \n    let target = Array.isArray(source) ? [] : {};\n    hash.set(source, target);\n    \n    // ============= 新增代码\n    let symKeys = Object.getOwnPropertySymbols(source); // 查找 \n    if (symKeys.length) { // 查找成功\t\n        symKeys.forEach(symKey => {\n            if (isObject(source[symKey])) {\n                target[symKey] = cloneDeep4(source[symKey], hash); \n            } else {\n                target[symKey] = source[symKey];\n            }    \n        });\n    }\n    // =============\n    \n    for(let key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (isObject(source[key])) {\n                target[key] = cloneDeep4(source[key], hash); \n            } else {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n}\n\n// 测试 可以看到成功拷贝了Symbol类型\nvar sym1 = Symbol(\"a\"); // 创建新的symbol类型\nvar sym2 = Symbol.for(\"b\"); // 从全局的symbol注册?表设置和取得symbol\n\na[sym1] = \"localSymbol\";\na[sym2] = \"globalSymbol\";\n\nvar b = cloneDeep4(a);\nconsole.log(b);\n// {\n// \tname: \"muyiy\",\n// \ta1: undefined,\n//\ta2: null,\n// \ta3: 123,\n// \tbook: {title: \"You Don't Know JS\", price: \"45\"},\n// \tcircleRef: {name: \"muyiy\", book: {…}, a1: undefined, a2: null, a3: 123, …},\n//  [Symbol(a)]: 'localSymbol',\n//  [Symbol(b)]: 'globalSymbol'\n// }\n```\n\n\n第六版 破解递归爆栈 (待研究@todo)\n```javascript\nfunction cloneDeep5(x) {\n    const root = {};\n\n    // 栈\n    const loopList = [\n        {\n            parent: root,\n            key: undefined,\n            data: x,\n        }\n    ];\n\n    while(loopList.length) {\n        // 广度优先\n        const node = loopList.pop();\n        const parent = node.parent;\n        const key = node.key;\n        const data = node.data;\n\n        // 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素\n        let res = parent;\n        if (typeof key !== 'undefined') {\n            res = parent[key] = {};\n        }\n\n        for(let k in data) {\n            if (data.hasOwnProperty(k)) {\n                if (typeof data[k] === 'object') {\n                    // 下一次循环\n                    loopList.push({\n                        parent: res,\n                        key: k,\n                        data: data[k],\n                    });\n                } else {\n                    res[k] = data[k];\n                }\n            }\n        }\n    }\n\n    return root;\n}\n```\n\n\n#### 小语法：\n1 Object.keys(..) 返回一个数组，包含所有可枚举属性\n2 Object.getOwnPropertyNames(..) 返回一个数组，包含所有属性，无论它们是否可枚举\n3 Object.getOwnPropertyDescriptor() 会返回对象的属性的指定描述\n4 in && hasOwnProperty\n```javascript\nvar anotherObject = {\n    a: 1\n};\n// 创建一个关联到 anotherObject 的对象\nvar myObject = Object.create( anotherObject );\nmyObject.b = 2;\n(\"a\" in myObject); // true\n(\"b\" in myObject); // true\nmyObject.hasOwnProperty( \"a\" ); // false\nmyObject.hasOwnProperty( \"b\" ); // true\n\n// (1) in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。\n// (2) hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 原型链。\n```\n5 WeakMap\n特点：弱引用，需以对象作为key，不打扰垃圾回收机制，可以通过set，get来取值\n```javascript\nconst wm1 = new WeakMap(),\n      wm2 = new WeakMap(),\n      wm3 = new WeakMap();\nconst o1 = {},\n      o2 = function(){},\n      o3 = window;\n\nwm1.set(o1, 37);\nwm1.set(o2, \"azerty\");\nwm2.set(o1, o2); // value可以是任意值,包括一个对象或一个函数\nwm2.set(o3, undefined);\nwm2.set(wm1, wm2); // 键和值可以是任意对象,甚至另外一个WeakMap对象\n\nwm1.get(o2); // \"azerty\"\nwm2.get(o2); // undefined,wm2中没有o2这个键\nwm2.get(o3); // undefined,值就是undefined\n\nwm1.has(o2); // true\nwm2.has(o2); // false\nwm2.has(o3); // true (即使值是undefined)\n\nwm3.set(o1, 37);\nwm3.get(o1); // 37\n\nwm1.has(o1);   // true\nwm1.delete(o1);\nwm1.has(o1);   // false\n\n```\n\n\n参考\n[MDN Object.assign](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n[wengjq issue](https://github.com/wengjq/Blog/issues/3)\n[yygmind issue](https://github.com/yygmind/blog/issues/25)\n[yygmind 深浅拷贝汇总](https://github.com/yygmind/blog/labels/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8E%9F%E7%90%86)\n[展开语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax)\n[MDN Object.getOwnPropertyDescription](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)\n[MDN WeakMap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)\n[神奇的weakmap科普贴](https://www.codenong.com/29413222/)\n[颜海镜](https://segmentfault.com/a/1190000016672263)","source":"_posts/克隆对象&&数组（二）.md","raw":"---\n   title: 克隆对象&&数组（二）\n   date: 2020-07-13 15:12:29\n   tags: JS 拷贝\n---\n\n#### 4. 深拷贝CODE\n`深拷贝 = 浅拷贝 + 遇到对象时递归拷贝`\n（1）最简单莫过于字符序列化，再parse反序列化\n语法：JSON.parse(JSON.stringify) \n<div class=\"tip\">\n后端传回的变量一般用它来拷贝足以应对。只是，\n1、会忽略 undefined\n                      \n2、会忽略 symbol\n                      \n3、不能序列化函数\n\n4、不能解决循环引用的对象\n\n5、不能正确处理new Date()\n\n6、不能处理正则\n                      \nundefined、symbol 和函数这三种情况，会直接忽略。拷贝函数会undefined，拷贝正则会Object{}，没拷完整。\n</div>\n\n```javascript \n// undefined symbol 函数示例\nlet obj = {\n    name: 'muyiy',\n    a: undefined,\n    b: Symbol('muyiy'),\n    c: function() {}\n}\nconsole.log(obj);\n// {\n// \tname: \"muyiy\", \n// \ta: undefined, \n//  b: Symbol(muyiy), \n//  c: ƒ ()\n// }\n\nlet b = JSON.parse(JSON.stringify(obj));\nconsole.log(b);\n// {name: \"muyiy\"}\n```\n\n```javascript\n// 循环引用\nlet obj = {\n    a: 1,\n    b: {\n        c: 2,\n   \t\td: 3\n    }\n}\nobj.a = obj.b;\nobj.b.c = obj.a;\n\nlet b = JSON.parse(JSON.stringify(obj));\n// Uncaught TypeError: Converting circular structure to JSON\n```\n\n```javascript\n// new Date转化结果不正确 结果方案是转为时间戳\nlet date = (new Date()).valueOf();\nJSON.stringify(date); \nJSON.parse(JSON.stringify(date)); // 和上面的输出是同一个值\n```\n\n```javascript\n// 正则\nlet obj = {\n    name: \"muyiy\",\n    a: /'123'/\n}\nconsole.log(obj);\n// {name: \"muyiy\", a: /'123'/}\n\nlet b = JSON.parse(JSON.stringify(obj));\nconsole.log(b); // {name: \"muyiy\", a: {}}\n```\n\n(2) 简易深拷贝\n\n第一版\n```javascript\n// 这个虽然能简单实现 却有以下问题\n// 1、没有对传入参数进行校验，传入 null 时应该返回 null 而不是 {}\n// 2、对于对象的判断逻辑不严谨，因为 typeof null === 'object'\n// 3、没有考虑数组的兼容\nfunction cloneDeep1(source) {\n    var target = {};\n    for(var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (typeof source[key] === 'object') {\n                target[key] = cloneDeep1(source[key]); // 注意这里 如果是对象的时候递归调用\n            } else {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n}\n\n```\n\n第二版 （非对象的返回自身以及数组的支持）\n```javascript\nfunction isObject(obj) {// 非对象返回自身\n\treturn typeof obj === 'object' && obj != null; \n}\nfunction cloneDeep2(source) {\n    if (!isObject(source)) return source; // 非对象返回自身\n    var target = Array.isArray(source) ? [] : {}; // 初始值为空数组或空对象\n    for(var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (isObject(source[key])) {\n                target[key] = cloneDeep2(source[key]); // 注意这里\n            } else {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n}\n\n// 使用上面测试用例测试一下\nvar b = cloneDeep2(a);\nconsole.log(b);\n// { \n//   name: 'muyiy', \n//   book: { title: 'You Don\\'t Know JS', price: '45' },\n//   a1: undefined,\n//   a2: null,\n//   a3: 123\n// }\n```\n\n第三版 （支持对象循环引用）\n```javascript\nfunction cloneDeep3(source, hash = new WeakMap()) {\n\n    if (!isObject(source)) return source; \n    if (hash.has(source)) return hash.get(source); // 新增代码，查哈希表\n      \n    var target = Array.isArray(source) ? [] : {};\n    hash.set(source, target); // 新增代码，哈希表设值\n    \n    for(var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (isObject(source[key])) {\n                target[key] = cloneDeep3(source[key], hash); // 新增代码，传入哈希表\n            } else {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n}\n\nconst a = {\n        name: \"muyiy\",\n        a1: undefined,\n        a2: null,\n        a3: 123,\n        book: {title: \"You Don't Know JS\", price: \"45\"},\n    }\n    a.circleRef = a // circleRef是个很奇特的属性，它能在自身存自己，并永久循环，\n    var b = cloneDeep3(a)\n    console.log(b)\n```\n\n第四版 （保存引用关系）\n```javascript\n   // 数组版\n    function cloneDeep3(source, uniqueList) {\n        if (!isObject(source)) return source\n        if (!uniqueList) uniqueList = []\n\n        var target = Array.isArray(source) ? [] : {}\n\n        var uniqueData = find(uniqueList, source)\n        \n        // 数据已经存在，返回保存的数据 如果return这一步，会跳到下方的return target\n        if(uniqueData) {\n            return uniqueData.target\n        }\n        \n        // 数据不存在，保存源数据，以及对应的引用\n        uniqueList.push({ // 用数组存储键值对\n            source: source,\n            target: target\n        })\n\n        for (var key in source) {\n            if(Object.prototype.hasOwnProperty.call(source,key)) {\n                if (isObject(source[key])) {\n                    target[key] = cloneDeep3(source[key], uniqueList)\n                } else {\n                    target[key] = source[key]\n                }\n            }\n        }\n        return target // target很值得玩味，递归完了后的callStack让人惊奇\n    }\n\n    var obj1 = {};\n    var obj2 = {a: obj1, b: obj1};\n\n    console.log(obj2.a === obj2.b);\n    // true\n\n    var obj3 = cloneDeep3(obj2);\n    console.log(obj3.a === obj3.b)\n    // true\n```\n\n第五版 （拷贝Symbol类型）\n思路就是先查找有没有 Symbol 属性，如果查找到则先遍历处理 Symbol 情况，然后再处理正常情况，\n```javascript\n// 逻辑代码\nfunction cloneDeep4(source, hash = new WeakMap()) {\n\n    if (!isObject(source)) return source; \n    if (hash.has(source)) return hash.get(source); \n      \n    let target = Array.isArray(source) ? [] : {};\n    hash.set(source, target);\n    \n    // ============= 新增代码\n    let symKeys = Object.getOwnPropertySymbols(source); // 查找 \n    if (symKeys.length) { // 查找成功\t\n        symKeys.forEach(symKey => {\n            if (isObject(source[symKey])) {\n                target[symKey] = cloneDeep4(source[symKey], hash); \n            } else {\n                target[symKey] = source[symKey];\n            }    \n        });\n    }\n    // =============\n    \n    for(let key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            if (isObject(source[key])) {\n                target[key] = cloneDeep4(source[key], hash); \n            } else {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n}\n\n// 测试 可以看到成功拷贝了Symbol类型\nvar sym1 = Symbol(\"a\"); // 创建新的symbol类型\nvar sym2 = Symbol.for(\"b\"); // 从全局的symbol注册?表设置和取得symbol\n\na[sym1] = \"localSymbol\";\na[sym2] = \"globalSymbol\";\n\nvar b = cloneDeep4(a);\nconsole.log(b);\n// {\n// \tname: \"muyiy\",\n// \ta1: undefined,\n//\ta2: null,\n// \ta3: 123,\n// \tbook: {title: \"You Don't Know JS\", price: \"45\"},\n// \tcircleRef: {name: \"muyiy\", book: {…}, a1: undefined, a2: null, a3: 123, …},\n//  [Symbol(a)]: 'localSymbol',\n//  [Symbol(b)]: 'globalSymbol'\n// }\n```\n\n\n第六版 破解递归爆栈 (待研究@todo)\n```javascript\nfunction cloneDeep5(x) {\n    const root = {};\n\n    // 栈\n    const loopList = [\n        {\n            parent: root,\n            key: undefined,\n            data: x,\n        }\n    ];\n\n    while(loopList.length) {\n        // 广度优先\n        const node = loopList.pop();\n        const parent = node.parent;\n        const key = node.key;\n        const data = node.data;\n\n        // 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素\n        let res = parent;\n        if (typeof key !== 'undefined') {\n            res = parent[key] = {};\n        }\n\n        for(let k in data) {\n            if (data.hasOwnProperty(k)) {\n                if (typeof data[k] === 'object') {\n                    // 下一次循环\n                    loopList.push({\n                        parent: res,\n                        key: k,\n                        data: data[k],\n                    });\n                } else {\n                    res[k] = data[k];\n                }\n            }\n        }\n    }\n\n    return root;\n}\n```\n\n\n#### 小语法：\n1 Object.keys(..) 返回一个数组，包含所有可枚举属性\n2 Object.getOwnPropertyNames(..) 返回一个数组，包含所有属性，无论它们是否可枚举\n3 Object.getOwnPropertyDescriptor() 会返回对象的属性的指定描述\n4 in && hasOwnProperty\n```javascript\nvar anotherObject = {\n    a: 1\n};\n// 创建一个关联到 anotherObject 的对象\nvar myObject = Object.create( anotherObject );\nmyObject.b = 2;\n(\"a\" in myObject); // true\n(\"b\" in myObject); // true\nmyObject.hasOwnProperty( \"a\" ); // false\nmyObject.hasOwnProperty( \"b\" ); // true\n\n// (1) in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。\n// (2) hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 原型链。\n```\n5 WeakMap\n特点：弱引用，需以对象作为key，不打扰垃圾回收机制，可以通过set，get来取值\n```javascript\nconst wm1 = new WeakMap(),\n      wm2 = new WeakMap(),\n      wm3 = new WeakMap();\nconst o1 = {},\n      o2 = function(){},\n      o3 = window;\n\nwm1.set(o1, 37);\nwm1.set(o2, \"azerty\");\nwm2.set(o1, o2); // value可以是任意值,包括一个对象或一个函数\nwm2.set(o3, undefined);\nwm2.set(wm1, wm2); // 键和值可以是任意对象,甚至另外一个WeakMap对象\n\nwm1.get(o2); // \"azerty\"\nwm2.get(o2); // undefined,wm2中没有o2这个键\nwm2.get(o3); // undefined,值就是undefined\n\nwm1.has(o2); // true\nwm2.has(o2); // false\nwm2.has(o3); // true (即使值是undefined)\n\nwm3.set(o1, 37);\nwm3.get(o1); // 37\n\nwm1.has(o1);   // true\nwm1.delete(o1);\nwm1.has(o1);   // false\n\n```\n\n\n参考\n[MDN Object.assign](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n[wengjq issue](https://github.com/wengjq/Blog/issues/3)\n[yygmind issue](https://github.com/yygmind/blog/issues/25)\n[yygmind 深浅拷贝汇总](https://github.com/yygmind/blog/labels/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8E%9F%E7%90%86)\n[展开语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax)\n[MDN Object.getOwnPropertyDescription](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)\n[MDN WeakMap](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)\n[神奇的weakmap科普贴](https://www.codenong.com/29413222/)\n[颜海镜](https://segmentfault.com/a/1190000016672263)","slug":"克隆对象&&数组（二）","published":1,"updated":"2020-07-15T15:21:11.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmra60014z5o8fufvcbeh","content":"<h4 id=\"4-深拷贝CODE\"><a href=\"#4-深拷贝CODE\" class=\"headerlink\" title=\"4. 深拷贝CODE\"></a>4. 深拷贝CODE</h4><p><code>深拷贝 = 浅拷贝 + 遇到对象时递归拷贝</code><br>（1）最简单莫过于字符序列化，再parse反序列化<br>语法：JSON.parse(JSON.stringify) </p>\n<div class=\"tip\">\n后端传回的变量一般用它来拷贝足以应对。只是，\n1、会忽略 undefined\n\n<p>2、会忽略 symbol</p>\n<p>3、不能序列化函数</p>\n<p>4、不能解决循环引用的对象</p>\n<p>5、不能正确处理new Date()</p>\n<p>6、不能处理正则</p>\n<p>undefined、symbol 和函数这三种情况，会直接忽略。拷贝函数会undefined，拷贝正则会Object{}，没拷完整。</p>\n</div>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// undefined symbol 函数示例</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'muyiy'</span>,</span><br><span class=\"line\">    a: <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">    b: <span class=\"built_in\">Symbol</span>(<span class=\"string\">'muyiy'</span>),</span><br><span class=\"line\">    c: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj);</span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// \tname: \"muyiy\", </span></span><br><span class=\"line\"><span class=\"comment\">// \ta: undefined, </span></span><br><span class=\"line\"><span class=\"comment\">//  b: Symbol(muyiy), </span></span><br><span class=\"line\"><span class=\"comment\">//  c: ƒ ()</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(obj));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"><span class=\"comment\">// &#123;name: \"muyiy\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 循环引用</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span>,</span><br><span class=\"line\">    b: &#123;</span><br><span class=\"line\">        c: <span class=\"number\">2</span>,</span><br><span class=\"line\">   \t\td: <span class=\"number\">3</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.a = obj.b;</span><br><span class=\"line\">obj.b.c = obj.a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(obj));</span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new Date转化结果不正确 结果方案是转为时间戳</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> date = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).valueOf();</span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(date); </span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(date)); <span class=\"comment\">// 和上面的输出是同一个值</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正则</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">\"muyiy\"</span>,</span><br><span class=\"line\">    a: <span class=\"regexp\">/'123'/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj);</span><br><span class=\"line\"><span class=\"comment\">// &#123;name: \"muyiy\", a: /'123'/&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(obj));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// &#123;name: \"muyiy\", a: &#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>(2) 简易深拷贝</p>\n<p>第一版</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个虽然能简单实现 却有以下问题</span></span><br><span class=\"line\"><span class=\"comment\">// 1、没有对传入参数进行校验，传入 null 时应该返回 null 而不是 &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 2、对于对象的判断逻辑不严谨，因为 typeof null === 'object'</span></span><br><span class=\"line\"><span class=\"comment\">// 3、没有考虑数组的兼容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneDeep1</span>(<span class=\"params\">source</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> target = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> source) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> source[key] === <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">                target[key] = cloneDeep1(source[key]); <span class=\"comment\">// 注意这里 如果是对象的时候递归调用</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                target[key] = source[key];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二版 （非对象的返回自身以及数组的支持）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isObject</span>(<span class=\"params\">obj</span>) </span>&#123;<span class=\"comment\">// 非对象返回自身</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> obj === <span class=\"string\">'object'</span> &amp;&amp; obj != <span class=\"literal\">null</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneDeep2</span>(<span class=\"params\">source</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isObject(source)) <span class=\"keyword\">return</span> source; <span class=\"comment\">// 非对象返回自身</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> target = <span class=\"built_in\">Array</span>.isArray(source) ? [] : &#123;&#125;; <span class=\"comment\">// 初始值为空数组或空对象</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> source) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isObject(source[key])) &#123;</span><br><span class=\"line\">                target[key] = cloneDeep2(source[key]); <span class=\"comment\">// 注意这里</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                target[key] = source[key];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用上面测试用例测试一下</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = cloneDeep2(a);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"><span class=\"comment\">// &#123; </span></span><br><span class=\"line\"><span class=\"comment\">//   name: 'muyiy', </span></span><br><span class=\"line\"><span class=\"comment\">//   book: &#123; title: 'You Don\\'t Know JS', price: '45' &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//   a1: undefined,</span></span><br><span class=\"line\"><span class=\"comment\">//   a2: null,</span></span><br><span class=\"line\"><span class=\"comment\">//   a3: 123</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>第三版 （支持对象循环引用）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneDeep3</span>(<span class=\"params\">source, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isObject(source)) <span class=\"keyword\">return</span> source; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hash.has(source)) <span class=\"keyword\">return</span> hash.get(source); <span class=\"comment\">// 新增代码，查哈希表</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">var</span> target = <span class=\"built_in\">Array</span>.isArray(source) ? [] : &#123;&#125;;</span><br><span class=\"line\">    hash.set(source, target); <span class=\"comment\">// 新增代码，哈希表设值</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> source) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isObject(source[key])) &#123;</span><br><span class=\"line\">                target[key] = cloneDeep3(source[key], hash); <span class=\"comment\">// 新增代码，传入哈希表</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                target[key] = source[key];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;</span><br><span class=\"line\">        name: <span class=\"string\">\"muyiy\"</span>,</span><br><span class=\"line\">        a1: <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">        a2: <span class=\"literal\">null</span>,</span><br><span class=\"line\">        a3: <span class=\"number\">123</span>,</span><br><span class=\"line\">        book: &#123;<span class=\"attr\">title</span>: <span class=\"string\">\"You Don't Know JS\"</span>, <span class=\"attr\">price</span>: <span class=\"string\">\"45\"</span>&#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    a.circleRef = a <span class=\"comment\">// circleRef是个很奇特的属性，它能在自身存自己，并永久循环，</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = cloneDeep3(a)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(b)</span><br></pre></td></tr></table></figure>\n\n<p>第四版 （保存引用关系）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组版</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneDeep3</span>(<span class=\"params\">source, uniqueList</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!isObject(source)) <span class=\"keyword\">return</span> source</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!uniqueList) uniqueList = []</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">var</span> target = <span class=\"built_in\">Array</span>.isArray(source) ? [] : &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">var</span> uniqueData = find(uniqueList, source)</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"comment\">// 数据已经存在，返回保存的数据 如果return这一步，会跳到下方的return target</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span>(uniqueData) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> uniqueData.target</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"comment\">// 数据不存在，保存源数据，以及对应的引用</span></span><br><span class=\"line\">     uniqueList.push(&#123; <span class=\"comment\">// 用数组存储键值对</span></span><br><span class=\"line\">         source: source,</span><br><span class=\"line\">         target: target</span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> source) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(source,key)) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (isObject(source[key])) &#123;</span><br><span class=\"line\">                 target[key] = cloneDeep3(source[key], uniqueList)</span><br><span class=\"line\">             &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                 target[key] = source[key]</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> target <span class=\"comment\">// target很值得玩味，递归完了后的callStack让人惊奇</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"> <span class=\"keyword\">var</span> obj2 = &#123;<span class=\"attr\">a</span>: obj1, <span class=\"attr\">b</span>: obj1&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(obj2.a === obj2.b);</span><br><span class=\"line\"> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> obj3 = cloneDeep3(obj2);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(obj3.a === obj3.b)</span><br><span class=\"line\"> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>第五版 （拷贝Symbol类型）<br>思路就是先查找有没有 Symbol 属性，如果查找到则先遍历处理 Symbol 情况，然后再处理正常情况，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 逻辑代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneDeep4</span>(<span class=\"params\">source, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isObject(source)) <span class=\"keyword\">return</span> source; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hash.has(source)) <span class=\"keyword\">return</span> hash.get(source); </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">let</span> target = <span class=\"built_in\">Array</span>.isArray(source) ? [] : &#123;&#125;;</span><br><span class=\"line\">    hash.set(source, target);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ============= 新增代码</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> symKeys = <span class=\"built_in\">Object</span>.getOwnPropertySymbols(source); <span class=\"comment\">// 查找 </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (symKeys.length) &#123; <span class=\"comment\">// 查找成功\t</span></span><br><span class=\"line\">        symKeys.forEach(<span class=\"function\"><span class=\"params\">symKey</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isObject(source[symKey])) &#123;</span><br><span class=\"line\">                target[symKey] = cloneDeep4(source[symKey], hash); </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                target[symKey] = source[symKey];</span><br><span class=\"line\">            &#125;    </span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// =============</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> source) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isObject(source[key])) &#123;</span><br><span class=\"line\">                target[key] = cloneDeep4(source[key], hash); </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                target[key] = source[key];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试 可以看到成功拷贝了Symbol类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sym1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"a\"</span>); <span class=\"comment\">// 创建新的symbol类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sym2 = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"b\"</span>); <span class=\"comment\">// 从全局的symbol注册?表设置和取得symbol</span></span><br><span class=\"line\"></span><br><span class=\"line\">a[sym1] = <span class=\"string\">\"localSymbol\"</span>;</span><br><span class=\"line\">a[sym2] = <span class=\"string\">\"globalSymbol\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = cloneDeep4(a);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// \tname: \"muyiy\",</span></span><br><span class=\"line\"><span class=\"comment\">// \ta1: undefined,</span></span><br><span class=\"line\"><span class=\"comment\">//\ta2: null,</span></span><br><span class=\"line\"><span class=\"comment\">// \ta3: 123,</span></span><br><span class=\"line\"><span class=\"comment\">// \tbook: &#123;title: \"You Don't Know JS\", price: \"45\"&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// \tcircleRef: &#123;name: \"muyiy\", book: &#123;…&#125;, a1: undefined, a2: null, a3: 123, …&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//  [Symbol(a)]: 'localSymbol',</span></span><br><span class=\"line\"><span class=\"comment\">//  [Symbol(b)]: 'globalSymbol'</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n\n\n<p>第六版 破解递归爆栈 (待研究@todo)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneDeep5</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> root = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 栈</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> loopList = [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            parent: root,</span><br><span class=\"line\">            key: <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">            data: x,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(loopList.length) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 广度优先</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> node = loopList.pop();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> parent = node.parent;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> key = node.key;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = node.data;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> res = parent;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> key !== <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">            res = parent[key] = &#123;&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (data.hasOwnProperty(k)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> data[k] === <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 下一次循环</span></span><br><span class=\"line\">                    loopList.push(&#123;</span><br><span class=\"line\">                        parent: res,</span><br><span class=\"line\">                        key: k,</span><br><span class=\"line\">                        data: data[k],</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    res[k] = data[k];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"小语法：\"><a href=\"#小语法：\" class=\"headerlink\" title=\"小语法：\"></a>小语法：</h4><p>1 Object.keys(..) 返回一个数组，包含所有可枚举属性<br>2 Object.getOwnPropertyNames(..) 返回一个数组，包含所有属性，无论它们是否可枚举<br>3 Object.getOwnPropertyDescriptor() 会返回对象的属性的指定描述<br>4 in &amp;&amp; hasOwnProperty</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> anotherObject = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 创建一个关联到 anotherObject 的对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = <span class=\"built_in\">Object</span>.create( anotherObject );</span><br><span class=\"line\">myObject.b = <span class=\"number\">2</span>;</span><br><span class=\"line\">(<span class=\"string\">\"a\"</span> <span class=\"keyword\">in</span> myObject); <span class=\"comment\">// true</span></span><br><span class=\"line\">(<span class=\"string\">\"b\"</span> <span class=\"keyword\">in</span> myObject); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// false</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"b\"</span> ); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (1) in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。</span></span><br><span class=\"line\"><span class=\"comment\">// (2) hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 原型链。</span></span><br></pre></td></tr></table></figure>\n<p>5 WeakMap<br>特点：弱引用，需以对象作为key，不打扰垃圾回收机制，可以通过set，get来取值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wm1 = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>(),</span><br><span class=\"line\">      wm2 = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>(),</span><br><span class=\"line\">      wm3 = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> o1 = &#123;&#125;,</span><br><span class=\"line\">      o2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</span><br><span class=\"line\">      o3 = <span class=\"built_in\">window</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">wm1.set(o1, <span class=\"number\">37</span>);</span><br><span class=\"line\">wm1.set(o2, <span class=\"string\">\"azerty\"</span>);</span><br><span class=\"line\">wm2.set(o1, o2); <span class=\"comment\">// value可以是任意值,包括一个对象或一个函数</span></span><br><span class=\"line\">wm2.set(o3, <span class=\"literal\">undefined</span>);</span><br><span class=\"line\">wm2.set(wm1, wm2); <span class=\"comment\">// 键和值可以是任意对象,甚至另外一个WeakMap对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">wm1.get(o2); <span class=\"comment\">// \"azerty\"</span></span><br><span class=\"line\">wm2.get(o2); <span class=\"comment\">// undefined,wm2中没有o2这个键</span></span><br><span class=\"line\">wm2.get(o3); <span class=\"comment\">// undefined,值就是undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">wm1.has(o2); <span class=\"comment\">// true</span></span><br><span class=\"line\">wm2.has(o2); <span class=\"comment\">// false</span></span><br><span class=\"line\">wm2.has(o3); <span class=\"comment\">// true (即使值是undefined)</span></span><br><span class=\"line\"></span><br><span class=\"line\">wm3.set(o1, <span class=\"number\">37</span>);</span><br><span class=\"line\">wm3.get(o1); <span class=\"comment\">// 37</span></span><br><span class=\"line\"></span><br><span class=\"line\">wm1.has(o1);   <span class=\"comment\">// true</span></span><br><span class=\"line\">wm1.delete(o1);</span><br><span class=\"line\">wm1.has(o1);   <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n\n<p>参考<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\" rel=\"noopener\">MDN Object.assign</a><br><a href=\"https://github.com/wengjq/Blog/issues/3\" target=\"_blank\" rel=\"noopener\">wengjq issue</a><br><a href=\"https://github.com/yygmind/blog/issues/25\" target=\"_blank\" rel=\"noopener\">yygmind issue</a><br><a href=\"https://github.com/yygmind/blog/labels/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8E%9F%E7%90%86\" target=\"_blank\" rel=\"noopener\">yygmind 深浅拷贝汇总</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax\" target=\"_blank\" rel=\"noopener\">展开语法</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\" target=\"_blank\" rel=\"noopener\">MDN Object.getOwnPropertyDescription</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\" target=\"_blank\" rel=\"noopener\">MDN WeakMap</a><br><a href=\"https://www.codenong.com/29413222/\" target=\"_blank\" rel=\"noopener\">神奇的weakmap科普贴</a><br><a href=\"https://segmentfault.com/a/1190000016672263\" target=\"_blank\" rel=\"noopener\">颜海镜</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"4-深拷贝CODE\"><a href=\"#4-深拷贝CODE\" class=\"headerlink\" title=\"4. 深拷贝CODE\"></a>4. 深拷贝CODE</h4><p><code>深拷贝 = 浅拷贝 + 遇到对象时递归拷贝</code><br>（1）最简单莫过于字符序列化，再parse反序列化<br>语法：JSON.parse(JSON.stringify) </p>\n<div class=\"tip\">\n后端传回的变量一般用它来拷贝足以应对。只是，\n1、会忽略 undefined\n\n<p>2、会忽略 symbol</p>\n<p>3、不能序列化函数</p>\n<p>4、不能解决循环引用的对象</p>\n<p>5、不能正确处理new Date()</p>\n<p>6、不能处理正则</p>\n<p>undefined、symbol 和函数这三种情况，会直接忽略。拷贝函数会undefined，拷贝正则会Object{}，没拷完整。</p>\n</div>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// undefined symbol 函数示例</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'muyiy'</span>,</span><br><span class=\"line\">    a: <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">    b: <span class=\"built_in\">Symbol</span>(<span class=\"string\">'muyiy'</span>),</span><br><span class=\"line\">    c: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj);</span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// \tname: \"muyiy\", </span></span><br><span class=\"line\"><span class=\"comment\">// \ta: undefined, </span></span><br><span class=\"line\"><span class=\"comment\">//  b: Symbol(muyiy), </span></span><br><span class=\"line\"><span class=\"comment\">//  c: ƒ ()</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(obj));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"><span class=\"comment\">// &#123;name: \"muyiy\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 循环引用</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span>,</span><br><span class=\"line\">    b: &#123;</span><br><span class=\"line\">        c: <span class=\"number\">2</span>,</span><br><span class=\"line\">   \t\td: <span class=\"number\">3</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.a = obj.b;</span><br><span class=\"line\">obj.b.c = obj.a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(obj));</span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// new Date转化结果不正确 结果方案是转为时间戳</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> date = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).valueOf();</span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(date); </span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(date)); <span class=\"comment\">// 和上面的输出是同一个值</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正则</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">\"muyiy\"</span>,</span><br><span class=\"line\">    a: <span class=\"regexp\">/'123'/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj);</span><br><span class=\"line\"><span class=\"comment\">// &#123;name: \"muyiy\", a: /'123'/&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(obj));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// &#123;name: \"muyiy\", a: &#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>(2) 简易深拷贝</p>\n<p>第一版</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个虽然能简单实现 却有以下问题</span></span><br><span class=\"line\"><span class=\"comment\">// 1、没有对传入参数进行校验，传入 null 时应该返回 null 而不是 &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 2、对于对象的判断逻辑不严谨，因为 typeof null === 'object'</span></span><br><span class=\"line\"><span class=\"comment\">// 3、没有考虑数组的兼容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneDeep1</span>(<span class=\"params\">source</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> target = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> source) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> source[key] === <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">                target[key] = cloneDeep1(source[key]); <span class=\"comment\">// 注意这里 如果是对象的时候递归调用</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                target[key] = source[key];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二版 （非对象的返回自身以及数组的支持）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isObject</span>(<span class=\"params\">obj</span>) </span>&#123;<span class=\"comment\">// 非对象返回自身</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> obj === <span class=\"string\">'object'</span> &amp;&amp; obj != <span class=\"literal\">null</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneDeep2</span>(<span class=\"params\">source</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isObject(source)) <span class=\"keyword\">return</span> source; <span class=\"comment\">// 非对象返回自身</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> target = <span class=\"built_in\">Array</span>.isArray(source) ? [] : &#123;&#125;; <span class=\"comment\">// 初始值为空数组或空对象</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> source) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isObject(source[key])) &#123;</span><br><span class=\"line\">                target[key] = cloneDeep2(source[key]); <span class=\"comment\">// 注意这里</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                target[key] = source[key];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用上面测试用例测试一下</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = cloneDeep2(a);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"><span class=\"comment\">// &#123; </span></span><br><span class=\"line\"><span class=\"comment\">//   name: 'muyiy', </span></span><br><span class=\"line\"><span class=\"comment\">//   book: &#123; title: 'You Don\\'t Know JS', price: '45' &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//   a1: undefined,</span></span><br><span class=\"line\"><span class=\"comment\">//   a2: null,</span></span><br><span class=\"line\"><span class=\"comment\">//   a3: 123</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>第三版 （支持对象循环引用）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneDeep3</span>(<span class=\"params\">source, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isObject(source)) <span class=\"keyword\">return</span> source; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hash.has(source)) <span class=\"keyword\">return</span> hash.get(source); <span class=\"comment\">// 新增代码，查哈希表</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">var</span> target = <span class=\"built_in\">Array</span>.isArray(source) ? [] : &#123;&#125;;</span><br><span class=\"line\">    hash.set(source, target); <span class=\"comment\">// 新增代码，哈希表设值</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> source) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isObject(source[key])) &#123;</span><br><span class=\"line\">                target[key] = cloneDeep3(source[key], hash); <span class=\"comment\">// 新增代码，传入哈希表</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                target[key] = source[key];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;</span><br><span class=\"line\">        name: <span class=\"string\">\"muyiy\"</span>,</span><br><span class=\"line\">        a1: <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">        a2: <span class=\"literal\">null</span>,</span><br><span class=\"line\">        a3: <span class=\"number\">123</span>,</span><br><span class=\"line\">        book: &#123;<span class=\"attr\">title</span>: <span class=\"string\">\"You Don't Know JS\"</span>, <span class=\"attr\">price</span>: <span class=\"string\">\"45\"</span>&#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    a.circleRef = a <span class=\"comment\">// circleRef是个很奇特的属性，它能在自身存自己，并永久循环，</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = cloneDeep3(a)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(b)</span><br></pre></td></tr></table></figure>\n\n<p>第四版 （保存引用关系）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组版</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneDeep3</span>(<span class=\"params\">source, uniqueList</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!isObject(source)) <span class=\"keyword\">return</span> source</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!uniqueList) uniqueList = []</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">var</span> target = <span class=\"built_in\">Array</span>.isArray(source) ? [] : &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">var</span> uniqueData = find(uniqueList, source)</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"comment\">// 数据已经存在，返回保存的数据 如果return这一步，会跳到下方的return target</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span>(uniqueData) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> uniqueData.target</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"comment\">// 数据不存在，保存源数据，以及对应的引用</span></span><br><span class=\"line\">     uniqueList.push(&#123; <span class=\"comment\">// 用数组存储键值对</span></span><br><span class=\"line\">         source: source,</span><br><span class=\"line\">         target: target</span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> source) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(source,key)) &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (isObject(source[key])) &#123;</span><br><span class=\"line\">                 target[key] = cloneDeep3(source[key], uniqueList)</span><br><span class=\"line\">             &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                 target[key] = source[key]</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> target <span class=\"comment\">// target很值得玩味，递归完了后的callStack让人惊奇</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> obj1 = &#123;&#125;;</span><br><span class=\"line\"> <span class=\"keyword\">var</span> obj2 = &#123;<span class=\"attr\">a</span>: obj1, <span class=\"attr\">b</span>: obj1&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(obj2.a === obj2.b);</span><br><span class=\"line\"> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> obj3 = cloneDeep3(obj2);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(obj3.a === obj3.b)</span><br><span class=\"line\"> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>第五版 （拷贝Symbol类型）<br>思路就是先查找有没有 Symbol 属性，如果查找到则先遍历处理 Symbol 情况，然后再处理正常情况，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 逻辑代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneDeep4</span>(<span class=\"params\">source, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isObject(source)) <span class=\"keyword\">return</span> source; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hash.has(source)) <span class=\"keyword\">return</span> hash.get(source); </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">let</span> target = <span class=\"built_in\">Array</span>.isArray(source) ? [] : &#123;&#125;;</span><br><span class=\"line\">    hash.set(source, target);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// ============= 新增代码</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> symKeys = <span class=\"built_in\">Object</span>.getOwnPropertySymbols(source); <span class=\"comment\">// 查找 </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (symKeys.length) &#123; <span class=\"comment\">// 查找成功\t</span></span><br><span class=\"line\">        symKeys.forEach(<span class=\"function\"><span class=\"params\">symKey</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isObject(source[symKey])) &#123;</span><br><span class=\"line\">                target[symKey] = cloneDeep4(source[symKey], hash); </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                target[symKey] = source[symKey];</span><br><span class=\"line\">            &#125;    </span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// =============</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> source) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isObject(source[key])) &#123;</span><br><span class=\"line\">                target[key] = cloneDeep4(source[key], hash); </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                target[key] = source[key];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试 可以看到成功拷贝了Symbol类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sym1 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"a\"</span>); <span class=\"comment\">// 创建新的symbol类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sym2 = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"b\"</span>); <span class=\"comment\">// 从全局的symbol注册?表设置和取得symbol</span></span><br><span class=\"line\"></span><br><span class=\"line\">a[sym1] = <span class=\"string\">\"localSymbol\"</span>;</span><br><span class=\"line\">a[sym2] = <span class=\"string\">\"globalSymbol\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = cloneDeep4(a);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// \tname: \"muyiy\",</span></span><br><span class=\"line\"><span class=\"comment\">// \ta1: undefined,</span></span><br><span class=\"line\"><span class=\"comment\">//\ta2: null,</span></span><br><span class=\"line\"><span class=\"comment\">// \ta3: 123,</span></span><br><span class=\"line\"><span class=\"comment\">// \tbook: &#123;title: \"You Don't Know JS\", price: \"45\"&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// \tcircleRef: &#123;name: \"muyiy\", book: &#123;…&#125;, a1: undefined, a2: null, a3: 123, …&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//  [Symbol(a)]: 'localSymbol',</span></span><br><span class=\"line\"><span class=\"comment\">//  [Symbol(b)]: 'globalSymbol'</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n\n\n<p>第六版 破解递归爆栈 (待研究@todo)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneDeep5</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> root = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 栈</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> loopList = [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            parent: root,</span><br><span class=\"line\">            key: <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">            data: x,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(loopList.length) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 广度优先</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> node = loopList.pop();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> parent = node.parent;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> key = node.key;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> data = node.data;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> res = parent;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> key !== <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">            res = parent[key] = &#123;&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> data) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (data.hasOwnProperty(k)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> data[k] === <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 下一次循环</span></span><br><span class=\"line\">                    loopList.push(&#123;</span><br><span class=\"line\">                        parent: res,</span><br><span class=\"line\">                        key: k,</span><br><span class=\"line\">                        data: data[k],</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    res[k] = data[k];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"小语法：\"><a href=\"#小语法：\" class=\"headerlink\" title=\"小语法：\"></a>小语法：</h4><p>1 Object.keys(..) 返回一个数组，包含所有可枚举属性<br>2 Object.getOwnPropertyNames(..) 返回一个数组，包含所有属性，无论它们是否可枚举<br>3 Object.getOwnPropertyDescriptor() 会返回对象的属性的指定描述<br>4 in &amp;&amp; hasOwnProperty</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> anotherObject = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 创建一个关联到 anotherObject 的对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = <span class=\"built_in\">Object</span>.create( anotherObject );</span><br><span class=\"line\">myObject.b = <span class=\"number\">2</span>;</span><br><span class=\"line\">(<span class=\"string\">\"a\"</span> <span class=\"keyword\">in</span> myObject); <span class=\"comment\">// true</span></span><br><span class=\"line\">(<span class=\"string\">\"b\"</span> <span class=\"keyword\">in</span> myObject); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"a\"</span> ); <span class=\"comment\">// false</span></span><br><span class=\"line\">myObject.hasOwnProperty( <span class=\"string\">\"b\"</span> ); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (1) in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。</span></span><br><span class=\"line\"><span class=\"comment\">// (2) hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 原型链。</span></span><br></pre></td></tr></table></figure>\n<p>5 WeakMap<br>特点：弱引用，需以对象作为key，不打扰垃圾回收机制，可以通过set，get来取值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wm1 = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>(),</span><br><span class=\"line\">      wm2 = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>(),</span><br><span class=\"line\">      wm3 = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> o1 = &#123;&#125;,</span><br><span class=\"line\">      o2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</span><br><span class=\"line\">      o3 = <span class=\"built_in\">window</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">wm1.set(o1, <span class=\"number\">37</span>);</span><br><span class=\"line\">wm1.set(o2, <span class=\"string\">\"azerty\"</span>);</span><br><span class=\"line\">wm2.set(o1, o2); <span class=\"comment\">// value可以是任意值,包括一个对象或一个函数</span></span><br><span class=\"line\">wm2.set(o3, <span class=\"literal\">undefined</span>);</span><br><span class=\"line\">wm2.set(wm1, wm2); <span class=\"comment\">// 键和值可以是任意对象,甚至另外一个WeakMap对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">wm1.get(o2); <span class=\"comment\">// \"azerty\"</span></span><br><span class=\"line\">wm2.get(o2); <span class=\"comment\">// undefined,wm2中没有o2这个键</span></span><br><span class=\"line\">wm2.get(o3); <span class=\"comment\">// undefined,值就是undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">wm1.has(o2); <span class=\"comment\">// true</span></span><br><span class=\"line\">wm2.has(o2); <span class=\"comment\">// false</span></span><br><span class=\"line\">wm2.has(o3); <span class=\"comment\">// true (即使值是undefined)</span></span><br><span class=\"line\"></span><br><span class=\"line\">wm3.set(o1, <span class=\"number\">37</span>);</span><br><span class=\"line\">wm3.get(o1); <span class=\"comment\">// 37</span></span><br><span class=\"line\"></span><br><span class=\"line\">wm1.has(o1);   <span class=\"comment\">// true</span></span><br><span class=\"line\">wm1.delete(o1);</span><br><span class=\"line\">wm1.has(o1);   <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n\n<p>参考<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\" rel=\"noopener\">MDN Object.assign</a><br><a href=\"https://github.com/wengjq/Blog/issues/3\" target=\"_blank\" rel=\"noopener\">wengjq issue</a><br><a href=\"https://github.com/yygmind/blog/issues/25\" target=\"_blank\" rel=\"noopener\">yygmind issue</a><br><a href=\"https://github.com/yygmind/blog/labels/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8E%9F%E7%90%86\" target=\"_blank\" rel=\"noopener\">yygmind 深浅拷贝汇总</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax\" target=\"_blank\" rel=\"noopener\">展开语法</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\" target=\"_blank\" rel=\"noopener\">MDN Object.getOwnPropertyDescription</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap\" target=\"_blank\" rel=\"noopener\">MDN WeakMap</a><br><a href=\"https://www.codenong.com/29413222/\" target=\"_blank\" rel=\"noopener\">神奇的weakmap科普贴</a><br><a href=\"https://segmentfault.com/a/1190000016672263\" target=\"_blank\" rel=\"noopener\">颜海镜</a></p>\n"},{"title":"小程序入门","date":"2019-08-05T15:32:04.000Z","_content":"\n- 目录结构\n- 页面结构\n\n### 正文\n目录结构如图：\n ![image](https://raw.githubusercontent.com/jonnzer/saveImgForYun/master/a646ddf246beb349e404ba97e137473.png)\n---\n1.`components文件夹`：存放自定义的组件、封装的组件。\n\n2.`custom-tab-bar`: 如名，它就是自定义的tab-bar。\n\n3.`img`：如名, 它就是存放图片的。  \n\n4.`pages`：最核心的，是存放我们的页面。\n\n![image](https://raw.githubusercontent.com/jonnzer/saveImgForYun/master/6237ce1f0d8810a3bcf79d5c3ff65eb.png)\n\n如图 ，index文件夹中，就包含四个这样名字的js,json,wxml,wxss 其中的json是定义页面的自定义信息，包含页面标题，引用组件，背景颜色等等\n\n5.`service`: 存放了工具函数，如全局存储，登录封装，api相关地址以及请求封装，还有一些根据业务的处理字符串或者对象的方法（包括正则）。\n\n6.`app.json`：全局的配置,标题，背景，底部tabBar，页面路由，定位允许，appid授权（简单理解，就是一个配置文件）\n\n7.`app.js`: 每个小程序都需要在 app.js 中调用 App 方法注册小程序示例，绑定生命周期回调函数。\n\n8.`project.config.json`: 小程序开发工具的顶上的编译入口文件，可以在里面定义好路径，刷新也只是刷新指定页面，减少调试步骤。\n\n--- \n页面结构\n+ 1.`wxml`: \n    - 常用标签略微有点不一样，web开发常用的div，换成它的****view****标签。span换成它的**text**标签。\n    图片标签换成**image**标签，属性一样，用法一样。\n    - 谈下**cover-view**这个标签，它是可以在`map`、`video`、`canvas`、`camera`、`live-player`、`live-pusher`等等之上的渲染的标签。这时候**view**标签表示无能为力的。\n+ 2.`wxss`:\n    - 单位：px单位换成rpx,适配设备的单位，这个是真香，不用再换算。\n    - flex布局支持。\n+ 3.`js`:\n    - 页面组件的js结构：\n    ```javascript\n    // import utils\n     Page({\n      data: { // 页面所需变量\n    \t},\n      onShow: function() {\n      \n      },\n      onLoad: function() {\n       // fetch data\n      },\n      customEvent: function () { // 自己定义的触发函数\n      \n      },\n   })       \n    ```\n     --- \n    - 自定义组件的js结构： \n     ```javascript\n      // import utils\n      Component({\n          properties: {\n        \tsomething: { // 父组件传过来的\n      \t    \ttype: String,\n          \t}\n          },\n          data:{\n        \t\n          },\n          ready() {\n        \t\n          },\n          attached() {\n        \t\n          },\n          methods: {\n        \tmethods1: function() {\n      \t  \n      \t    },\n    \t    methods2: function() {\n  \t      \n  \t        },\n\t         // ...\n          }\n      })\n    ```\n [官方API](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html)\n [小程序组件化API介绍](https://juejin.im/entry/5a676b3ff265da3e4f0a5215)\n     \n+ 4.`json`\n\n\n\n\n","source":"_posts/小程序入门篇.md","raw":"---\ntitle: 小程序入门\ndate: 2019-08-05 23:32:04\ntags: 小程序\n---\n\n- 目录结构\n- 页面结构\n\n### 正文\n目录结构如图：\n ![image](https://raw.githubusercontent.com/jonnzer/saveImgForYun/master/a646ddf246beb349e404ba97e137473.png)\n---\n1.`components文件夹`：存放自定义的组件、封装的组件。\n\n2.`custom-tab-bar`: 如名，它就是自定义的tab-bar。\n\n3.`img`：如名, 它就是存放图片的。  \n\n4.`pages`：最核心的，是存放我们的页面。\n\n![image](https://raw.githubusercontent.com/jonnzer/saveImgForYun/master/6237ce1f0d8810a3bcf79d5c3ff65eb.png)\n\n如图 ，index文件夹中，就包含四个这样名字的js,json,wxml,wxss 其中的json是定义页面的自定义信息，包含页面标题，引用组件，背景颜色等等\n\n5.`service`: 存放了工具函数，如全局存储，登录封装，api相关地址以及请求封装，还有一些根据业务的处理字符串或者对象的方法（包括正则）。\n\n6.`app.json`：全局的配置,标题，背景，底部tabBar，页面路由，定位允许，appid授权（简单理解，就是一个配置文件）\n\n7.`app.js`: 每个小程序都需要在 app.js 中调用 App 方法注册小程序示例，绑定生命周期回调函数。\n\n8.`project.config.json`: 小程序开发工具的顶上的编译入口文件，可以在里面定义好路径，刷新也只是刷新指定页面，减少调试步骤。\n\n--- \n页面结构\n+ 1.`wxml`: \n    - 常用标签略微有点不一样，web开发常用的div，换成它的****view****标签。span换成它的**text**标签。\n    图片标签换成**image**标签，属性一样，用法一样。\n    - 谈下**cover-view**这个标签，它是可以在`map`、`video`、`canvas`、`camera`、`live-player`、`live-pusher`等等之上的渲染的标签。这时候**view**标签表示无能为力的。\n+ 2.`wxss`:\n    - 单位：px单位换成rpx,适配设备的单位，这个是真香，不用再换算。\n    - flex布局支持。\n+ 3.`js`:\n    - 页面组件的js结构：\n    ```javascript\n    // import utils\n     Page({\n      data: { // 页面所需变量\n    \t},\n      onShow: function() {\n      \n      },\n      onLoad: function() {\n       // fetch data\n      },\n      customEvent: function () { // 自己定义的触发函数\n      \n      },\n   })       \n    ```\n     --- \n    - 自定义组件的js结构： \n     ```javascript\n      // import utils\n      Component({\n          properties: {\n        \tsomething: { // 父组件传过来的\n      \t    \ttype: String,\n          \t}\n          },\n          data:{\n        \t\n          },\n          ready() {\n        \t\n          },\n          attached() {\n        \t\n          },\n          methods: {\n        \tmethods1: function() {\n      \t  \n      \t    },\n    \t    methods2: function() {\n  \t      \n  \t        },\n\t         // ...\n          }\n      })\n    ```\n [官方API](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html)\n [小程序组件化API介绍](https://juejin.im/entry/5a676b3ff265da3e4f0a5215)\n     \n+ 4.`json`\n\n\n\n\n","slug":"小程序入门篇","published":1,"updated":"2019-12-03T03:14:07.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmra90017z5o8g9bi7adj","content":"<ul>\n<li>目录结构</li>\n<li>页面结构</li>\n</ul>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>目录结构如图：<br> <img src=\"https://raw.githubusercontent.com/jonnzer/saveImgForYun/master/a646ddf246beb349e404ba97e137473.png\" alt=\"image\"></p>\n<hr>\n<p>1.<code>components文件夹</code>：存放自定义的组件、封装的组件。</p>\n<p>2.<code>custom-tab-bar</code>: 如名，它就是自定义的tab-bar。</p>\n<p>3.<code>img</code>：如名, 它就是存放图片的。  </p>\n<p>4.<code>pages</code>：最核心的，是存放我们的页面。</p>\n<p><img src=\"https://raw.githubusercontent.com/jonnzer/saveImgForYun/master/6237ce1f0d8810a3bcf79d5c3ff65eb.png\" alt=\"image\"></p>\n<p>如图 ，index文件夹中，就包含四个这样名字的js,json,wxml,wxss 其中的json是定义页面的自定义信息，包含页面标题，引用组件，背景颜色等等</p>\n<p>5.<code>service</code>: 存放了工具函数，如全局存储，登录封装，api相关地址以及请求封装，还有一些根据业务的处理字符串或者对象的方法（包括正则）。</p>\n<p>6.<code>app.json</code>：全局的配置,标题，背景，底部tabBar，页面路由，定位允许，appid授权（简单理解，就是一个配置文件）</p>\n<p>7.<code>app.js</code>: 每个小程序都需要在 app.js 中调用 App 方法注册小程序示例，绑定生命周期回调函数。</p>\n<p>8.<code>project.config.json</code>: 小程序开发工具的顶上的编译入口文件，可以在里面定义好路径，刷新也只是刷新指定页面，减少调试步骤。</p>\n<hr>\n<p>页面结构</p>\n<ul>\n<li><p>1.<code>wxml</code>: </p>\n<ul>\n<li>常用标签略微有点不一样，web开发常用的div，换成它的<strong><strong>view</strong></strong>标签。span换成它的<strong>text</strong>标签。<br>图片标签换成<strong>image</strong>标签，属性一样，用法一样。</li>\n<li>谈下<strong>cover-view</strong>这个标签，它是可以在<code>map</code>、<code>video</code>、<code>canvas</code>、<code>camera</code>、<code>live-player</code>、<code>live-pusher</code>等等之上的渲染的标签。这时候<strong>view</strong>标签表示无能为力的。</li>\n</ul>\n</li>\n<li><p>2.<code>wxss</code>:</p>\n<ul>\n<li>单位：px单位换成rpx,适配设备的单位，这个是真香，不用再换算。</li>\n<li>flex布局支持。</li>\n</ul>\n</li>\n<li><p>3.<code>js</code>:</p>\n<ul>\n<li>页面组件的js结构：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// import utils</span></span><br><span class=\"line\">  Page(&#123;</span><br><span class=\"line\">   data: &#123; <span class=\"comment\">// 页面所需变量</span></span><br><span class=\"line\"> \t&#125;,</span><br><span class=\"line\">   onShow: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   onLoad: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// fetch data</span></span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   customEvent: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 自己定义的触发函数</span></span><br><span class=\"line\">   </span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<hr>\n</li>\n<li>自定义组件的js结构： <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import utils</span></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    properties: &#123;</span><br><span class=\"line\">  \tsomething: &#123; <span class=\"comment\">// 父组件传过来的</span></span><br><span class=\"line\">\t    \ttype: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    data:&#123;</span><br><span class=\"line\">  \t</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ready() &#123;</span><br><span class=\"line\">  \t</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    attached() &#123;</span><br><span class=\"line\">  \t</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">  \tmethods1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t    &#125;,</span><br><span class=\"line\">   methods2: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html\" target=\"_blank\" rel=\"noopener\">官方API</a><br><a href=\"https://juejin.im/entry/5a676b3ff265da3e4f0a5215\" target=\"_blank\" rel=\"noopener\">小程序组件化API介绍</a></li>\n</ul>\n</li>\n<li><p>4.<code>json</code></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>目录结构</li>\n<li>页面结构</li>\n</ul>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>目录结构如图：<br> <img src=\"https://raw.githubusercontent.com/jonnzer/saveImgForYun/master/a646ddf246beb349e404ba97e137473.png\" alt=\"image\"></p>\n<hr>\n<p>1.<code>components文件夹</code>：存放自定义的组件、封装的组件。</p>\n<p>2.<code>custom-tab-bar</code>: 如名，它就是自定义的tab-bar。</p>\n<p>3.<code>img</code>：如名, 它就是存放图片的。  </p>\n<p>4.<code>pages</code>：最核心的，是存放我们的页面。</p>\n<p><img src=\"https://raw.githubusercontent.com/jonnzer/saveImgForYun/master/6237ce1f0d8810a3bcf79d5c3ff65eb.png\" alt=\"image\"></p>\n<p>如图 ，index文件夹中，就包含四个这样名字的js,json,wxml,wxss 其中的json是定义页面的自定义信息，包含页面标题，引用组件，背景颜色等等</p>\n<p>5.<code>service</code>: 存放了工具函数，如全局存储，登录封装，api相关地址以及请求封装，还有一些根据业务的处理字符串或者对象的方法（包括正则）。</p>\n<p>6.<code>app.json</code>：全局的配置,标题，背景，底部tabBar，页面路由，定位允许，appid授权（简单理解，就是一个配置文件）</p>\n<p>7.<code>app.js</code>: 每个小程序都需要在 app.js 中调用 App 方法注册小程序示例，绑定生命周期回调函数。</p>\n<p>8.<code>project.config.json</code>: 小程序开发工具的顶上的编译入口文件，可以在里面定义好路径，刷新也只是刷新指定页面，减少调试步骤。</p>\n<hr>\n<p>页面结构</p>\n<ul>\n<li><p>1.<code>wxml</code>: </p>\n<ul>\n<li>常用标签略微有点不一样，web开发常用的div，换成它的<strong><strong>view</strong></strong>标签。span换成它的<strong>text</strong>标签。<br>图片标签换成<strong>image</strong>标签，属性一样，用法一样。</li>\n<li>谈下<strong>cover-view</strong>这个标签，它是可以在<code>map</code>、<code>video</code>、<code>canvas</code>、<code>camera</code>、<code>live-player</code>、<code>live-pusher</code>等等之上的渲染的标签。这时候<strong>view</strong>标签表示无能为力的。</li>\n</ul>\n</li>\n<li><p>2.<code>wxss</code>:</p>\n<ul>\n<li>单位：px单位换成rpx,适配设备的单位，这个是真香，不用再换算。</li>\n<li>flex布局支持。</li>\n</ul>\n</li>\n<li><p>3.<code>js</code>:</p>\n<ul>\n<li>页面组件的js结构：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// import utils</span></span><br><span class=\"line\">  Page(&#123;</span><br><span class=\"line\">   data: &#123; <span class=\"comment\">// 页面所需变量</span></span><br><span class=\"line\"> \t&#125;,</span><br><span class=\"line\">   onShow: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   onLoad: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// fetch data</span></span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   customEvent: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 自己定义的触发函数</span></span><br><span class=\"line\">   </span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<hr>\n</li>\n<li>自定义组件的js结构： <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import utils</span></span><br><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    properties: &#123;</span><br><span class=\"line\">  \tsomething: &#123; <span class=\"comment\">// 父组件传过来的</span></span><br><span class=\"line\">\t    \ttype: <span class=\"built_in\">String</span>,</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    data:&#123;</span><br><span class=\"line\">  \t</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    ready() &#123;</span><br><span class=\"line\">  \t</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    attached() &#123;</span><br><span class=\"line\">  \t</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">  \tmethods1: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t  </span><br><span class=\"line\">\t    &#125;,</span><br><span class=\"line\">   methods2: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html\" target=\"_blank\" rel=\"noopener\">官方API</a><br><a href=\"https://juejin.im/entry/5a676b3ff265da3e4f0a5215\" target=\"_blank\" rel=\"noopener\">小程序组件化API介绍</a></li>\n</ul>\n</li>\n<li><p>4.<code>json</code></p>\n</li>\n</ul>\n"},{"title":"数组去重","date":"2019-02-25T07:53:23.000Z","_content":"\n> 我们时常遇见数组去重的需求，或是后台给的数据重了，或是前端生成数据的时候重了，这时候往往需要处理下，那下面我归纳下各种解决方案吧🧐：\n\n```js\n// 先给出几组测试数组\nlet includeObjArr = [ // 待检测数组（含对象）\n    {\n        id: 11,\n        name: 'wang'\n    },\n    {\n        id: 11,\n        name: 'wang'\n    },\n    {\n        id:12,\n        name: 'zhong'\n    },\n    {\n        id: 11,\n        name: 'zhong'\n    }\n];\nlet includeNumArr =  [3, 62, 3, 38, 20, 42, 14, 5, 38, 29, 42]; // 只含数字的简单数组\n```\n\n### 1. 利用ES6的API Set和 Array\n```js\n/*\n* es6 api的解决方案\n* @param targetArr\n* @returns {any[]}\n*/\nfunction uniqueArray(targetArr){\n    return Array.from(new Set(targetArr));\n}\n```\n###### 结论：只能用于包含简单数字的数组去重\n\n### 2. 利用array.splice\n```js\n/*\n* es6 api的解决方案\n* @param arr\n* @returns {any[]}\n*/\nfunction uniqueArray(arr){ \n    for(var i = 0; i < arr.length - 1; i++){ \n      for(var j = i + 1; j < arr.length; j++){ \n            if(arr[j] === arr[i]){ \n                arr.splice(j--, 1); \n                } \n              } \n            } \n          return arr;\n         }\n```\n###### 结论：只能用于包含简单数字的数组去重\n\n### 3. 利用哈希表\n```js\n/**\n* 对象存储的是引用而原始变量存储的是值。\n* 因为哈希表在Javascript里是一个简单的Object，它的key永远是String类型。这意味着我们不能区分字符串和数字表示的相同的值，如1和'1'。\n* 然而，因为我们使用的JSON.stringify，String类型的key 将会被存储为一个字符串值，这样hashTable的key就唯一了。\n* 这意味着相同的值，但不同类型的元素，将以原来的格式保留。\n* @param arr\n* @returns {Array}\n*/\nfunction dedup(arr) {\n\tvar hashTable = {};\n\n\treturn arr.filter(function (el) {\n\t\tvar key = JSON.stringify(el);\n\t\tvar match = Boolean(hashTable[key]);\n\n\t\treturn (match ? false : hashTable[key] = true);\n\t});\n}\n\n```\n###### 结论：可用于包含复杂类型的数组去重\n\n---\n\n### 4. 利用对象中key的唯一\n```js\nfunction unique(arr) {\n    var ret = [];\n    var len = arr.length;\n    var tmp = {};\n    var tmpKey;\n    for(var i=0; i<len; i++){\n        tmpKey = typeof arr[i] + JSON.stringify(arr[i]);\n        if(!tmp[tmpKey]){\n            tmp[tmpKey] = 1;\n            ret.push(arr[i]);\n        }\n    }\n    return ret;\n}\n```\n###### 结论：可用于包含复杂类型的数组去重\n\n###### 参考链接：\n[jstips](http://www.jstips.co/zh_cn/javascript/deduplicate-an-array/)\n[blog](https://github.com/lifesinger/blog/issues/113)\n[blog](https://github.com/hanzichi/underscore-analysis/issues/9)\n\n\n\n","source":"_posts/数组去重.md","raw":"---\ntitle: 数组去重\ndate: 2019-02-25 15:53:23\ntags: Array\n---\n\n> 我们时常遇见数组去重的需求，或是后台给的数据重了，或是前端生成数据的时候重了，这时候往往需要处理下，那下面我归纳下各种解决方案吧🧐：\n\n```js\n// 先给出几组测试数组\nlet includeObjArr = [ // 待检测数组（含对象）\n    {\n        id: 11,\n        name: 'wang'\n    },\n    {\n        id: 11,\n        name: 'wang'\n    },\n    {\n        id:12,\n        name: 'zhong'\n    },\n    {\n        id: 11,\n        name: 'zhong'\n    }\n];\nlet includeNumArr =  [3, 62, 3, 38, 20, 42, 14, 5, 38, 29, 42]; // 只含数字的简单数组\n```\n\n### 1. 利用ES6的API Set和 Array\n```js\n/*\n* es6 api的解决方案\n* @param targetArr\n* @returns {any[]}\n*/\nfunction uniqueArray(targetArr){\n    return Array.from(new Set(targetArr));\n}\n```\n###### 结论：只能用于包含简单数字的数组去重\n\n### 2. 利用array.splice\n```js\n/*\n* es6 api的解决方案\n* @param arr\n* @returns {any[]}\n*/\nfunction uniqueArray(arr){ \n    for(var i = 0; i < arr.length - 1; i++){ \n      for(var j = i + 1; j < arr.length; j++){ \n            if(arr[j] === arr[i]){ \n                arr.splice(j--, 1); \n                } \n              } \n            } \n          return arr;\n         }\n```\n###### 结论：只能用于包含简单数字的数组去重\n\n### 3. 利用哈希表\n```js\n/**\n* 对象存储的是引用而原始变量存储的是值。\n* 因为哈希表在Javascript里是一个简单的Object，它的key永远是String类型。这意味着我们不能区分字符串和数字表示的相同的值，如1和'1'。\n* 然而，因为我们使用的JSON.stringify，String类型的key 将会被存储为一个字符串值，这样hashTable的key就唯一了。\n* 这意味着相同的值，但不同类型的元素，将以原来的格式保留。\n* @param arr\n* @returns {Array}\n*/\nfunction dedup(arr) {\n\tvar hashTable = {};\n\n\treturn arr.filter(function (el) {\n\t\tvar key = JSON.stringify(el);\n\t\tvar match = Boolean(hashTable[key]);\n\n\t\treturn (match ? false : hashTable[key] = true);\n\t});\n}\n\n```\n###### 结论：可用于包含复杂类型的数组去重\n\n---\n\n### 4. 利用对象中key的唯一\n```js\nfunction unique(arr) {\n    var ret = [];\n    var len = arr.length;\n    var tmp = {};\n    var tmpKey;\n    for(var i=0; i<len; i++){\n        tmpKey = typeof arr[i] + JSON.stringify(arr[i]);\n        if(!tmp[tmpKey]){\n            tmp[tmpKey] = 1;\n            ret.push(arr[i]);\n        }\n    }\n    return ret;\n}\n```\n###### 结论：可用于包含复杂类型的数组去重\n\n###### 参考链接：\n[jstips](http://www.jstips.co/zh_cn/javascript/deduplicate-an-array/)\n[blog](https://github.com/lifesinger/blog/issues/113)\n[blog](https://github.com/hanzichi/underscore-analysis/issues/9)\n\n\n\n","slug":"数组去重","published":1,"updated":"2019-03-16T12:29:03.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmraa0018z5o84zqs8tpv","content":"<blockquote>\n<p>我们时常遇见数组去重的需求，或是后台给的数据重了，或是前端生成数据的时候重了，这时候往往需要处理下，那下面我归纳下各种解决方案吧🧐：</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 先给出几组测试数组</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> includeObjArr = [ <span class=\"comment\">// 待检测数组（含对象）</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        id: <span class=\"number\">11</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'wang'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        id: <span class=\"number\">11</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'wang'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        id:<span class=\"number\">12</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'zhong'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        id: <span class=\"number\">11</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'zhong'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">let</span> includeNumArr =  [<span class=\"number\">3</span>, <span class=\"number\">62</span>, <span class=\"number\">3</span>, <span class=\"number\">38</span>, <span class=\"number\">20</span>, <span class=\"number\">42</span>, <span class=\"number\">14</span>, <span class=\"number\">5</span>, <span class=\"number\">38</span>, <span class=\"number\">29</span>, <span class=\"number\">42</span>]; <span class=\"comment\">// 只含数字的简单数组</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-利用ES6的API-Set和-Array\"><a href=\"#1-利用ES6的API-Set和-Array\" class=\"headerlink\" title=\"1. 利用ES6的API Set和 Array\"></a>1. 利用ES6的API Set和 Array</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* es6 api的解决方案</span></span><br><span class=\"line\"><span class=\"comment\">* @param targetArr</span></span><br><span class=\"line\"><span class=\"comment\">* @returns &#123;any[]&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniqueArray</span>(<span class=\"params\">targetArr</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(targetArr));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"结论：只能用于包含简单数字的数组去重\"><a href=\"#结论：只能用于包含简单数字的数组去重\" class=\"headerlink\" title=\"结论：只能用于包含简单数字的数组去重\"></a>结论：只能用于包含简单数字的数组去重</h6><h3 id=\"2-利用array-splice\"><a href=\"#2-利用array-splice\" class=\"headerlink\" title=\"2. 利用array.splice\"></a>2. 利用array.splice</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* es6 api的解决方案</span></span><br><span class=\"line\"><span class=\"comment\">* @param arr</span></span><br><span class=\"line\"><span class=\"comment\">* @returns &#123;any[]&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniqueArray</span>(<span class=\"params\">arr</span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length - <span class=\"number\">1</span>; i++)&#123; </span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span>; j &lt; arr.length; j++)&#123; </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] === arr[i])&#123; </span><br><span class=\"line\">                arr.splice(j--, <span class=\"number\">1</span>); </span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">              &#125; </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">          <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">         &#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"结论：只能用于包含简单数字的数组去重-1\"><a href=\"#结论：只能用于包含简单数字的数组去重-1\" class=\"headerlink\" title=\"结论：只能用于包含简单数字的数组去重\"></a>结论：只能用于包含简单数字的数组去重</h6><h3 id=\"3-利用哈希表\"><a href=\"#3-利用哈希表\" class=\"headerlink\" title=\"3. 利用哈希表\"></a>3. 利用哈希表</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 对象存储的是引用而原始变量存储的是值。</span></span><br><span class=\"line\"><span class=\"comment\">* 因为哈希表在Javascript里是一个简单的Object，它的key永远是String类型。这意味着我们不能区分字符串和数字表示的相同的值，如1和'1'。</span></span><br><span class=\"line\"><span class=\"comment\">* 然而，因为我们使用的JSON.stringify，String类型的key 将会被存储为一个字符串值，这样hashTable的key就唯一了。</span></span><br><span class=\"line\"><span class=\"comment\">* 这意味着相同的值，但不同类型的元素，将以原来的格式保留。</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param <span class=\"variable\">arr</span></span></span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@returns <span class=\"type\">&#123;Array&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dedup</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> hashTable = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arr.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> key = <span class=\"built_in\">JSON</span>.stringify(el);</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> match = <span class=\"built_in\">Boolean</span>(hashTable[key]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (match ? <span class=\"literal\">false</span> : hashTable[key] = <span class=\"literal\">true</span>);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"结论：可用于包含复杂类型的数组去重\"><a href=\"#结论：可用于包含复杂类型的数组去重\" class=\"headerlink\" title=\"结论：可用于包含复杂类型的数组去重\"></a>结论：可用于包含复杂类型的数组去重</h6><hr>\n<h3 id=\"4-利用对象中key的唯一\"><a href=\"#4-利用对象中key的唯一\" class=\"headerlink\" title=\"4. 利用对象中key的唯一\"></a>4. 利用对象中key的唯一</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmpKey;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;len; i++)&#123;</span><br><span class=\"line\">        tmpKey = <span class=\"keyword\">typeof</span> arr[i] + <span class=\"built_in\">JSON</span>.stringify(arr[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!tmp[tmpKey])&#123;</span><br><span class=\"line\">            tmp[tmpKey] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            ret.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"结论：可用于包含复杂类型的数组去重-1\"><a href=\"#结论：可用于包含复杂类型的数组去重-1\" class=\"headerlink\" title=\"结论：可用于包含复杂类型的数组去重\"></a>结论：可用于包含复杂类型的数组去重</h6><h6 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h6><p><a href=\"http://www.jstips.co/zh_cn/javascript/deduplicate-an-array/\" target=\"_blank\" rel=\"noopener\">jstips</a><br><a href=\"https://github.com/lifesinger/blog/issues/113\" target=\"_blank\" rel=\"noopener\">blog</a><br><a href=\"https://github.com/hanzichi/underscore-analysis/issues/9\" target=\"_blank\" rel=\"noopener\">blog</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>我们时常遇见数组去重的需求，或是后台给的数据重了，或是前端生成数据的时候重了，这时候往往需要处理下，那下面我归纳下各种解决方案吧🧐：</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 先给出几组测试数组</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> includeObjArr = [ <span class=\"comment\">// 待检测数组（含对象）</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        id: <span class=\"number\">11</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'wang'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        id: <span class=\"number\">11</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'wang'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        id:<span class=\"number\">12</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'zhong'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        id: <span class=\"number\">11</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'zhong'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">let</span> includeNumArr =  [<span class=\"number\">3</span>, <span class=\"number\">62</span>, <span class=\"number\">3</span>, <span class=\"number\">38</span>, <span class=\"number\">20</span>, <span class=\"number\">42</span>, <span class=\"number\">14</span>, <span class=\"number\">5</span>, <span class=\"number\">38</span>, <span class=\"number\">29</span>, <span class=\"number\">42</span>]; <span class=\"comment\">// 只含数字的简单数组</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-利用ES6的API-Set和-Array\"><a href=\"#1-利用ES6的API-Set和-Array\" class=\"headerlink\" title=\"1. 利用ES6的API Set和 Array\"></a>1. 利用ES6的API Set和 Array</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* es6 api的解决方案</span></span><br><span class=\"line\"><span class=\"comment\">* @param targetArr</span></span><br><span class=\"line\"><span class=\"comment\">* @returns &#123;any[]&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniqueArray</span>(<span class=\"params\">targetArr</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(targetArr));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"结论：只能用于包含简单数字的数组去重\"><a href=\"#结论：只能用于包含简单数字的数组去重\" class=\"headerlink\" title=\"结论：只能用于包含简单数字的数组去重\"></a>结论：只能用于包含简单数字的数组去重</h6><h3 id=\"2-利用array-splice\"><a href=\"#2-利用array-splice\" class=\"headerlink\" title=\"2. 利用array.splice\"></a>2. 利用array.splice</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* es6 api的解决方案</span></span><br><span class=\"line\"><span class=\"comment\">* @param arr</span></span><br><span class=\"line\"><span class=\"comment\">* @returns &#123;any[]&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniqueArray</span>(<span class=\"params\">arr</span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length - <span class=\"number\">1</span>; i++)&#123; </span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span>; j &lt; arr.length; j++)&#123; </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] === arr[i])&#123; </span><br><span class=\"line\">                arr.splice(j--, <span class=\"number\">1</span>); </span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">              &#125; </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">          <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">         &#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"结论：只能用于包含简单数字的数组去重-1\"><a href=\"#结论：只能用于包含简单数字的数组去重-1\" class=\"headerlink\" title=\"结论：只能用于包含简单数字的数组去重\"></a>结论：只能用于包含简单数字的数组去重</h6><h3 id=\"3-利用哈希表\"><a href=\"#3-利用哈希表\" class=\"headerlink\" title=\"3. 利用哈希表\"></a>3. 利用哈希表</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 对象存储的是引用而原始变量存储的是值。</span></span><br><span class=\"line\"><span class=\"comment\">* 因为哈希表在Javascript里是一个简单的Object，它的key永远是String类型。这意味着我们不能区分字符串和数字表示的相同的值，如1和'1'。</span></span><br><span class=\"line\"><span class=\"comment\">* 然而，因为我们使用的JSON.stringify，String类型的key 将会被存储为一个字符串值，这样hashTable的key就唯一了。</span></span><br><span class=\"line\"><span class=\"comment\">* 这意味着相同的值，但不同类型的元素，将以原来的格式保留。</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param <span class=\"variable\">arr</span></span></span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@returns <span class=\"type\">&#123;Array&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dedup</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> hashTable = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arr.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> key = <span class=\"built_in\">JSON</span>.stringify(el);</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> match = <span class=\"built_in\">Boolean</span>(hashTable[key]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (match ? <span class=\"literal\">false</span> : hashTable[key] = <span class=\"literal\">true</span>);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"结论：可用于包含复杂类型的数组去重\"><a href=\"#结论：可用于包含复杂类型的数组去重\" class=\"headerlink\" title=\"结论：可用于包含复杂类型的数组去重\"></a>结论：可用于包含复杂类型的数组去重</h6><hr>\n<h3 id=\"4-利用对象中key的唯一\"><a href=\"#4-利用对象中key的唯一\" class=\"headerlink\" title=\"4. 利用对象中key的唯一\"></a>4. 利用对象中key的唯一</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmpKey;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;len; i++)&#123;</span><br><span class=\"line\">        tmpKey = <span class=\"keyword\">typeof</span> arr[i] + <span class=\"built_in\">JSON</span>.stringify(arr[i]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!tmp[tmpKey])&#123;</span><br><span class=\"line\">            tmp[tmpKey] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            ret.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id=\"结论：可用于包含复杂类型的数组去重-1\"><a href=\"#结论：可用于包含复杂类型的数组去重-1\" class=\"headerlink\" title=\"结论：可用于包含复杂类型的数组去重\"></a>结论：可用于包含复杂类型的数组去重</h6><h6 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h6><p><a href=\"http://www.jstips.co/zh_cn/javascript/deduplicate-an-array/\" target=\"_blank\" rel=\"noopener\">jstips</a><br><a href=\"https://github.com/lifesinger/blog/issues/113\" target=\"_blank\" rel=\"noopener\">blog</a><br><a href=\"https://github.com/hanzichi/underscore-analysis/issues/9\" target=\"_blank\" rel=\"noopener\">blog</a></p>\n"},{"title":"浏览器-输入url系列","date":"2020-03-13T07:03:39.000Z","_content":"\n> 共是五个步骤\n\n### 1 浏览器的搜索框\n浏览器会根据输入的内容，去匹配是用对应的引擎搜索内容，还是直接跳转url。\n详细的讲，就是\n- 搜索内容+默认搜索引擎，形成新的URL\n- 符合URL规则的话，在输入内容基础上加上协议，形成新的URL\n\n### 2 dns解析\n- 自己的理解：路由解析，找到背后的ip地址，路由缓存，域名缓存，为什么第二次加载会更快，跟这个有关。\n- dns：一个域名与ip地址相互映射的分布式数据库\n- 我们无法记住的ip，那一个个长相平凡但是堆积在一起就是记不住的几个数字，是的，dns帮我们记住了。他以电话簿的形式，记住了许许多多的ip地址，映射到了所有网站上。\n- 在客户端输入 URL 后，会有一个递归查找的过程，从浏览器缓存中查找->本地的hosts文件查找->找本地DNS解析器缓存查找->本地DNS服务器查找，这个过程中任何一步找到了都会结束查找流程。\n- 本地dns服务器找不到的时候，去查询其他根dns服务器，顶级域服务器，权威dns服务器\n- 查找的过程是有优化的地方：\n    + DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 \n    + 在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。\n    + 补充：域名与ip之间有映射关系，但是大多数情况下却不是一一对应的，我们可以将多个ip映射到同一个域名，因为用户是通过域名去进行访问的，具体访问哪个地址，则有DNS服务器的映射记录和一定的负载均衡算法来决定，用户拿到具体ip后再去访问，而这个过程对用户来说完全是透明的，通过DNS分流完成了第一步的负载均衡：\n\n### 3 Https，ssl协议，Tcp建立连接\n浏览器通过http/https协议，建立tcp连接，三次握手建立请求，传输连接建立完毕。\n\n### 4 服务器处理请求，返回结果\n服务器，解析请求头，对比是否过期字段，缓存字段，返回对应的状态码和内容。返回所有内容后，可以关闭连接了亲。\n\n### 5 浏览器解析/渲染 \ndom树解析，转换css单位成通用单位，cssdom解析，绘制。优先视口。\n\n- 构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示\n    + 构建DOM树：html内容解析成DOM树（这里面用到HTML的parser）\n    + css样式表，转为浏览器可以读懂的CSS规则树\n    + 由DOM树和CSS规则树，创建render树，计算布局信息，包括所有元素的尺寸、位置、还有position、z-index、overflow\n    + 绘制render树，绘制页面像素\n    + GPU绘制，显示到显示屏\n\n\n小知识点：\n- HTML的parser：\n    + 转换：HTML编码成字符\n    + 分词：给字符们打上标记Tokens\n    + 词法：tokens转换成包含属性和规则的对象\n    + DOM树创建\n\n参考：\n- [文章](https://mp.weixin.qq.com/s/DLq_GIkdnuOayThfi3jI0A)\n- [https](https://segmentfault.com/a/1190000012196642)\n- [https](https://zhuanlan.zhihu.com/p/26682342)\n- [负载均衡](https://blog.csdn.net/weixin_34050389/article/details/93027673)\n- [If-Unmodified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since)\n- [If-Modified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since)\n- [Expires](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires)\n- [Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)\n- [浏览器相关](https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649825731&idx=1&sn=2c0835cebfee3a44e82d9efeb54f6e43&chksm=f175eb00c602621649fd46d7c9de87f7f08a4cdaa9e08808b938948584ca6977e24a5f5336ce&scene=21#wechat_redirect)\n- [全面](https://segmentfault.com/a/1190000013662126)\n- [浏览器进程/线程](https://segmentfault.com/a/1190000012925872)\n\n","source":"_posts/浏览器-输入url操作篇.md","raw":"---\ntitle: 浏览器-输入url系列\ndate: 2020-03-13 15:03:39\ntags: 浏览器\n---\n\n> 共是五个步骤\n\n### 1 浏览器的搜索框\n浏览器会根据输入的内容，去匹配是用对应的引擎搜索内容，还是直接跳转url。\n详细的讲，就是\n- 搜索内容+默认搜索引擎，形成新的URL\n- 符合URL规则的话，在输入内容基础上加上协议，形成新的URL\n\n### 2 dns解析\n- 自己的理解：路由解析，找到背后的ip地址，路由缓存，域名缓存，为什么第二次加载会更快，跟这个有关。\n- dns：一个域名与ip地址相互映射的分布式数据库\n- 我们无法记住的ip，那一个个长相平凡但是堆积在一起就是记不住的几个数字，是的，dns帮我们记住了。他以电话簿的形式，记住了许许多多的ip地址，映射到了所有网站上。\n- 在客户端输入 URL 后，会有一个递归查找的过程，从浏览器缓存中查找->本地的hosts文件查找->找本地DNS解析器缓存查找->本地DNS服务器查找，这个过程中任何一步找到了都会结束查找流程。\n- 本地dns服务器找不到的时候，去查询其他根dns服务器，顶级域服务器，权威dns服务器\n- 查找的过程是有优化的地方：\n    + DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 \n    + 在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。\n    + 补充：域名与ip之间有映射关系，但是大多数情况下却不是一一对应的，我们可以将多个ip映射到同一个域名，因为用户是通过域名去进行访问的，具体访问哪个地址，则有DNS服务器的映射记录和一定的负载均衡算法来决定，用户拿到具体ip后再去访问，而这个过程对用户来说完全是透明的，通过DNS分流完成了第一步的负载均衡：\n\n### 3 Https，ssl协议，Tcp建立连接\n浏览器通过http/https协议，建立tcp连接，三次握手建立请求，传输连接建立完毕。\n\n### 4 服务器处理请求，返回结果\n服务器，解析请求头，对比是否过期字段，缓存字段，返回对应的状态码和内容。返回所有内容后，可以关闭连接了亲。\n\n### 5 浏览器解析/渲染 \ndom树解析，转换css单位成通用单位，cssdom解析，绘制。优先视口。\n\n- 构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示\n    + 构建DOM树：html内容解析成DOM树（这里面用到HTML的parser）\n    + css样式表，转为浏览器可以读懂的CSS规则树\n    + 由DOM树和CSS规则树，创建render树，计算布局信息，包括所有元素的尺寸、位置、还有position、z-index、overflow\n    + 绘制render树，绘制页面像素\n    + GPU绘制，显示到显示屏\n\n\n小知识点：\n- HTML的parser：\n    + 转换：HTML编码成字符\n    + 分词：给字符们打上标记Tokens\n    + 词法：tokens转换成包含属性和规则的对象\n    + DOM树创建\n\n参考：\n- [文章](https://mp.weixin.qq.com/s/DLq_GIkdnuOayThfi3jI0A)\n- [https](https://segmentfault.com/a/1190000012196642)\n- [https](https://zhuanlan.zhihu.com/p/26682342)\n- [负载均衡](https://blog.csdn.net/weixin_34050389/article/details/93027673)\n- [If-Unmodified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since)\n- [If-Modified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since)\n- [Expires](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires)\n- [Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)\n- [浏览器相关](https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649825731&idx=1&sn=2c0835cebfee3a44e82d9efeb54f6e43&chksm=f175eb00c602621649fd46d7c9de87f7f08a4cdaa9e08808b938948584ca6977e24a5f5336ce&scene=21#wechat_redirect)\n- [全面](https://segmentfault.com/a/1190000013662126)\n- [浏览器进程/线程](https://segmentfault.com/a/1190000012925872)\n\n","slug":"浏览器-输入url操作篇","published":1,"updated":"2020-07-21T03:05:09.751Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmrab001az5o80w0mcfrx","content":"<blockquote>\n<p>共是五个步骤</p>\n</blockquote>\n<h3 id=\"1-浏览器的搜索框\"><a href=\"#1-浏览器的搜索框\" class=\"headerlink\" title=\"1 浏览器的搜索框\"></a>1 浏览器的搜索框</h3><p>浏览器会根据输入的内容，去匹配是用对应的引擎搜索内容，还是直接跳转url。<br>详细的讲，就是</p>\n<ul>\n<li>搜索内容+默认搜索引擎，形成新的URL</li>\n<li>符合URL规则的话，在输入内容基础上加上协议，形成新的URL</li>\n</ul>\n<h3 id=\"2-dns解析\"><a href=\"#2-dns解析\" class=\"headerlink\" title=\"2 dns解析\"></a>2 dns解析</h3><ul>\n<li>自己的理解：路由解析，找到背后的ip地址，路由缓存，域名缓存，为什么第二次加载会更快，跟这个有关。</li>\n<li>dns：一个域名与ip地址相互映射的分布式数据库</li>\n<li>我们无法记住的ip，那一个个长相平凡但是堆积在一起就是记不住的几个数字，是的，dns帮我们记住了。他以电话簿的形式，记住了许许多多的ip地址，映射到了所有网站上。</li>\n<li>在客户端输入 URL 后，会有一个递归查找的过程，从浏览器缓存中查找-&gt;本地的hosts文件查找-&gt;找本地DNS解析器缓存查找-&gt;本地DNS服务器查找，这个过程中任何一步找到了都会结束查找流程。</li>\n<li>本地dns服务器找不到的时候，去查询其他根dns服务器，顶级域服务器，权威dns服务器</li>\n<li>查找的过程是有优化的地方：<ul>\n<li>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 </li>\n<li>在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。</li>\n<li>补充：域名与ip之间有映射关系，但是大多数情况下却不是一一对应的，我们可以将多个ip映射到同一个域名，因为用户是通过域名去进行访问的，具体访问哪个地址，则有DNS服务器的映射记录和一定的负载均衡算法来决定，用户拿到具体ip后再去访问，而这个过程对用户来说完全是透明的，通过DNS分流完成了第一步的负载均衡：</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-Https，ssl协议，Tcp建立连接\"><a href=\"#3-Https，ssl协议，Tcp建立连接\" class=\"headerlink\" title=\"3 Https，ssl协议，Tcp建立连接\"></a>3 Https，ssl协议，Tcp建立连接</h3><p>浏览器通过http/https协议，建立tcp连接，三次握手建立请求，传输连接建立完毕。</p>\n<h3 id=\"4-服务器处理请求，返回结果\"><a href=\"#4-服务器处理请求，返回结果\" class=\"headerlink\" title=\"4 服务器处理请求，返回结果\"></a>4 服务器处理请求，返回结果</h3><p>服务器，解析请求头，对比是否过期字段，缓存字段，返回对应的状态码和内容。返回所有内容后，可以关闭连接了亲。</p>\n<h3 id=\"5-浏览器解析-渲染\"><a href=\"#5-浏览器解析-渲染\" class=\"headerlink\" title=\"5 浏览器解析/渲染\"></a>5 浏览器解析/渲染</h3><p>dom树解析，转换css单位成通用单位，cssdom解析，绘制。优先视口。</p>\n<ul>\n<li>构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示<ul>\n<li>构建DOM树：html内容解析成DOM树（这里面用到HTML的parser）</li>\n<li>css样式表，转为浏览器可以读懂的CSS规则树</li>\n<li>由DOM树和CSS规则树，创建render树，计算布局信息，包括所有元素的尺寸、位置、还有position、z-index、overflow</li>\n<li>绘制render树，绘制页面像素</li>\n<li>GPU绘制，显示到显示屏</li>\n</ul>\n</li>\n</ul>\n<p>小知识点：</p>\n<ul>\n<li>HTML的parser：<ul>\n<li>转换：HTML编码成字符</li>\n<li>分词：给字符们打上标记Tokens</li>\n<li>词法：tokens转换成包含属性和规则的对象</li>\n<li>DOM树创建</li>\n</ul>\n</li>\n</ul>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/DLq_GIkdnuOayThfi3jI0A\" target=\"_blank\" rel=\"noopener\">文章</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000012196642\" target=\"_blank\" rel=\"noopener\">https</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26682342\" target=\"_blank\" rel=\"noopener\">https</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_34050389/article/details/93027673\" target=\"_blank\" rel=\"noopener\">负载均衡</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since\" target=\"_blank\" rel=\"noopener\">If-Unmodified-Since</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since\" target=\"_blank\" rel=\"noopener\">If-Modified-Since</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires\" target=\"_blank\" rel=\"noopener\">Expires</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control\" target=\"_blank\" rel=\"noopener\">Cache-Control</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649825731&idx=1&sn=2c0835cebfee3a44e82d9efeb54f6e43&chksm=f175eb00c602621649fd46d7c9de87f7f08a4cdaa9e08808b938948584ca6977e24a5f5336ce&scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">浏览器相关</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000013662126\" target=\"_blank\" rel=\"noopener\">全面</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000012925872\" target=\"_blank\" rel=\"noopener\">浏览器进程/线程</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>共是五个步骤</p>\n</blockquote>\n<h3 id=\"1-浏览器的搜索框\"><a href=\"#1-浏览器的搜索框\" class=\"headerlink\" title=\"1 浏览器的搜索框\"></a>1 浏览器的搜索框</h3><p>浏览器会根据输入的内容，去匹配是用对应的引擎搜索内容，还是直接跳转url。<br>详细的讲，就是</p>\n<ul>\n<li>搜索内容+默认搜索引擎，形成新的URL</li>\n<li>符合URL规则的话，在输入内容基础上加上协议，形成新的URL</li>\n</ul>\n<h3 id=\"2-dns解析\"><a href=\"#2-dns解析\" class=\"headerlink\" title=\"2 dns解析\"></a>2 dns解析</h3><ul>\n<li>自己的理解：路由解析，找到背后的ip地址，路由缓存，域名缓存，为什么第二次加载会更快，跟这个有关。</li>\n<li>dns：一个域名与ip地址相互映射的分布式数据库</li>\n<li>我们无法记住的ip，那一个个长相平凡但是堆积在一起就是记不住的几个数字，是的，dns帮我们记住了。他以电话簿的形式，记住了许许多多的ip地址，映射到了所有网站上。</li>\n<li>在客户端输入 URL 后，会有一个递归查找的过程，从浏览器缓存中查找-&gt;本地的hosts文件查找-&gt;找本地DNS解析器缓存查找-&gt;本地DNS服务器查找，这个过程中任何一步找到了都会结束查找流程。</li>\n<li>本地dns服务器找不到的时候，去查询其他根dns服务器，顶级域服务器，权威dns服务器</li>\n<li>查找的过程是有优化的地方：<ul>\n<li>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 </li>\n<li>在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。</li>\n<li>补充：域名与ip之间有映射关系，但是大多数情况下却不是一一对应的，我们可以将多个ip映射到同一个域名，因为用户是通过域名去进行访问的，具体访问哪个地址，则有DNS服务器的映射记录和一定的负载均衡算法来决定，用户拿到具体ip后再去访问，而这个过程对用户来说完全是透明的，通过DNS分流完成了第一步的负载均衡：</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-Https，ssl协议，Tcp建立连接\"><a href=\"#3-Https，ssl协议，Tcp建立连接\" class=\"headerlink\" title=\"3 Https，ssl协议，Tcp建立连接\"></a>3 Https，ssl协议，Tcp建立连接</h3><p>浏览器通过http/https协议，建立tcp连接，三次握手建立请求，传输连接建立完毕。</p>\n<h3 id=\"4-服务器处理请求，返回结果\"><a href=\"#4-服务器处理请求，返回结果\" class=\"headerlink\" title=\"4 服务器处理请求，返回结果\"></a>4 服务器处理请求，返回结果</h3><p>服务器，解析请求头，对比是否过期字段，缓存字段，返回对应的状态码和内容。返回所有内容后，可以关闭连接了亲。</p>\n<h3 id=\"5-浏览器解析-渲染\"><a href=\"#5-浏览器解析-渲染\" class=\"headerlink\" title=\"5 浏览器解析/渲染\"></a>5 浏览器解析/渲染</h3><p>dom树解析，转换css单位成通用单位，cssdom解析，绘制。优先视口。</p>\n<ul>\n<li>构建 DOM 树、样式计算、布局阶段、分层、栅格化和显示<ul>\n<li>构建DOM树：html内容解析成DOM树（这里面用到HTML的parser）</li>\n<li>css样式表，转为浏览器可以读懂的CSS规则树</li>\n<li>由DOM树和CSS规则树，创建render树，计算布局信息，包括所有元素的尺寸、位置、还有position、z-index、overflow</li>\n<li>绘制render树，绘制页面像素</li>\n<li>GPU绘制，显示到显示屏</li>\n</ul>\n</li>\n</ul>\n<p>小知识点：</p>\n<ul>\n<li>HTML的parser：<ul>\n<li>转换：HTML编码成字符</li>\n<li>分词：给字符们打上标记Tokens</li>\n<li>词法：tokens转换成包含属性和规则的对象</li>\n<li>DOM树创建</li>\n</ul>\n</li>\n</ul>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/DLq_GIkdnuOayThfi3jI0A\" target=\"_blank\" rel=\"noopener\">文章</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000012196642\" target=\"_blank\" rel=\"noopener\">https</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/26682342\" target=\"_blank\" rel=\"noopener\">https</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_34050389/article/details/93027673\" target=\"_blank\" rel=\"noopener\">负载均衡</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since\" target=\"_blank\" rel=\"noopener\">If-Unmodified-Since</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since\" target=\"_blank\" rel=\"noopener\">If-Modified-Since</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires\" target=\"_blank\" rel=\"noopener\">Expires</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control\" target=\"_blank\" rel=\"noopener\">Cache-Control</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649825731&idx=1&sn=2c0835cebfee3a44e82d9efeb54f6e43&chksm=f175eb00c602621649fd46d7c9de87f7f08a4cdaa9e08808b938948584ca6977e24a5f5336ce&scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">浏览器相关</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000013662126\" target=\"_blank\" rel=\"noopener\">全面</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000012925872\" target=\"_blank\" rel=\"noopener\">浏览器进程/线程</a></li>\n</ul>\n"},{"title":"浏览器异步（二）","date":"2020-07-17T16:37:05.000Z","_content":"\n> 转载自瓶子君的blog [链接](https://github.com/sisterAn/blog/issues/12)\n\n### step1：回调函数callback\n```js\nasyncFunction(function(value) {\n    // todo\n})\n```\n\n这种回调函数，大家是最熟悉的。一般是需要在某个耗时操作之后执行某个回调函数。\n\n例如：\n\n```js\nsetTimeout(function() {\n    console.log('Time out')\n}, 1000)\n```\n\n其中，我们称`setTimeout`为发起函数，`fn`为回调函数。都是在主线程上调用的，其中发起函数用来发动异步过程，回调函数用来处理结果。在执行`setTimeout`1s后，执行function函数。\n\n下面，我们再看一种情况。\n\n```js\n$.ajax({\n    url:'XXX1',\n    success: function(res) {\n        $.ajax({\n            url:'XXX2',\n            success: function(res) {\n                $.ajax({\n                    url: 'XXX3',\n                    success: function(res) {\n                        // todo\n                    },\n                    fail: function(err) {\n                        console.log(err)\n                    }\n                })\n            },\n            fail: function(err) {\n                console.log(err)\n            }\n        }) \n    },\n    fail: function(err) {\n    \tconsole.log(err)\n\t}\n})\n```\n\n在上例中，我们看到这段回调函数，不断的在回调，这只是三层回调，在实际应用中，我们遇到的需求会更复杂，回调也许更多，调试起来也就更麻烦，代码也更不美观，这就是我们要引入的第一个问题：回调地狱。\n\n**问题1: 回调地狱**\n\n回调地狱是JS里一个约定俗成的名称，一般情况下，一个业务依赖于上层业务，上层业务又依赖于更上一层的业务，以此类推，如果我们使用回调函数来处理异步的话，就会出现回调地狱。\n\n主要是因为：大脑对业务的逻辑处理是线性的、阻塞的、单线程的，但是回调表达异步的方式是非线形的、非顺序的，这使得正确推导这类代码的难度很大，很容易出bug。\n\n再例如：\n\n```js\n// A\n$.ajax({\n    ...\n    success: function (...) {\n        // C\n    }\n});\n// B\n```\n\nA和B发生于现在，在JavaScript主程序的直接控制之下，而C会延迟到将来发生，并且是在第三方的控制下，在本例中就是函数$.ajax(...)。从根本上来说，这种控制的转移通常不会给程序带来很多问题。\n\n但是，请不要被这个小概率迷惑而认为这种控制切换不是什么大问题。实际上，这是回调驱动设计最严重（也是最微妙）的问题。它以这样一个思路为中心：有时候ajax(...)，也就是你交付回调函数的第三方不是你编写的代码，也不在你的直接控制之下，它是某个第三方提供的工具。\n\n这种情况称为**控制反转**，也就是把自己程序一部分的执行控制交给某个第三方，在你的代码和第三方工具直接有一份并没有明确表达的契约。\n\n既然是无法控制的第三方在执行你的回调函数，那么就有可能存在以下问题，当然通常情况下是不会发生的：\n\n1. 调用回调过早\n2. 调用回调过晚\n3. 调用回调次数太多或者太少\n4. 未能把所需的参数成功传给你的回调函数\n5. 吞掉可能出现的错误或异常\n6. ......\n\n这种控制反转会导致信任链的完全断裂，如果你没有采取行动来解决这些控制反转导致的信任问题，那么你的代码已经有了隐藏的Bug，尽管我们大多数人都没有这样做。\n\n这里，我们引出了回调函数处理异步的第二个问题：**控制反转**。\n\n###  **step2：控制反转**\n\n综上，回调函数处理异步流程存在2个问题：\n\n**1. 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符**\n\n**2. 缺乏可信任性： 控制反转导致的一系列信任问题**\n\n那么如何来解决这两个问题，先驱者们开始了探索之路......\n\n\n---\n\n参考：\n[瓶子君 blog](https://github.com/sisterAn/blog/issues/12)\n\n\n","source":"_posts/浏览器异步（二）.md","raw":"---\ntitle: 浏览器异步（二）\ndate: 2020-07-18 00:37:05\ntags: JS\n---\n\n> 转载自瓶子君的blog [链接](https://github.com/sisterAn/blog/issues/12)\n\n### step1：回调函数callback\n```js\nasyncFunction(function(value) {\n    // todo\n})\n```\n\n这种回调函数，大家是最熟悉的。一般是需要在某个耗时操作之后执行某个回调函数。\n\n例如：\n\n```js\nsetTimeout(function() {\n    console.log('Time out')\n}, 1000)\n```\n\n其中，我们称`setTimeout`为发起函数，`fn`为回调函数。都是在主线程上调用的，其中发起函数用来发动异步过程，回调函数用来处理结果。在执行`setTimeout`1s后，执行function函数。\n\n下面，我们再看一种情况。\n\n```js\n$.ajax({\n    url:'XXX1',\n    success: function(res) {\n        $.ajax({\n            url:'XXX2',\n            success: function(res) {\n                $.ajax({\n                    url: 'XXX3',\n                    success: function(res) {\n                        // todo\n                    },\n                    fail: function(err) {\n                        console.log(err)\n                    }\n                })\n            },\n            fail: function(err) {\n                console.log(err)\n            }\n        }) \n    },\n    fail: function(err) {\n    \tconsole.log(err)\n\t}\n})\n```\n\n在上例中，我们看到这段回调函数，不断的在回调，这只是三层回调，在实际应用中，我们遇到的需求会更复杂，回调也许更多，调试起来也就更麻烦，代码也更不美观，这就是我们要引入的第一个问题：回调地狱。\n\n**问题1: 回调地狱**\n\n回调地狱是JS里一个约定俗成的名称，一般情况下，一个业务依赖于上层业务，上层业务又依赖于更上一层的业务，以此类推，如果我们使用回调函数来处理异步的话，就会出现回调地狱。\n\n主要是因为：大脑对业务的逻辑处理是线性的、阻塞的、单线程的，但是回调表达异步的方式是非线形的、非顺序的，这使得正确推导这类代码的难度很大，很容易出bug。\n\n再例如：\n\n```js\n// A\n$.ajax({\n    ...\n    success: function (...) {\n        // C\n    }\n});\n// B\n```\n\nA和B发生于现在，在JavaScript主程序的直接控制之下，而C会延迟到将来发生，并且是在第三方的控制下，在本例中就是函数$.ajax(...)。从根本上来说，这种控制的转移通常不会给程序带来很多问题。\n\n但是，请不要被这个小概率迷惑而认为这种控制切换不是什么大问题。实际上，这是回调驱动设计最严重（也是最微妙）的问题。它以这样一个思路为中心：有时候ajax(...)，也就是你交付回调函数的第三方不是你编写的代码，也不在你的直接控制之下，它是某个第三方提供的工具。\n\n这种情况称为**控制反转**，也就是把自己程序一部分的执行控制交给某个第三方，在你的代码和第三方工具直接有一份并没有明确表达的契约。\n\n既然是无法控制的第三方在执行你的回调函数，那么就有可能存在以下问题，当然通常情况下是不会发生的：\n\n1. 调用回调过早\n2. 调用回调过晚\n3. 调用回调次数太多或者太少\n4. 未能把所需的参数成功传给你的回调函数\n5. 吞掉可能出现的错误或异常\n6. ......\n\n这种控制反转会导致信任链的完全断裂，如果你没有采取行动来解决这些控制反转导致的信任问题，那么你的代码已经有了隐藏的Bug，尽管我们大多数人都没有这样做。\n\n这里，我们引出了回调函数处理异步的第二个问题：**控制反转**。\n\n###  **step2：控制反转**\n\n综上，回调函数处理异步流程存在2个问题：\n\n**1. 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符**\n\n**2. 缺乏可信任性： 控制反转导致的一系列信任问题**\n\n那么如何来解决这两个问题，先驱者们开始了探索之路......\n\n\n---\n\n参考：\n[瓶子君 blog](https://github.com/sisterAn/blog/issues/12)\n\n\n","slug":"浏览器异步（二）","published":1,"updated":"2020-07-20T08:51:05.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmrac001cz5o8fduka8qr","content":"<blockquote>\n<p>转载自瓶子君的blog <a href=\"https://github.com/sisterAn/blog/issues/12\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n</blockquote>\n<h3 id=\"step1：回调函数callback\"><a href=\"#step1：回调函数callback\" class=\"headerlink\" title=\"step1：回调函数callback\"></a>step1：回调函数callback</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asyncFunction(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// todo</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这种回调函数，大家是最熟悉的。一般是需要在某个耗时操作之后执行某个回调函数。</p>\n<p>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Time out'</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure>\n\n<p>其中，我们称<code>setTimeout</code>为发起函数，<code>fn</code>为回调函数。都是在主线程上调用的，其中发起函数用来发动异步过程，回调函数用来处理结果。在执行<code>setTimeout</code>1s后，执行function函数。</p>\n<p>下面，我们再看一种情况。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url:<span class=\"string\">'XXX1'</span>,</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">        $.ajax(&#123;</span><br><span class=\"line\">            url:<span class=\"string\">'XXX2'</span>,</span><br><span class=\"line\">            success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">                $.ajax(&#123;</span><br><span class=\"line\">                    url: <span class=\"string\">'XXX3'</span>,</span><br><span class=\"line\">                    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// todo</span></span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    fail: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">                        <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            fail: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;) </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    fail: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在上例中，我们看到这段回调函数，不断的在回调，这只是三层回调，在实际应用中，我们遇到的需求会更复杂，回调也许更多，调试起来也就更麻烦，代码也更不美观，这就是我们要引入的第一个问题：回调地狱。</p>\n<p><strong>问题1: 回调地狱</strong></p>\n<p>回调地狱是JS里一个约定俗成的名称，一般情况下，一个业务依赖于上层业务，上层业务又依赖于更上一层的业务，以此类推，如果我们使用回调函数来处理异步的话，就会出现回调地狱。</p>\n<p>主要是因为：大脑对业务的逻辑处理是线性的、阻塞的、单线程的，但是回调表达异步的方式是非线形的、非顺序的，这使得正确推导这类代码的难度很大，很容易出bug。</p>\n<p>再例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A</span></span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// C</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// B</span></span><br></pre></td></tr></table></figure>\n\n<p>A和B发生于现在，在JavaScript主程序的直接控制之下，而C会延迟到将来发生，并且是在第三方的控制下，在本例中就是函数$.ajax(…)。从根本上来说，这种控制的转移通常不会给程序带来很多问题。</p>\n<p>但是，请不要被这个小概率迷惑而认为这种控制切换不是什么大问题。实际上，这是回调驱动设计最严重（也是最微妙）的问题。它以这样一个思路为中心：有时候ajax(…)，也就是你交付回调函数的第三方不是你编写的代码，也不在你的直接控制之下，它是某个第三方提供的工具。</p>\n<p>这种情况称为<strong>控制反转</strong>，也就是把自己程序一部分的执行控制交给某个第三方，在你的代码和第三方工具直接有一份并没有明确表达的契约。</p>\n<p>既然是无法控制的第三方在执行你的回调函数，那么就有可能存在以下问题，当然通常情况下是不会发生的：</p>\n<ol>\n<li>调用回调过早</li>\n<li>调用回调过晚</li>\n<li>调用回调次数太多或者太少</li>\n<li>未能把所需的参数成功传给你的回调函数</li>\n<li>吞掉可能出现的错误或异常</li>\n<li>……</li>\n</ol>\n<p>这种控制反转会导致信任链的完全断裂，如果你没有采取行动来解决这些控制反转导致的信任问题，那么你的代码已经有了隐藏的Bug，尽管我们大多数人都没有这样做。</p>\n<p>这里，我们引出了回调函数处理异步的第二个问题：<strong>控制反转</strong>。</p>\n<h3 id=\"step2：控制反转\"><a href=\"#step2：控制反转\" class=\"headerlink\" title=\"step2：控制反转\"></a><strong>step2：控制反转</strong></h3><p>综上，回调函数处理异步流程存在2个问题：</p>\n<p><strong>1. 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符</strong></p>\n<p><strong>2. 缺乏可信任性： 控制反转导致的一系列信任问题</strong></p>\n<p>那么如何来解决这两个问题，先驱者们开始了探索之路……</p>\n<hr>\n<p>参考：<br><a href=\"https://github.com/sisterAn/blog/issues/12\" target=\"_blank\" rel=\"noopener\">瓶子君 blog</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>转载自瓶子君的blog <a href=\"https://github.com/sisterAn/blog/issues/12\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n</blockquote>\n<h3 id=\"step1：回调函数callback\"><a href=\"#step1：回调函数callback\" class=\"headerlink\" title=\"step1：回调函数callback\"></a>step1：回调函数callback</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asyncFunction(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// todo</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这种回调函数，大家是最熟悉的。一般是需要在某个耗时操作之后执行某个回调函数。</p>\n<p>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Time out'</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span>)</span><br></pre></td></tr></table></figure>\n\n<p>其中，我们称<code>setTimeout</code>为发起函数，<code>fn</code>为回调函数。都是在主线程上调用的，其中发起函数用来发动异步过程，回调函数用来处理结果。在执行<code>setTimeout</code>1s后，执行function函数。</p>\n<p>下面，我们再看一种情况。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url:<span class=\"string\">'XXX1'</span>,</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">        $.ajax(&#123;</span><br><span class=\"line\">            url:<span class=\"string\">'XXX2'</span>,</span><br><span class=\"line\">            success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">                $.ajax(&#123;</span><br><span class=\"line\">                    url: <span class=\"string\">'XXX3'</span>,</span><br><span class=\"line\">                    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// todo</span></span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    fail: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">                        <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            fail: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;) </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    fail: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在上例中，我们看到这段回调函数，不断的在回调，这只是三层回调，在实际应用中，我们遇到的需求会更复杂，回调也许更多，调试起来也就更麻烦，代码也更不美观，这就是我们要引入的第一个问题：回调地狱。</p>\n<p><strong>问题1: 回调地狱</strong></p>\n<p>回调地狱是JS里一个约定俗成的名称，一般情况下，一个业务依赖于上层业务，上层业务又依赖于更上一层的业务，以此类推，如果我们使用回调函数来处理异步的话，就会出现回调地狱。</p>\n<p>主要是因为：大脑对业务的逻辑处理是线性的、阻塞的、单线程的，但是回调表达异步的方式是非线形的、非顺序的，这使得正确推导这类代码的难度很大，很容易出bug。</p>\n<p>再例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A</span></span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// C</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// B</span></span><br></pre></td></tr></table></figure>\n\n<p>A和B发生于现在，在JavaScript主程序的直接控制之下，而C会延迟到将来发生，并且是在第三方的控制下，在本例中就是函数$.ajax(…)。从根本上来说，这种控制的转移通常不会给程序带来很多问题。</p>\n<p>但是，请不要被这个小概率迷惑而认为这种控制切换不是什么大问题。实际上，这是回调驱动设计最严重（也是最微妙）的问题。它以这样一个思路为中心：有时候ajax(…)，也就是你交付回调函数的第三方不是你编写的代码，也不在你的直接控制之下，它是某个第三方提供的工具。</p>\n<p>这种情况称为<strong>控制反转</strong>，也就是把自己程序一部分的执行控制交给某个第三方，在你的代码和第三方工具直接有一份并没有明确表达的契约。</p>\n<p>既然是无法控制的第三方在执行你的回调函数，那么就有可能存在以下问题，当然通常情况下是不会发生的：</p>\n<ol>\n<li>调用回调过早</li>\n<li>调用回调过晚</li>\n<li>调用回调次数太多或者太少</li>\n<li>未能把所需的参数成功传给你的回调函数</li>\n<li>吞掉可能出现的错误或异常</li>\n<li>……</li>\n</ol>\n<p>这种控制反转会导致信任链的完全断裂，如果你没有采取行动来解决这些控制反转导致的信任问题，那么你的代码已经有了隐藏的Bug，尽管我们大多数人都没有这样做。</p>\n<p>这里，我们引出了回调函数处理异步的第二个问题：<strong>控制反转</strong>。</p>\n<h3 id=\"step2：控制反转\"><a href=\"#step2：控制反转\" class=\"headerlink\" title=\"step2：控制反转\"></a><strong>step2：控制反转</strong></h3><p>综上，回调函数处理异步流程存在2个问题：</p>\n<p><strong>1. 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符</strong></p>\n<p><strong>2. 缺乏可信任性： 控制反转导致的一系列信任问题</strong></p>\n<p>那么如何来解决这两个问题，先驱者们开始了探索之路……</p>\n<hr>\n<p>参考：<br><a href=\"https://github.com/sisterAn/blog/issues/12\" target=\"_blank\" rel=\"noopener\">瓶子君 blog</a></p>\n"},{"title":"浏览器异步（一）","date":"2020-07-17T15:10:05.000Z","_content":"\n> 注： 转载瓶子君文章 [详细连接](https://github.com/sisterAn/blog/issues/11)\n\n已知，JavaScript 是单线程的，天生异步，适合 IO 密集型，不适合 CPU 密集型，但是，为什么是异步的，异步由何而来的，我们将在这里逐渐讨论实现。\n\n### 一、进程与线程\n#### 1. 浏览器是多进程的\n它主要包括以下进程：\n\n* Browser 进程：浏览器的主进程，唯一，负责创建和销毁其它进程、网络资源的下载与管理、浏览器界面的展示、前进后退等。\n* GPU 进程：用于 3D 绘制等，最多一个。\n* 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。\n* 浏览器渲染进程（浏览器内核）：内部是多线程的，每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。\n\n#### 2. 渲染进程（浏览器内核）\n浏览器的渲染进程是多线程的，页面的渲染，JavaScript 的执行，事件的循环，都在这个进程内进行：\n\n* GUI 渲染线程：负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。\n* JavaScript 引擎线程：也称为 JavaScript 内核，负责处理 Javascript 脚本程序、解析 Javascript 脚本、运行代码等。（例如 V8 引擎）\n* 事件触发线程：用来控制浏览器事件循环，注意这不归 JavaScript 引擎线程管，当事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。\n* 定时触发器线程：传说中的 `setInterval` 与 `setTimeout` 所在线程，注意，W3C 在 HTML 标准中规定，规定要求 `setTimeout` 中低于 4ms 的时间间隔算为 4ms 。\n* 异步 http 请求线程：在 `XMLHttpRequest` 连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。\n\n注意，**GUI 渲染线程与 JavaScript 引擎线程是互斥的**，当 JavaScript 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中**等到 JavaScript 引擎空闲时**立即被执行。所以如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n\n### 二、单线程的 JavaScript\n所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。\n\n**问题：首先为什么要引入单线程？**\n\n我们知道：\n\n* 浏览器需要渲染 DOM\n* JavaScript 可以修改 DOM 结构\n* JavaScript 执行时，浏览器 DOM 渲染停止\n\n如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都修改 DOM，那么就会出现 DOM 冲突。\n\n你可能会说，[web worker](http://www.ruanyifeng.com/blog/2018/07/web-worker.html) 就支持多线程，但是 web worker 不能访问 window 对象，document 对象等。\n\n**原因：避免 DOM 渲染的冲突**\n\n当然，我们可以为浏览器引入**锁** 的机制来解决这些冲突，但其大大提高了复杂性，所以 JavaScript从诞生开始就选择了单线程执行。\n\n引入单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这同时又导致了一个问题：如果前一个任务耗时很长，后一个任务就不得不一直等着。\n\n```js\n// 实例1\nlet i, sum = 0\nfor(i = 0; i < 1000000000; i ++) {\n    sum += i\n}\nconsole.log(sum)\n```\n\n在实例1中，`sum` 并不能立刻打印出来，必须在 for 循环执行完成之后才能执行 `console.log(sum)` 。\n\n```js\n// 实例2\nconsole.log(1)\nalert('hello')\nconsole.log(2)\n```\n\n在实例2中，浏览器先打印 `1` ，然后弹出弹框，点击确定后才执行 `console.log(2)` 。\n\n**总结：**\n\n* 优点：实现比较简单，执行环境相对单纯\n* 缺点：只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 Javascript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。\n\n为了解决这个问题，JavaScript 语言将任务的执行模式分为两种：同步和异步\n\n### 三、同步与异步\n#### 1. 同步\n```js\nfunc(args...)\n```\n\n如果在函数 `func` 返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。\n\n```js\nlet a = 1\nMath.floor(a)\nconsole.log(a) // 1\n```\n\n#### 2. 异步\n如果在函数 `func` 返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。\n\n```js\nfs.readFile('foo.txt', 'utf8', function(err, data) {\n    console.log(data);\n});\n```\n\n**总结：**\n\nJavaScript 采用异步编程原因有两点，\n\n* 一是 JavaScript 是单线程；\n* 二是为了提高 CPU 的利用率。\n\n### 四、异步过程\n```js\nfs.readFile('data.json', 'utf8', function(err, data) {\n    console.log(data)\n})\n```\n\n在执行这段代码时，`fs.readFile` 函数返回时，并不会立刻打印 `data` ，只有 `data.json` 读取完成时才打印。也就是异步函数 `fs.readFile` 执行很快，但后面还有工作线程执行异步任务、通知主线程、主线程回调等操作，这个过程就叫做异步过程。\n\n主线程发起一个异步操作，相应的工作线程接受请求并告知主线程已收到（异步函数返回）；主线程继续执行后面的任务，同时工作线程执行异步任务；工作线程完成任务后，通知主线程；主线程收到通知后，执行一定的动作（调用回调函数）。\n\n工作线程在异步操作完成后通知主线程，那么这个通知机制又是如何显现？答案就是就是消息队列与事件循环。\n\n### 五、消息队列与事件循环\n工作线程将消息放在消息队列，主线程通过事件循环过程去取消息。\n\n* 消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。\n* 事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。\n\n#### 1. 事件循环（eventloop）\n主线程不断的从消息队列中取消息，执行消息，这个过程称为事件循环，这种机制叫事件循环机制，取一次消息并执行的过程叫一次循环。\n\n大致实现过程如下：\n\n```js\nwhile(true) {\n    var message = queue.get()\n    execute(message)\n}\n```\n\n例如：\n\n```js\n$.ajax({\n    url: 'xxxx',\n    success: function(result) {\n        console.log(1)\n    }\n})\nsetTimeout(function() {\n    console.log(2)\n}, 100)\nsetTimeout(function() {\n    console.log(3)\n})\nconsole.log(4)\n// output：4321 或 4312\n```\n\n其中，主线程：\n\n```js\n// 主线程\nconsole.log(4)\n```\n\n异步队列：\n\n```js\n// 异步队列\nfunction () {\n    console.log(3)\n}\nfunction () { // 100ms后\n    console.log(2)\n}\nfunction() { // ajax加载完成之后\n    console.log(1)\n}\n```\n\n**事件循环是JavaScript实现异步的具体解决方案，其中同步代码，直接执行；异步函数先放在异步队列中，待同步函数执行完毕后，轮询执行 异步队列 的回调函数。**\n\n#### 2. 消息队列\n其中，消息就是注册异步任务时添加的回调函数。\n\n```js\n$.ajax('XXX', function(res) {\n    console.log(res)\n})\n...\n```\n\n主线程在发起 AJAX 请求后，会继续执行其他代码，AJAX 线程负责请求 `XXX`，拿到请求后，会封装成 JavaScript 对象，然后构造一条消息：\n\n```js\n// 消息队列里的消息\nvar message = function () {\n    callback(response)\n}\n```\n\n其中 `callback` 是 AJAX 网络请求成功响应时的回调函数。\n\n主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是 `message` 函数)，并执行它。到此为止，就完成了工作线程对主线程的 `通知` ，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，AJAX 线程在收到 HTTP 响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。\n\n![](https://camo.githubusercontent.com/2f5acdeefff9a281d03db7defe011fff037cf1ee/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139333333392e706e67)\n\n异步过程中的回调函数，**一定不在当前这一轮事件循环中执行**。\n\n### 六、异步与事件\n消息队列中的每条消息实际上都对应着一个事件。\n\n其中一个重要的异步过程就是： **DOM事件**\n\n```js\nvar button = document.getElementById('button')\nbutton.addEventLister('click', function(e) {\n    console.log('事件')\n})\n```\n\n从异步的角度看，`addEventLister` 函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放在消息队列中，等待主线程执行。\n\n事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。\n\n另外，所有的异步过程也都可以用事件来描述。例如：\n\n```js\nsetTimeout(func, 1000)\n// 可以看成：\ntimer.addEventLister('timeout', 1000, func)\n```\n\n其中关于事件的详细描述，可以看这篇文章： [事件绑定、事件监听、事件委托](http://blog.xieliqun.com/2016/08/12/event-delegate/)，这里不再深入介绍。\n\n### 七、生产者与消费者\n生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加数据，消费者从存储空间中取走数据，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。\n\n![](https://camo.githubusercontent.com/a717134740586438955fb819b2b76d07ff4d3295/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139323732312e676966)\n\n从生产者与消费者的角度看，异步过程是这样的：\n\n工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。\n\n那么异步的实现方式有哪些？\n\n* ES6之前：回调函数、eventloop事件机制、Promise、发布/订阅\n* ES6：Generator\n* ES7: Async/Await\n\n\n\n---\n\n参考：\n[瓶子君 blog](https://github.com/sisterAn/blog/issues/11)\n\n[瓶子君 Generator](https://github.com/sisterAn/blog/issues/23)\n\n[瓶子君 co函数](https://github.com/sisterAn/blog/issues/27)","source":"_posts/浏览器异步（一）.md","raw":"---\ntitle: 浏览器异步（一）\ndate: 2020-07-17 23:10:05\ntags: JS\n---\n\n> 注： 转载瓶子君文章 [详细连接](https://github.com/sisterAn/blog/issues/11)\n\n已知，JavaScript 是单线程的，天生异步，适合 IO 密集型，不适合 CPU 密集型，但是，为什么是异步的，异步由何而来的，我们将在这里逐渐讨论实现。\n\n### 一、进程与线程\n#### 1. 浏览器是多进程的\n它主要包括以下进程：\n\n* Browser 进程：浏览器的主进程，唯一，负责创建和销毁其它进程、网络资源的下载与管理、浏览器界面的展示、前进后退等。\n* GPU 进程：用于 3D 绘制等，最多一个。\n* 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。\n* 浏览器渲染进程（浏览器内核）：内部是多线程的，每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。\n\n#### 2. 渲染进程（浏览器内核）\n浏览器的渲染进程是多线程的，页面的渲染，JavaScript 的执行，事件的循环，都在这个进程内进行：\n\n* GUI 渲染线程：负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。\n* JavaScript 引擎线程：也称为 JavaScript 内核，负责处理 Javascript 脚本程序、解析 Javascript 脚本、运行代码等。（例如 V8 引擎）\n* 事件触发线程：用来控制浏览器事件循环，注意这不归 JavaScript 引擎线程管，当事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。\n* 定时触发器线程：传说中的 `setInterval` 与 `setTimeout` 所在线程，注意，W3C 在 HTML 标准中规定，规定要求 `setTimeout` 中低于 4ms 的时间间隔算为 4ms 。\n* 异步 http 请求线程：在 `XMLHttpRequest` 连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。\n\n注意，**GUI 渲染线程与 JavaScript 引擎线程是互斥的**，当 JavaScript 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中**等到 JavaScript 引擎空闲时**立即被执行。所以如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n\n### 二、单线程的 JavaScript\n所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。\n\n**问题：首先为什么要引入单线程？**\n\n我们知道：\n\n* 浏览器需要渲染 DOM\n* JavaScript 可以修改 DOM 结构\n* JavaScript 执行时，浏览器 DOM 渲染停止\n\n如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都修改 DOM，那么就会出现 DOM 冲突。\n\n你可能会说，[web worker](http://www.ruanyifeng.com/blog/2018/07/web-worker.html) 就支持多线程，但是 web worker 不能访问 window 对象，document 对象等。\n\n**原因：避免 DOM 渲染的冲突**\n\n当然，我们可以为浏览器引入**锁** 的机制来解决这些冲突，但其大大提高了复杂性，所以 JavaScript从诞生开始就选择了单线程执行。\n\n引入单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这同时又导致了一个问题：如果前一个任务耗时很长，后一个任务就不得不一直等着。\n\n```js\n// 实例1\nlet i, sum = 0\nfor(i = 0; i < 1000000000; i ++) {\n    sum += i\n}\nconsole.log(sum)\n```\n\n在实例1中，`sum` 并不能立刻打印出来，必须在 for 循环执行完成之后才能执行 `console.log(sum)` 。\n\n```js\n// 实例2\nconsole.log(1)\nalert('hello')\nconsole.log(2)\n```\n\n在实例2中，浏览器先打印 `1` ，然后弹出弹框，点击确定后才执行 `console.log(2)` 。\n\n**总结：**\n\n* 优点：实现比较简单，执行环境相对单纯\n* 缺点：只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 Javascript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。\n\n为了解决这个问题，JavaScript 语言将任务的执行模式分为两种：同步和异步\n\n### 三、同步与异步\n#### 1. 同步\n```js\nfunc(args...)\n```\n\n如果在函数 `func` 返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。\n\n```js\nlet a = 1\nMath.floor(a)\nconsole.log(a) // 1\n```\n\n#### 2. 异步\n如果在函数 `func` 返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。\n\n```js\nfs.readFile('foo.txt', 'utf8', function(err, data) {\n    console.log(data);\n});\n```\n\n**总结：**\n\nJavaScript 采用异步编程原因有两点，\n\n* 一是 JavaScript 是单线程；\n* 二是为了提高 CPU 的利用率。\n\n### 四、异步过程\n```js\nfs.readFile('data.json', 'utf8', function(err, data) {\n    console.log(data)\n})\n```\n\n在执行这段代码时，`fs.readFile` 函数返回时，并不会立刻打印 `data` ，只有 `data.json` 读取完成时才打印。也就是异步函数 `fs.readFile` 执行很快，但后面还有工作线程执行异步任务、通知主线程、主线程回调等操作，这个过程就叫做异步过程。\n\n主线程发起一个异步操作，相应的工作线程接受请求并告知主线程已收到（异步函数返回）；主线程继续执行后面的任务，同时工作线程执行异步任务；工作线程完成任务后，通知主线程；主线程收到通知后，执行一定的动作（调用回调函数）。\n\n工作线程在异步操作完成后通知主线程，那么这个通知机制又是如何显现？答案就是就是消息队列与事件循环。\n\n### 五、消息队列与事件循环\n工作线程将消息放在消息队列，主线程通过事件循环过程去取消息。\n\n* 消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。\n* 事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。\n\n#### 1. 事件循环（eventloop）\n主线程不断的从消息队列中取消息，执行消息，这个过程称为事件循环，这种机制叫事件循环机制，取一次消息并执行的过程叫一次循环。\n\n大致实现过程如下：\n\n```js\nwhile(true) {\n    var message = queue.get()\n    execute(message)\n}\n```\n\n例如：\n\n```js\n$.ajax({\n    url: 'xxxx',\n    success: function(result) {\n        console.log(1)\n    }\n})\nsetTimeout(function() {\n    console.log(2)\n}, 100)\nsetTimeout(function() {\n    console.log(3)\n})\nconsole.log(4)\n// output：4321 或 4312\n```\n\n其中，主线程：\n\n```js\n// 主线程\nconsole.log(4)\n```\n\n异步队列：\n\n```js\n// 异步队列\nfunction () {\n    console.log(3)\n}\nfunction () { // 100ms后\n    console.log(2)\n}\nfunction() { // ajax加载完成之后\n    console.log(1)\n}\n```\n\n**事件循环是JavaScript实现异步的具体解决方案，其中同步代码，直接执行；异步函数先放在异步队列中，待同步函数执行完毕后，轮询执行 异步队列 的回调函数。**\n\n#### 2. 消息队列\n其中，消息就是注册异步任务时添加的回调函数。\n\n```js\n$.ajax('XXX', function(res) {\n    console.log(res)\n})\n...\n```\n\n主线程在发起 AJAX 请求后，会继续执行其他代码，AJAX 线程负责请求 `XXX`，拿到请求后，会封装成 JavaScript 对象，然后构造一条消息：\n\n```js\n// 消息队列里的消息\nvar message = function () {\n    callback(response)\n}\n```\n\n其中 `callback` 是 AJAX 网络请求成功响应时的回调函数。\n\n主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是 `message` 函数)，并执行它。到此为止，就完成了工作线程对主线程的 `通知` ，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，AJAX 线程在收到 HTTP 响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。\n\n![](https://camo.githubusercontent.com/2f5acdeefff9a281d03db7defe011fff037cf1ee/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139333333392e706e67)\n\n异步过程中的回调函数，**一定不在当前这一轮事件循环中执行**。\n\n### 六、异步与事件\n消息队列中的每条消息实际上都对应着一个事件。\n\n其中一个重要的异步过程就是： **DOM事件**\n\n```js\nvar button = document.getElementById('button')\nbutton.addEventLister('click', function(e) {\n    console.log('事件')\n})\n```\n\n从异步的角度看，`addEventLister` 函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放在消息队列中，等待主线程执行。\n\n事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。\n\n另外，所有的异步过程也都可以用事件来描述。例如：\n\n```js\nsetTimeout(func, 1000)\n// 可以看成：\ntimer.addEventLister('timeout', 1000, func)\n```\n\n其中关于事件的详细描述，可以看这篇文章： [事件绑定、事件监听、事件委托](http://blog.xieliqun.com/2016/08/12/event-delegate/)，这里不再深入介绍。\n\n### 七、生产者与消费者\n生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加数据，消费者从存储空间中取走数据，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。\n\n![](https://camo.githubusercontent.com/a717134740586438955fb819b2b76d07ff4d3295/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139323732312e676966)\n\n从生产者与消费者的角度看，异步过程是这样的：\n\n工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。\n\n那么异步的实现方式有哪些？\n\n* ES6之前：回调函数、eventloop事件机制、Promise、发布/订阅\n* ES6：Generator\n* ES7: Async/Await\n\n\n\n---\n\n参考：\n[瓶子君 blog](https://github.com/sisterAn/blog/issues/11)\n\n[瓶子君 Generator](https://github.com/sisterAn/blog/issues/23)\n\n[瓶子君 co函数](https://github.com/sisterAn/blog/issues/27)","slug":"浏览器异步（一）","published":1,"updated":"2020-07-20T12:27:02.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmrae001fz5o83h8x87jl","content":"<blockquote>\n<p>注： 转载瓶子君文章 <a href=\"https://github.com/sisterAn/blog/issues/11\" target=\"_blank\" rel=\"noopener\">详细连接</a></p>\n</blockquote>\n<p>已知，JavaScript 是单线程的，天生异步，适合 IO 密集型，不适合 CPU 密集型，但是，为什么是异步的，异步由何而来的，我们将在这里逐渐讨论实现。</p>\n<h3 id=\"一、进程与线程\"><a href=\"#一、进程与线程\" class=\"headerlink\" title=\"一、进程与线程\"></a>一、进程与线程</h3><h4 id=\"1-浏览器是多进程的\"><a href=\"#1-浏览器是多进程的\" class=\"headerlink\" title=\"1. 浏览器是多进程的\"></a>1. 浏览器是多进程的</h4><p>它主要包括以下进程：</p>\n<ul>\n<li>Browser 进程：浏览器的主进程，唯一，负责创建和销毁其它进程、网络资源的下载与管理、浏览器界面的展示、前进后退等。</li>\n<li>GPU 进程：用于 3D 绘制等，最多一个。</li>\n<li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。</li>\n<li>浏览器渲染进程（浏览器内核）：内部是多线程的，每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。</li>\n</ul>\n<h4 id=\"2-渲染进程（浏览器内核）\"><a href=\"#2-渲染进程（浏览器内核）\" class=\"headerlink\" title=\"2. 渲染进程（浏览器内核）\"></a>2. 渲染进程（浏览器内核）</h4><p>浏览器的渲染进程是多线程的，页面的渲染，JavaScript 的执行，事件的循环，都在这个进程内进行：</p>\n<ul>\n<li>GUI 渲染线程：负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。</li>\n<li>JavaScript 引擎线程：也称为 JavaScript 内核，负责处理 Javascript 脚本程序、解析 Javascript 脚本、运行代码等。（例如 V8 引擎）</li>\n<li>事件触发线程：用来控制浏览器事件循环，注意这不归 JavaScript 引擎线程管，当事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。</li>\n<li>定时触发器线程：传说中的 <code>setInterval</code> 与 <code>setTimeout</code> 所在线程，注意，W3C 在 HTML 标准中规定，规定要求 <code>setTimeout</code> 中低于 4ms 的时间间隔算为 4ms 。</li>\n<li>异步 http 请求线程：在 <code>XMLHttpRequest</code> 连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就<strong>产生状态变更事件</strong>，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li>\n</ul>\n<p>注意，<strong>GUI 渲染线程与 JavaScript 引擎线程是互斥的</strong>，当 JavaScript 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中<strong>等到 JavaScript 引擎空闲时</strong>立即被执行。所以如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>\n<h3 id=\"二、单线程的-JavaScript\"><a href=\"#二、单线程的-JavaScript\" class=\"headerlink\" title=\"二、单线程的 JavaScript\"></a>二、单线程的 JavaScript</h3><p>所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。</p>\n<p><strong>问题：首先为什么要引入单线程？</strong></p>\n<p>我们知道：</p>\n<ul>\n<li>浏览器需要渲染 DOM</li>\n<li>JavaScript 可以修改 DOM 结构</li>\n<li>JavaScript 执行时，浏览器 DOM 渲染停止</li>\n</ul>\n<p>如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都修改 DOM，那么就会出现 DOM 冲突。</p>\n<p>你可能会说，<a href=\"http://www.ruanyifeng.com/blog/2018/07/web-worker.html\" target=\"_blank\" rel=\"noopener\">web worker</a> 就支持多线程，但是 web worker 不能访问 window 对象，document 对象等。</p>\n<p><strong>原因：避免 DOM 渲染的冲突</strong></p>\n<p>当然，我们可以为浏览器引入<strong>锁</strong> 的机制来解决这些冲突，但其大大提高了复杂性，所以 JavaScript从诞生开始就选择了单线程执行。</p>\n<p>引入单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这同时又导致了一个问题：如果前一个任务耗时很长，后一个任务就不得不一直等着。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实例1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> i, sum = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000000</span>; i ++) &#123;</span><br><span class=\"line\">    sum += i</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum)</span><br></pre></td></tr></table></figure>\n\n<p>在实例1中，<code>sum</code> 并不能立刻打印出来，必须在 for 循环执行完成之后才能执行 <code>console.log(sum)</code> 。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实例2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">alert(<span class=\"string\">'hello'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<p>在实例2中，浏览器先打印 <code>1</code> ，然后弹出弹框，点击确定后才执行 <code>console.log(2)</code> 。</p>\n<p><strong>总结：</strong></p>\n<ul>\n<li>优点：实现比较简单，执行环境相对单纯</li>\n<li>缺点：只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 Javascript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</li>\n</ul>\n<p>为了解决这个问题，JavaScript 语言将任务的执行模式分为两种：同步和异步</p>\n<h3 id=\"三、同步与异步\"><a href=\"#三、同步与异步\" class=\"headerlink\" title=\"三、同步与异步\"></a>三、同步与异步</h3><h4 id=\"1-同步\"><a href=\"#1-同步\" class=\"headerlink\" title=\"1. 同步\"></a>1. 同步</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func(args...)</span><br></pre></td></tr></table></figure>\n\n<p>如果在函数 <code>func</code> 返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.floor(a)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-异步\"><a href=\"#2-异步\" class=\"headerlink\" title=\"2. 异步\"></a>2. 异步</h4><p>如果在函数 <code>func</code> 返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.readFile(<span class=\"string\">'foo.txt'</span>, <span class=\"string\">'utf8'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结：</strong></p>\n<p>JavaScript 采用异步编程原因有两点，</p>\n<ul>\n<li>一是 JavaScript 是单线程；</li>\n<li>二是为了提高 CPU 的利用率。</li>\n</ul>\n<h3 id=\"四、异步过程\"><a href=\"#四、异步过程\" class=\"headerlink\" title=\"四、异步过程\"></a>四、异步过程</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.readFile(<span class=\"string\">'data.json'</span>, <span class=\"string\">'utf8'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在执行这段代码时，<code>fs.readFile</code> 函数返回时，并不会立刻打印 <code>data</code> ，只有 <code>data.json</code> 读取完成时才打印。也就是异步函数 <code>fs.readFile</code> 执行很快，但后面还有工作线程执行异步任务、通知主线程、主线程回调等操作，这个过程就叫做异步过程。</p>\n<p>主线程发起一个异步操作，相应的工作线程接受请求并告知主线程已收到（异步函数返回）；主线程继续执行后面的任务，同时工作线程执行异步任务；工作线程完成任务后，通知主线程；主线程收到通知后，执行一定的动作（调用回调函数）。</p>\n<p>工作线程在异步操作完成后通知主线程，那么这个通知机制又是如何显现？答案就是就是消息队列与事件循环。</p>\n<h3 id=\"五、消息队列与事件循环\"><a href=\"#五、消息队列与事件循环\" class=\"headerlink\" title=\"五、消息队列与事件循环\"></a>五、消息队列与事件循环</h3><p>工作线程将消息放在消息队列，主线程通过事件循环过程去取消息。</p>\n<ul>\n<li>消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。</li>\n<li>事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。</li>\n</ul>\n<h4 id=\"1-事件循环（eventloop）\"><a href=\"#1-事件循环（eventloop）\" class=\"headerlink\" title=\"1. 事件循环（eventloop）\"></a>1. 事件循环（eventloop）</h4><p>主线程不断的从消息队列中取消息，执行消息，这个过程称为事件循环，这种机制叫事件循环机制，取一次消息并执行的过程叫一次循环。</p>\n<p>大致实现过程如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = queue.get()</span><br><span class=\"line\">    execute(message)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">'xxxx'</span>,</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">// output：4321 或 4312</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，主线程：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主线程</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n\n<p>异步队列：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 异步队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 100ms后</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// ajax加载完成之后</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>事件循环是JavaScript实现异步的具体解决方案，其中同步代码，直接执行；异步函数先放在异步队列中，待同步函数执行完毕后，轮询执行 异步队列 的回调函数。</strong></p>\n<h4 id=\"2-消息队列\"><a href=\"#2-消息队列\" class=\"headerlink\" title=\"2. 消息队列\"></a>2. 消息队列</h4><p>其中，消息就是注册异步任务时添加的回调函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(<span class=\"string\">'XXX'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>主线程在发起 AJAX 请求后，会继续执行其他代码，AJAX 线程负责请求 <code>XXX</code>，拿到请求后，会封装成 JavaScript 对象，然后构造一条消息：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 消息队列里的消息</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    callback(response)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>callback</code> 是 AJAX 网络请求成功响应时的回调函数。</p>\n<p>主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是 <code>message</code> 函数)，并执行它。到此为止，就完成了工作线程对主线程的 <code>通知</code> ，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，AJAX 线程在收到 HTTP 响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。</p>\n<p><img src=\"https://camo.githubusercontent.com/2f5acdeefff9a281d03db7defe011fff037cf1ee/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139333333392e706e67\" alt></p>\n<p>异步过程中的回调函数，<strong>一定不在当前这一轮事件循环中执行</strong>。</p>\n<h3 id=\"六、异步与事件\"><a href=\"#六、异步与事件\" class=\"headerlink\" title=\"六、异步与事件\"></a>六、异步与事件</h3><p>消息队列中的每条消息实际上都对应着一个事件。</p>\n<p>其中一个重要的异步过程就是： <strong>DOM事件</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> button = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'button'</span>)</span><br><span class=\"line\">button.addEventLister(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'事件'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>从异步的角度看，<code>addEventLister</code> 函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放在消息队列中，等待主线程执行。</p>\n<p>事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。</p>\n<p>另外，所有的异步过程也都可以用事件来描述。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(func, <span class=\"number\">1000</span>)</span><br><span class=\"line\"><span class=\"comment\">// 可以看成：</span></span><br><span class=\"line\">timer.addEventLister(<span class=\"string\">'timeout'</span>, <span class=\"number\">1000</span>, func)</span><br></pre></td></tr></table></figure>\n\n<p>其中关于事件的详细描述，可以看这篇文章： <a href=\"http://blog.xieliqun.com/2016/08/12/event-delegate/\" target=\"_blank\" rel=\"noopener\">事件绑定、事件监听、事件委托</a>，这里不再深入介绍。</p>\n<h3 id=\"七、生产者与消费者\"><a href=\"#七、生产者与消费者\" class=\"headerlink\" title=\"七、生产者与消费者\"></a>七、生产者与消费者</h3><p>生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加数据，消费者从存储空间中取走数据，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。</p>\n<p><img src=\"https://camo.githubusercontent.com/a717134740586438955fb819b2b76d07ff4d3295/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139323732312e676966\" alt></p>\n<p>从生产者与消费者的角度看，异步过程是这样的：</p>\n<p>工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。</p>\n<p>那么异步的实现方式有哪些？</p>\n<ul>\n<li>ES6之前：回调函数、eventloop事件机制、Promise、发布/订阅</li>\n<li>ES6：Generator</li>\n<li>ES7: Async/Await</li>\n</ul>\n<hr>\n<p>参考：<br><a href=\"https://github.com/sisterAn/blog/issues/11\" target=\"_blank\" rel=\"noopener\">瓶子君 blog</a></p>\n<p><a href=\"https://github.com/sisterAn/blog/issues/23\" target=\"_blank\" rel=\"noopener\">瓶子君 Generator</a></p>\n<p><a href=\"https://github.com/sisterAn/blog/issues/27\" target=\"_blank\" rel=\"noopener\">瓶子君 co函数</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>注： 转载瓶子君文章 <a href=\"https://github.com/sisterAn/blog/issues/11\" target=\"_blank\" rel=\"noopener\">详细连接</a></p>\n</blockquote>\n<p>已知，JavaScript 是单线程的，天生异步，适合 IO 密集型，不适合 CPU 密集型，但是，为什么是异步的，异步由何而来的，我们将在这里逐渐讨论实现。</p>\n<h3 id=\"一、进程与线程\"><a href=\"#一、进程与线程\" class=\"headerlink\" title=\"一、进程与线程\"></a>一、进程与线程</h3><h4 id=\"1-浏览器是多进程的\"><a href=\"#1-浏览器是多进程的\" class=\"headerlink\" title=\"1. 浏览器是多进程的\"></a>1. 浏览器是多进程的</h4><p>它主要包括以下进程：</p>\n<ul>\n<li>Browser 进程：浏览器的主进程，唯一，负责创建和销毁其它进程、网络资源的下载与管理、浏览器界面的展示、前进后退等。</li>\n<li>GPU 进程：用于 3D 绘制等，最多一个。</li>\n<li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。</li>\n<li>浏览器渲染进程（浏览器内核）：内部是多线程的，每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。</li>\n</ul>\n<h4 id=\"2-渲染进程（浏览器内核）\"><a href=\"#2-渲染进程（浏览器内核）\" class=\"headerlink\" title=\"2. 渲染进程（浏览器内核）\"></a>2. 渲染进程（浏览器内核）</h4><p>浏览器的渲染进程是多线程的，页面的渲染，JavaScript 的执行，事件的循环，都在这个进程内进行：</p>\n<ul>\n<li>GUI 渲染线程：负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。</li>\n<li>JavaScript 引擎线程：也称为 JavaScript 内核，负责处理 Javascript 脚本程序、解析 Javascript 脚本、运行代码等。（例如 V8 引擎）</li>\n<li>事件触发线程：用来控制浏览器事件循环，注意这不归 JavaScript 引擎线程管，当事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。</li>\n<li>定时触发器线程：传说中的 <code>setInterval</code> 与 <code>setTimeout</code> 所在线程，注意，W3C 在 HTML 标准中规定，规定要求 <code>setTimeout</code> 中低于 4ms 的时间间隔算为 4ms 。</li>\n<li>异步 http 请求线程：在 <code>XMLHttpRequest</code> 连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就<strong>产生状态变更事件</strong>，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li>\n</ul>\n<p>注意，<strong>GUI 渲染线程与 JavaScript 引擎线程是互斥的</strong>，当 JavaScript 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中<strong>等到 JavaScript 引擎空闲时</strong>立即被执行。所以如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>\n<h3 id=\"二、单线程的-JavaScript\"><a href=\"#二、单线程的-JavaScript\" class=\"headerlink\" title=\"二、单线程的 JavaScript\"></a>二、单线程的 JavaScript</h3><p>所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。</p>\n<p><strong>问题：首先为什么要引入单线程？</strong></p>\n<p>我们知道：</p>\n<ul>\n<li>浏览器需要渲染 DOM</li>\n<li>JavaScript 可以修改 DOM 结构</li>\n<li>JavaScript 执行时，浏览器 DOM 渲染停止</li>\n</ul>\n<p>如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都修改 DOM，那么就会出现 DOM 冲突。</p>\n<p>你可能会说，<a href=\"http://www.ruanyifeng.com/blog/2018/07/web-worker.html\" target=\"_blank\" rel=\"noopener\">web worker</a> 就支持多线程，但是 web worker 不能访问 window 对象，document 对象等。</p>\n<p><strong>原因：避免 DOM 渲染的冲突</strong></p>\n<p>当然，我们可以为浏览器引入<strong>锁</strong> 的机制来解决这些冲突，但其大大提高了复杂性，所以 JavaScript从诞生开始就选择了单线程执行。</p>\n<p>引入单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这同时又导致了一个问题：如果前一个任务耗时很长，后一个任务就不得不一直等着。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实例1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> i, sum = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000000</span>; i ++) &#123;</span><br><span class=\"line\">    sum += i</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum)</span><br></pre></td></tr></table></figure>\n\n<p>在实例1中，<code>sum</code> 并不能立刻打印出来，必须在 for 循环执行完成之后才能执行 <code>console.log(sum)</code> 。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实例2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">alert(<span class=\"string\">'hello'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<p>在实例2中，浏览器先打印 <code>1</code> ，然后弹出弹框，点击确定后才执行 <code>console.log(2)</code> 。</p>\n<p><strong>总结：</strong></p>\n<ul>\n<li>优点：实现比较简单，执行环境相对单纯</li>\n<li>缺点：只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 Javascript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</li>\n</ul>\n<p>为了解决这个问题，JavaScript 语言将任务的执行模式分为两种：同步和异步</p>\n<h3 id=\"三、同步与异步\"><a href=\"#三、同步与异步\" class=\"headerlink\" title=\"三、同步与异步\"></a>三、同步与异步</h3><h4 id=\"1-同步\"><a href=\"#1-同步\" class=\"headerlink\" title=\"1. 同步\"></a>1. 同步</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func(args...)</span><br></pre></td></tr></table></figure>\n\n<p>如果在函数 <code>func</code> 返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.floor(a)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-异步\"><a href=\"#2-异步\" class=\"headerlink\" title=\"2. 异步\"></a>2. 异步</h4><p>如果在函数 <code>func</code> 返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.readFile(<span class=\"string\">'foo.txt'</span>, <span class=\"string\">'utf8'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结：</strong></p>\n<p>JavaScript 采用异步编程原因有两点，</p>\n<ul>\n<li>一是 JavaScript 是单线程；</li>\n<li>二是为了提高 CPU 的利用率。</li>\n</ul>\n<h3 id=\"四、异步过程\"><a href=\"#四、异步过程\" class=\"headerlink\" title=\"四、异步过程\"></a>四、异步过程</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.readFile(<span class=\"string\">'data.json'</span>, <span class=\"string\">'utf8'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在执行这段代码时，<code>fs.readFile</code> 函数返回时，并不会立刻打印 <code>data</code> ，只有 <code>data.json</code> 读取完成时才打印。也就是异步函数 <code>fs.readFile</code> 执行很快，但后面还有工作线程执行异步任务、通知主线程、主线程回调等操作，这个过程就叫做异步过程。</p>\n<p>主线程发起一个异步操作，相应的工作线程接受请求并告知主线程已收到（异步函数返回）；主线程继续执行后面的任务，同时工作线程执行异步任务；工作线程完成任务后，通知主线程；主线程收到通知后，执行一定的动作（调用回调函数）。</p>\n<p>工作线程在异步操作完成后通知主线程，那么这个通知机制又是如何显现？答案就是就是消息队列与事件循环。</p>\n<h3 id=\"五、消息队列与事件循环\"><a href=\"#五、消息队列与事件循环\" class=\"headerlink\" title=\"五、消息队列与事件循环\"></a>五、消息队列与事件循环</h3><p>工作线程将消息放在消息队列，主线程通过事件循环过程去取消息。</p>\n<ul>\n<li>消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。</li>\n<li>事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。</li>\n</ul>\n<h4 id=\"1-事件循环（eventloop）\"><a href=\"#1-事件循环（eventloop）\" class=\"headerlink\" title=\"1. 事件循环（eventloop）\"></a>1. 事件循环（eventloop）</h4><p>主线程不断的从消息队列中取消息，执行消息，这个过程称为事件循环，这种机制叫事件循环机制，取一次消息并执行的过程叫一次循环。</p>\n<p>大致实现过程如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = queue.get()</span><br><span class=\"line\">    execute(message)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url: <span class=\"string\">'xxxx'</span>,</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">// output：4321 或 4312</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，主线程：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主线程</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n\n<p>异步队列：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 异步队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 100ms后</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// ajax加载完成之后</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>事件循环是JavaScript实现异步的具体解决方案，其中同步代码，直接执行；异步函数先放在异步队列中，待同步函数执行完毕后，轮询执行 异步队列 的回调函数。</strong></p>\n<h4 id=\"2-消息队列\"><a href=\"#2-消息队列\" class=\"headerlink\" title=\"2. 消息队列\"></a>2. 消息队列</h4><p>其中，消息就是注册异步任务时添加的回调函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(<span class=\"string\">'XXX'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>主线程在发起 AJAX 请求后，会继续执行其他代码，AJAX 线程负责请求 <code>XXX</code>，拿到请求后，会封装成 JavaScript 对象，然后构造一条消息：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 消息队列里的消息</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    callback(response)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>callback</code> 是 AJAX 网络请求成功响应时的回调函数。</p>\n<p>主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是 <code>message</code> 函数)，并执行它。到此为止，就完成了工作线程对主线程的 <code>通知</code> ，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，AJAX 线程在收到 HTTP 响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。</p>\n<p><img src=\"https://camo.githubusercontent.com/2f5acdeefff9a281d03db7defe011fff037cf1ee/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139333333392e706e67\" alt></p>\n<p>异步过程中的回调函数，<strong>一定不在当前这一轮事件循环中执行</strong>。</p>\n<h3 id=\"六、异步与事件\"><a href=\"#六、异步与事件\" class=\"headerlink\" title=\"六、异步与事件\"></a>六、异步与事件</h3><p>消息队列中的每条消息实际上都对应着一个事件。</p>\n<p>其中一个重要的异步过程就是： <strong>DOM事件</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> button = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'button'</span>)</span><br><span class=\"line\">button.addEventLister(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'事件'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>从异步的角度看，<code>addEventLister</code> 函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放在消息队列中，等待主线程执行。</p>\n<p>事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。</p>\n<p>另外，所有的异步过程也都可以用事件来描述。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(func, <span class=\"number\">1000</span>)</span><br><span class=\"line\"><span class=\"comment\">// 可以看成：</span></span><br><span class=\"line\">timer.addEventLister(<span class=\"string\">'timeout'</span>, <span class=\"number\">1000</span>, func)</span><br></pre></td></tr></table></figure>\n\n<p>其中关于事件的详细描述，可以看这篇文章： <a href=\"http://blog.xieliqun.com/2016/08/12/event-delegate/\" target=\"_blank\" rel=\"noopener\">事件绑定、事件监听、事件委托</a>，这里不再深入介绍。</p>\n<h3 id=\"七、生产者与消费者\"><a href=\"#七、生产者与消费者\" class=\"headerlink\" title=\"七、生产者与消费者\"></a>七、生产者与消费者</h3><p>生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加数据，消费者从存储空间中取走数据，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。</p>\n<p><img src=\"https://camo.githubusercontent.com/a717134740586438955fb819b2b76d07ff4d3295/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139323732312e676966\" alt></p>\n<p>从生产者与消费者的角度看，异步过程是这样的：</p>\n<p>工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。</p>\n<p>那么异步的实现方式有哪些？</p>\n<ul>\n<li>ES6之前：回调函数、eventloop事件机制、Promise、发布/订阅</li>\n<li>ES6：Generator</li>\n<li>ES7: Async/Await</li>\n</ul>\n<hr>\n<p>参考：<br><a href=\"https://github.com/sisterAn/blog/issues/11\" target=\"_blank\" rel=\"noopener\">瓶子君 blog</a></p>\n<p><a href=\"https://github.com/sisterAn/blog/issues/23\" target=\"_blank\" rel=\"noopener\">瓶子君 Generator</a></p>\n<p><a href=\"https://github.com/sisterAn/blog/issues/27\" target=\"_blank\" rel=\"noopener\">瓶子君 co函数</a></p>\n"},{"title":"浏览器异步（三）","date":"2020-07-17T16:54:40.000Z","_content":"\n> 此篇博文转载自瓶子君的blog [链接](https://github.com/sisterAn/blog/issues/13)，并加以自己的理解和注释。\n\n### Promise本质\n\n**Promise就是为了解决callback的问题而产生的。**\n\nPromise 本质上就是一个绑定了回调的对象，而不是将回调传回函数内部。\n\n**开门见山，Promise解决的是回调函数处理异步的第2个问题：控制反转**。\n\n我们把上面那个多层回调嵌套的例子用Promise的方式重构：\n\n```js\nlet getPromise1 = function () {\n    return new Promsie(function (resolve, reject) {\n        $.ajax({\n            url: 'XXX1',\n            success: function (data) {\n               let key = data;\n               resolve(key);         \n            },\n            error: function (err) {\n                reject(err);\n            }\n        });\n    });\n};\n\nlet getPromise2 = function (key) {\n    return new Promsie(function (resolve, reject) {\n        $.ajax({\n            url: 'XXX2',\n            data: {\n                key: key\n            },\n            success: function (data) {\n                resolve(data);         \n            },\n            error: function (err) {\n                reject(err);\n            }\n        });\n    });\n};\n\nlet getPromise3 = function () {\n    \n    return new Promsie(function (resolve, reject) {\n        $.ajax({\n            url: 'XXX3',\n            success: function (data) {\n                resolve(data);         \n            },\n            error: function (err) {\n                reject(err);\n            }\n        });\n    });\n};\n\ngetPromise1()\n    .then(function (key) {\n        return getPromise2(key);\n    })\n    .then(function (data) {\n        return getPromise3(data);\n    })\n    .then(function (data) {\n    \t// todo\n        console.log('业务数据：', data);\n    })\n    .catch(function (err) {\n        console.log(err);\n    }); \n```\n\nPromise 在一定程度上其实改善了回调函数的书写方式；另外逻辑性更明显了，将异步业务提取成单个函数，整个流程可以看到是一步步向下执行的，依赖层级也很清晰，最后需要的数据是在整个代码的最后一步获得。\n\n所以，Promise在一定程度上解决了回调函数的书写结构问题，但回调函数依然在主流程上存在，只不过都放到了then(...)里面，和我们大脑顺序线性的思维逻辑还是有出入的。\n\n### Promise 是什么\nPromise是什么，无论是ES6的Promise也好，jQuery的Promise也好，不同的库有不同的实现，但是大家遵循的都是同一套规范，所以，Promise并不指特定的某个实现，**它是一种规范，是一套处理JavaScript异步的机制**。\n\nPromise的规范会多，如Promise/A、Promise/B、Promise/D以及Promise/A的升级版Promise/A+，其中ES6遵循Promise/A+规范，有关Promise/A+，你可以参考一下：\n\n* 英文版：[Promise/A+](https://promisesaplus.com)\n* 翻译版：[【翻译】Promises/A+规范](http://www.ituring.com.cn/article/66566)\n\n这里只简要介绍下几点与接下来内容相关的规范：\n\n* Promise 本质是一个状态机，每个 Promise 有三种状态：pending、resolved以及rejected。状态转变只能是pending —resolved 或者 pending —rejected。状态转变不可逆。\n* then 方法可以被同一个 promise 调用多次。\n* then 方法必须返回一个 promise。规范2.2.7中规定， then 必须返回一个新的 Promise\n* 值穿透\n\n### Promise 实现及源码解读\n首先，我们看一下Promise的简单使用：\n\n```js\nvar p = new Promise(function(resolve, reject) {\n    // Do an async task async task and then...\n    if(/* good condition */) {\n        resolve('Success!');\n    }\n    else {\n        reject('Failure!');\n    }\n});\np.then(function() { \n    /* do something with the result */\n}).catch(function() {\n    /* error :( */\n})\n```\n\n我们通过这种使用构建Promise实现的第一个版本\n\n**自己的写法也是结合调用实例的逆推过程**。\n\n为什么要将callback单独传入呢？因为啊，new Promise(... ) 这括号里的函数逻辑是由我们编写的，可调整可修改，在任何条件下的resolve和reject，所以封装的时候最好写成一个通用的回调函数。\n\n#### Promise构建版本一\n\n```js\nfunction MyPromise(callback) {\n    var _this = this\n    _this.value = void 0 // Promise的值\n    var onResolvedCallback  // Promise resolve回调函数\n    var onRejectedCallback  // Promise reject回调函数\n    // resolve 处理函数\n    _this.resolve = function (value) {\n        onResolvedCallback()\n    } \n    // reject 处理函数\n    _this.reject = function (error) {\n        onRejectedCallback()\n    } \n    callback(_this.resolve, _this.reject) // 执行callback并传入相应的参数\n}\n// 添加 then 方法 因为是promise的实例需要用到，所以then最好挂载在promise的原型上\nMyPromise.prototype.then = function(resolve, reject) {}\n```\n\n大致框架已经出来了，但我们看到Promise状态、reslove函数、reject函数以及then等都没有处理。\n\n#### Promise构建之二：链式存储\n\n链式存储：讲的就是promise实例会有很多次then，然后下一次的then都会获得上一次的then的结果，就像链式一般。将结果存储下去，直至return。\n\n首先，举个例子：\n\n```js\nnew Promise(function (resolve, reject) {\n    setTimeout(function () {\n        var a=1;\n        resolve(a);\n    }, 1000);\n}).then(function (res) {\n    console.log(res);\n    return new Promise(function (resolve, reject) {\n        setTimeout(function () {\n            var b=2;\n            resolve(b);\n        }, 1000);\n    })\n}).then(function (res) {\n    console.log(res);\n    return new Promise(function (resolve, reject) {\n        setTimeout(function () {\n            var c=3\n            resolve(c);\n        }, 1000);\n    })\n}).then(function (res) {\n    console.log(res);\n})\n```\n\n上例结果是每间隔1s打印一个数字，顺序为1、2、3。\n\n这里保证了：\n\n* 让a,b,c的值能在then里面的回调接收到\n* 在连续调用异步，如何确保异步函数的执行顺序\n\nPromise一个常见的需求就是连续执行两个或者多个异步操作，这种情况下，每一个后来的操作都在前面的操作执行成功之后，带着上一步操作所返回的结果开始执行。这里用`setTimeout`来处理\n\n```js\nfunction MyPromise(callback) {\n    var _this = this\n    _this.value = void 0 // Promise的值\n    // 用于保存 then 的回调， 只有当 promise\n    // 状态为 pending 时才会缓存，并且每个实例至多缓存一个\n    _this.onResolvedCallbacks = [] // Promise resolve时的回调函数集\n    _this.onRejectedCallbacks = [] // Promise reject时的回调函数集\n    _this.resolve = function (value) {\n        setTimeout(() => { // 异步执行\n            _this.onResolvedCallbacks.forEach(cb =cb())\n        })\n    } // resolve 处理函数\n    _this.reject = function (error) {\n        setTimeout(() => { // 异步执行\n            _this.onRejectedCallbacks.forEach(cb =cb())\n        })\n    } // reject 处理函数\n    callback(_this.resolve, _this.reject) // 执行callback并传入相应的参数\n}\n// 添加 then 方法\nMyPromise.prototype.then = function() {}\n```\n\n#### Promise构建之三：状态机制、顺序执行\n为了保证Promise的异步操作时的顺序执行，这里给Promise加上状态机制\n\n```js\n// 三种状态\nconst PENDING = \"pending\"\nconst RESOLVED = \"resolved\"\nconst REJECTED = \"rejected\"\nfunction MyPromise(callback) {\n    var _this = this\n    _this.currentState = PENDING // Promise当前的状态\n    _this.value = void 0 // Promise的值\n    // 用于保存 then 的回调， 只有当 promise\n    // 状态为 pending 时才会缓存，并且每个实例至多缓存一个\n    _this.onResolvedCallbacks = [] // Promise resolve时的回调函数集\n    _this.onRejectedCallbacks = [] // Promise reject时的回调函数集\n    _this.resolve = function (value) {\n        setTimeout(() => { // 异步执行，保证顺序执行\n            if (_this.currentState === PENDING) {\n                _this.currentState = RESOLVED // 状态管理\n                _this.value = value\n                _this.onResolvedCallbacks.forEach(cb => cb())\n            }\n        })\n    } // resolve 处理函数\n    _this.reject = function (value) {\n        setTimeout(() => { // 异步执行，保证顺序执行\n            if (_this.currentState === PENDING) {\n            \t_this.currentState = REJECTED // 状态管理\n            \t_this.value = value\n            \t_this.onRejectedCallbacks.forEach(cb => cb())\n        \t}\n        })\n    } // reject 处理函数\n    callback(_this.resolve, _this.reject) // 执行callback并传入相应的参数\n}\n// 添加 then 方法\nMyPromise.prototype.then = function() {}\n```\n\n#### Promise构建之四：递归执行\n每个Promise后面链接一个对象，该对象包含onresolved,onrejected,子promise三个属性.\n\n当父Promise 状态改变完毕,执行完相应的onresolved/onrejected的时候，拿到子promise,在等待这个子promise状态改变，在执行相应的onresolved/onrejected。依次循环直到当前promise没有子promise。\n\n```js\n// 三种状态\nconst PENDING = \"pending\"\nconst RESOLVED = \"resolved\"\nconst REJECTED = \"rejected\"\nfunction MyPromise(callback) {\n    var _this = this\n    _this.currentState = PENDING // Promise当前的状态\n    _this.value = void 0 // Promise的值\n    // 用于保存 then 的回调， 只有当 promise\n    // 状态为 pending 时才会缓存，并且每个实例至多缓存一个\n    _this.onResolvedCallbacks = [] // Promise resolve时的回调函数集\n    _this.onRejectedCallbacks = [] // Promise reject时的回调函数集\n    _this.resolve = function (value) {\n        if (value instanceof MyPromise) {\n            // 如果 value 是个 MyPromise， 递归执行\n            return value.then(_this.resolve, _this.reject)\n        }\n        setTimeout(() => { // 异步执行，保证顺序执行\n            if (_this.currentState === PENDING) {\n                _this.currentState = RESOLVED // 状态管理\n                _this.value = value\n                _this.onResolvedCallbacks.forEach(cb => cb())\n            }\n        })\n    } // resolve 处理函数\n    _this.reject = function (value) {\n        setTimeout(() => { // 异步执行，保证顺序执行\n            if (_this.currentState === PENDING) {\n            \t_this.currentState = REJECTED // 状态管理\n            \t_this.value = value\n            \t_this.onRejectedCallbacks.forEach(cb => cb())\n        \t}\n        })\n    } // reject 处理函数\n    callback(_this.resolve, _this.reject) // 执行callback并传入相应的参数\n}\n// 添加 then 方法\nMyPromise.prototype.then = function() {}\n```\n\n#### Promise构建之五：异常处理\n```js\n// 三种状态\nconst PENDING = \"pending\"\nconst RESOLVED = \"resolved\"\nconst REJECTED = \"rejected\"\nfunction MyPromise(callback) {\n    var _this = this\n    _this.currentState = PENDING // Promise当前的状态\n    _this.value = void 0 // Promise的值\n    // 用于保存 then 的回调， 只有当 promise\n    // 状态为 pending 时才会缓存，并且每个实例至多缓存一个\n    _this.onResolvedCallbacks = [] // Promise resolve时的回调函数集\n    _this.onRejectedCallbacks = [] // Promise reject时的回调函数集\n    _this.resolve = function (value) {\n        if (value instanceof MyPromise) {\n            // 如果 value 是个 MyPromise， 递归执行\n            return value.then(_this.resolve, _this.reject)\n        }\n        setTimeout(() => { // 异步执行，保证顺序执行\n            if (_this.currentState === PENDING) {\n                _this.currentState = RESOLVED // 状态管理\n                _this.value = value\n                _this.onResolvedCallbacks.forEach(cb => cb())\n            }\n        })\n    } // resolve 处理函数\n    _this.reject = function (error) {\n        setTimeout(() => { // 异步执行，保证顺序执行\n            if (_this.currentState === PENDING) {\n            \t_this.currentState = REJECTED // 状态管理\n            \t_this.value = value\n            \t_this.onRejectedCallbacks.forEach(cb => cb())\n        \t}\n        })\n    } // reject 处理函数\n    \n    // 异常处理\n    // new Promise(() =throw Error('error'))\n    try {\n        callback(_this.resolve, _this.reject) // 执行callback并传入相应的参数\n    } catch(e) {\n        _this.reject(e)\n    }\n}\n// 添加 then 方法\nMyPromise.prototype.then = function() {}\n```\n\n#### Promise构建之六：then的实现\nthen 方法是 Promise 的核心，这里做一下详细介绍。\n\n```js\npromise.then(onFulfilled, onRejected)\n```\n\n一个 Promise 的then接受两个参数： onFulfilled和onRejected（都是可选参数，并且为函数，若不是函数将被忽略）\n\n* onFulfilled 特性：\n  \n  * 当 Promise 执行结束后其必须被调用，其第一个参数为 promise 的终值，也就是 resolve 传过来的值\n  * 在 Promise 执行结束前不可被调用\n  * 其调用次数不可超过一次\n* onRejected 特性\n  \n  * 当 Promise 被拒绝执行后其必须被调用，第一个参数为 Promise 的拒绝原因，也就是reject传过来的值\n  * 在 Promise 执行结束前不可被调用\n  * 其调用次数不可超过一次\n* 调用时机\n  `onFulfilled` 和 `onRejected` 只有在[执行环境](http://es5.github.io/#x10.3)堆栈仅包含**平台代码**时才可被调用（平台代码指引擎、环境以及 promise 的实施代码）\n* 调用要求\n  `onFulfilled` 和 `onRejected` 必须被作为函数调用（即没有 `this` 值，在 **严格模式（strict）** 中，函数 `this` 的值为 `undefined` ；在非严格模式中其为全局对象。）\n* 多次调用\n  `then` 方法可以被同一个 `promise` 调用多次\n  \n  * 当 `promise` 成功执行时，所有 `onFulfilled` 需按照其注册顺序依次回调\n  * 当 `promise` 被拒绝执行时，所有的 `onRejected` 需按照其注册顺序依次回调\n* 返回\n  `then`方法会返回一个`Promise`，关于这一点，Promise/A+标准并没有要求返回的这个Promise是一个新的对象，但在Promise/A标准中，明确规定了then要返回一个新的对象，目前的Promise实现中then几乎都是返回一个新的Promise([详情](https://promisesaplus.com/differences-from-promises-a#point-5))对象，所以在我们的实现中，也让then返回一个新的Promise对象。\n  ```\n  promise2 = promise1.then(onFulfilled, onRejected);\n  ```\n  \n  \n  \n  * 如果 `onFulfilled` 或者 `onRejected` 返回一个值 `x` ，则运行下面的 **Promise 解决过程**：`[[Resolve]](promise2, x)`\n  * 如果 `onFulfilled` 或者 `onRejected` 抛出一个异常 `e` ，则 `promise2` 必须拒绝执行，并返回拒因 `e`\n  * 如果 `onFulfilled` 不是函数且 `promise1` 成功执行， `promise2` 必须成功执行并返回相同的值\n  * 如果 `onRejected` 不是函数且 `promise1` 拒绝执行， `promise2` 必须拒绝执行并返回相同的拒因\n  \n  **不论 promise1 被 reject 还是被 resolve ， promise2 都会被 resolve，只有出现异常时才会被 rejected**。\n  每个Promise对象都可以在其上多次调用then方法，而每次调用then返回的Promise的状态取决于那一次调用then时传入参数的返回值，所以then不能返回this，因为then每次返回的Promise的结果都有可能不同。\n\n下面代码实现：\n\n```js\n// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调\nMyPromise.prototype.then = function(onFulfilled, onRejected) {\n    var _this = this\n    // 规范 2.2.7，then 必须返回一个新的 promise\n    var promise2\n    // 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数\n    // onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =value\n    onRejected = typeof onRejected === 'function' ? onRejected : error ={throw error}\n    \n    if (_this.currentState === RESOLVED) {\n        return promise2 = new MyPromise(function(resolve, reject) {\n            \n        })\n    }\n    if (_this.currentState === REJECTED) {\n        return promise2 = new MyPromise(function(resolve, reject) {\n            \n        })\n    }\n    if (_this.currentState === PENDING) {\n        return promise2 = new MyPromise(function(resolve, reject) {\n            \n        })\n    }\n}\n```\n\n**附：值穿透解读**\n\n```js\nMyPromise.prototype.then = function (onFulfilled, onRejected) {\n    ...\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =value\n    onRejected = typeof onRejected === 'function' ? onRejected : error ={throw error}\n    ...\n}\n```\n\n上面提到值穿透，值穿透即：\n\n```js\nvar promise = new MyPromise((resolve, reject) ={\n    setTimeout(() ={\n        resolve('1')\n    }, 1000)\n})\npromise.then('2').then(console.log)\n```\n\n最终打结果是`1`而不是`2`\n\n再例如：\n\n```js\nnew MyPromise(resolve =resolve('1'))\n    .then()\n    .then()\n    .then(function foo(value) {\n        alert(value)\n    })\n// output: alert 出 1\n```\n\n通过 `return this` 只实现了值穿透的一种情况，其实值穿透有两种情况：\n\n1. promise 已经是 RESOLVED/REJECTED 时，通过 return this 实现的值穿透：\n   ```js\n   var promise = new Promise(function (resolve) {\n       setTimeout(() ={\n           resolve('1')\n       }, 1000)\n   })\n   promise.then(() ={\n       promise.then().then((res) ={ // 状况A\n           console.log(res) // output: 1\n       })\n       promise.catch().then((res) ={ // 状况B\n           console.log(res) // output: 1\n       })\n       console.log(promise.then() === promise.catch()) // output: true\n       console.log(promise.then(1) === promise.catch({name: 'anran'})) // output: true\n   })\n   ```\n   \n   \n   状况A与B处 promise 已经是 RESOLVED 了符合条件，所以执行了 `return this`。\n   注意：原生的Promise实现里并不是这样实现的，会打印出两个false\n2. promise 是 PENDING时，通过生成新的 promise 加入到父 promise 的 queue，父 promise 有值时调用 callFulfilled->doResolve 或 callRejected->doReject（因为 then/catch 传入的参数不是函数）设置子 promise 的状态和值为父 promise 的状态与值。如：\n   ```js\n   var promise = new Promise((resolve) ={\n       setTimeout(() ={\n           resolve('1')\n       }, 1000)\n   })\n   var a = promise.then()\n   a.then((res) ={\n       console.log(res) // output: 1\n   })\n   var b = promise.catch()\n   b.then((res) ={\n       console.log(res) // output: 1\n   })\n   console.log(a === b) // output: false\n   ```\n\nPromise 有三种状态，我们分3个if块来处理，每块都返回一个new Promise。\n\n根据标准，我们知道，对于一下代码，promise2的值取决于then里面的返回值：\n\n```js\npromise2 = promise1.then(function(value) {\n    return 1\n}, function(err) {\n    throw new Error('error')\n})\n```\n\n如果promise1被resolve了，promise2的被`1`resolve，如果promise1 被reject了，promise2将被`new Error('error')`reject。\n\n所以，我们需要在then里面执行onFulfilled或者onRejected，并根据返回着（标记中记为`x`）来确定promise2的结果，并且，如果onFulfilled/onRejected返回的是一个Promise，promise将直接取这个Promise的结果。\n\n```js\n// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调\nMyPromise.prototype.then = function(onFulfilled, onRejected) {\n    var _this = this\n    // 规范 2.2.7，then 必须返回一个新的 promise\n    var promise2\n    // 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数\n    // onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =value\n    onRejected = typeof onRejected === 'function' ? onRejected : error ={throw error}\n    \n    if (_this.currentState === RESOLVED) {\n        // 如果promise1（此处为self/this）的状态已经确定并且为resolved，我们调用onFulfilled\n        // 如果考虑到有可能throw，所以我们将其包在try/catch块中\n        return promise2 = new MyPromise(function(resolve, reject) {\n            // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行\n      \t\t// 所以用了 setTimeout 包裹下\n            setTimeout(function() {\n                try {\n                \tvar x = onFulfilled(_this.value)\n                \t// 如果 onFulfilled 的返回值是一个 Promise 对象，直接取它的结果作为 promise2 的结果\n                \tif (x instanceof MyPromise) {\n                    \tx.then(resolve, reject)\n                \t}\n                \tresolve(x) // 否则，以它的返回值为 promise2 的结果\n            \t} catch (err) {\n                \treject(err) // 如果出错，以捕获到的错误作为promise2的结果\n            \t}\n            })\n        })\n    }\n    // 此处实现与FULFILLED相似，区别在使用的是onRejected而不是onFulfilled\n    if (_this.currentState === REJECTED) {\n        return promise2 = new MyPromise(function(resolve, reject) {\n            setTimeout(function() {\n                try {\n                \tvar x = onRejected(_this.value)\n                \tif (x instanceof Promise){\n                    \tx.then(resolve, reject)\n                \t}\n            \t} catch(err) {\n                \treject(err)\n            \t}\n            })\n        })\n    }\n    if (_this.currentState === PENDING) {\n        // 如果当前的Promise还处于PENDING状态，我们并不能确定调用onFulfilled还是onRejected\n        // 只有等待Promise的状态确定后，再做处理\n        // 所以我们需要把我们的两种情况的处理逻辑做成callback放入promise1（此处即self/this）的回调数组内\n        // 处理逻辑和以上相似\n        return promise2 = new MyPromise(function(resolve, reject) {\n            _this.onResolvedCallbacks.push(function() {\n                try {\n                    var x = onFulfilled(_this.value)\n                    if (x instanceof MyPromise) {\n                        x.then(resolve, reject)\n                    }\n                    resolve(x)\n                } catch(err) {\n                    reject(err)\n                }\n            })\n            _this.onRejectedCallbacks.push(function() {\n                try {\n                    var x = onRejected(_this.value)\n                    if (x instanceof MyPromise) {\n                        x.then(resolve, reject)\n                    }\n                } catch (err) {\n                    reject(err)\n                }\n            })\n        })\n    }\n}\n```\n\n#### Promise构建之七：catch的实现\n```js\n// catch 的实现\nMyPromise.prototype.catch = function (onRejected) {\n    return this.then(null, onRejected)\n}\n```\n\n至此，我们大致实现了Promise标准中所涉及到的内容。\n\n#### Promise构建之八：问题补充：无缝调用\n不同的Promise实现之间需要无缝的可交互，如ES6的Promise，和我们自己实现的Promise之间以及其他的Promise实现，必须是无缝调用的。\n\n```js\nnew MyPromise(function(resolve, reject) {\n    setTimeout(function() {\n        resolve('1')\n    }, 1000)\n}).then(function() {\n    return new Promise.reject('2') // ES6 的 Promise\n}).then(function() {\n    return Q.all([ // Q 的 Promise\n        new MyPromise(resolve =resolve('3')) // 我们实现的Promise\n        new Promise.eresolve('4') // ES6 的 Promise\n        Q.resolve('5') // Q 的 Promise\n    ])\n})\n```\n\n我之前实现的代码只是判断OnFullfilled/onRejected的返回值是否为我们自己实现的实例，并没有对其他类型Promise的判断，所以，上面的代码无法正常运行。\n\n接下来，我们解决这个问题\n\n关于不同Promise之间的交互，其实[Promise/A+标准](https://promisesaplus.com/#point-46)中有介绍，其中详细的指定了如何通过then的实参返回的值来决定promise2的状态，我们只需要按照标准把标准的内容转成代码即可。\n\n即我们要**把onFulfilled/onRejected的返回值x。当成是一个可能是Promise的对象**，也即标准中的thenable，并以最保险的姿势调用x上的then方法，如果大家都按照标准来实现，那么不同的Promise之间就可以交互了。\n\n而标准为了保险起见，即使x返回了一个带有then属性但不遵循Promise标准的对象（不如说这个x把它then里的两个参数都调用了，同步或者异步调用（PS，原则上then的两个参数需要异步调用，下文会讲到），或者是出错后又调用了它们，或者then根本不是一个函数），也能尽可能正确处理。\n\n关于为何需要不同的Promise实现能够相互交互，我想原因应该是显然的，Promise并不是JS一早就有的标准，不同第三方的实现之间是并不相互知晓的，如果你使用的某一个库中封装了一个Promise实现，想象一下如果它不能跟你自己使用的Promise实现交互的场景。。。\n\n代码实现：\n\n```js\n// 规范 2.3\n/*\nresolutionProcedure函数即为根据x的值来决定promise2的状态的函数\n也即标准中的[Promise Resolution Procedure](https://promisesaplus.com/#point-47)\nx 为 promise2 = promise1.then(onFulfilled, onRejected)里onFulfilled/onRejected的返回值\nresolve 和 reject 实际上是 promise2 的executor的两个实参，因为很难挂在其他地方，所以一并传过来。\n相信各位一定可以对照标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释。\n*/\nfunction resolutionProcedure(promise2, x, resolve, reject) {\n    // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用\n    if (promise2 === x) {\n        return reject(new TypeError(\"Chaining cycle detected for promise!\"))\n    }\n    // 规范 2.3.2\n    // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行\n    if (x instanceof MyPromise) {\n        // 2.3.2.1 如果x为pending状态，promise必须保持pending状态，直到x为fulfilled/rejected\n        if (x.currentState === PENDING) {\n            x.then(function(value) {\n                // 再次调用该函数是为了确认 x resolve 的\n                // 参数是什么类型，如果是基本类型就再次 resolve\n                // 把值传给下个 then\n                resolutionProcedure(promise2, value, resolve, reject)\n            }, reject)\n        } else { // 但如果这个promise的状态已经确定了，那么它肯定有一个正常的值，而不是一个thenable，所以这里可以取它的状态\n            x.then(resolve, reject)\n        }\n        return\n    }\n    \n    let called = false\n    // 规范 2.3.3，判断 x 是否为对象或函数\n    if (x !== null && (typeof x === \"object\" || typeof x === \"function\")) {\n        // 规范 2.3.3.2，如果不能取出 then，就 reject\n        try {\n            // 规范2.3.3.1 因为x.then可能是一个getter，这种情况下多次读取就有可能产生副作用\n            // 既要判断它的类型，又要调用它，这就是两次读取\n            let then = x.then\n            // 规范2.3.3.3，如果 then 是函数，调用 x.then\n            if (typeof then === \"function\") {\n                // 规范 2.3.3.3\n    \t\t\t// reject 或 reject 其中一个执行过的话，忽略其他的\n                then.call(\n                    x,\n                    y ={ // 规范 2.3.3.3.1\n                        if (called) return // 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准\n                        called = true\n                        // 规范 2.3.3.3.1\n                        return resolutionProcedure(promise2, y, resolve, reject)\n                    },\n                    r ={\n                        if (called) return // 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准\n                        called = true\n                         return reject(r)\n                    }\n                )\n            } else {\n                // 规范 2.3.3.4\n                resolve(x)\n            }\n        } catch (e) { // 规范 2.3.3.2\n            if (called) return // 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准\n            called = true\n            return reject(e)\n        }\n    } else {\n        // 规范 2.3.4，x 为基本类型\n        resolve(x)\n    }\n}\n```\n\n然后，我们使用`resolutionProcedure`函数替换`MyPromise.prototype.then`里面几处判断x是否为MyPromise对象的位置即可。即：\n\n```js\nif (x instanceof MyPromise) {\n    x.then(resolve, reject)\n}\n// resolve(x) // 否则，以它的返回值为 promise2 的结果\n```\n\n替换为：\n\n```js\nresolutionProcedure(promise2, x, resolve, reject)\n```\n\n总共四处，不要遗漏了\n\n#### Promise构建九：完整代码实现\n```js\n// 三种状态\nconst PENDING = \"pending\"\nconst RESOLVED = \"resolved\"\nconst REJECTED = \"rejected\"\nfunction MyPromise(callback) {\n    var _this = this\n    _this.currentState = PENDING // Promise当前的状态\n    _this.value = void 0 // Promise的值\n    // 用于保存 then 的回调， 只有当 promise\n    // 状态为 pending 时才会缓存，并且每个实例至多缓存一个\n    _this.onResolvedCallbacks = [] // Promise resolve时的回调函数集\n    _this.onRejectedCallbacks = [] // Promise reject时的回调函数集\n    _this.resolve = function (value) {\n        if (value instanceof MyPromise) {\n            // 如果 value 是个 Promise， 递归执行\n            return value.then(_this.resolve, _this.reject)\n        }\n        setTimeout(() ={ // 异步执行，保证顺序执行\n            if (_this.currentState === PENDING) {\n                _this.currentState = RESOLVED // 状态管理\n                _this.value = value\n                _this.onResolvedCallbacks.forEach(cb =cb())\n            }\n        })\n    } // resolve 处理函数\n    _this.reject = function (value) {\n        setTimeout(() ={ // 异步执行，保证顺序执行\n            if (_this.currentState === PENDING) {\n                _this.currentState = REJECTED // 状态管理\n                _this.value = value\n                _this.onRejectedCallbacks.forEach(cb =cb())\n            }\n        })\n    } // reject 处理函数\n\n    // 异常处理\n    // new Promise(() =throw Error('error'))\n    try {\n        callback(_this.resolve, _this.reject) // 执行callback并传入相应的参数\n    } catch(e) {\n        _this.reject(e)\n    }\n}\n// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调\nMyPromise.prototype.then = function(onFulfilled, onRejected) {\n    var _this = this\n    // 规范 2.2.7，then 必须返回一个新的 promise\n    var promise2\n    // 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数\n    // onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =value\n    onRejected = typeof onRejected === 'function' ? onRejected : error ={throw error}\n\n    if (_this.currentState === RESOLVED) {\n        // 如果promise1（此处为self/this）的状态已经确定并且为resolved，我们调用onFulfilled\n        // 如果考虑到有可能throw，所以我们将其包在try/catch块中\n        return promise2 = new MyPromise(function(resolve, reject) {\n            try {\n                var x = onFulfilled(_this.value)\n                // 如果 onFulfilled 的返回值是一个 Promise 对象，直接取它的结果作为 promise2 的结果\n                resolutionProcedure(promise2, x, resolve, reject)\n            } catch (err) {\n                reject(err) // 如果出错，以捕获到的错误作为promise2的结果\n            }\n        })\n    }\n    // 此处实现与FULFILLED相似，区别在使用的是onRejected而不是onFulfilled\n    if (_this.currentState === REJECTED) {\n        return promise2 = new MyPromise(function(resolve, reject) {\n            try {\n                var x = onRejected(_this.value)\n                resolutionProcedure(promise2, x, resolve, reject)\n            } catch(err) {\n                reject(err)\n            }\n        })\n    }\n    if (_this.currentState === PENDING) {\n        // 如果当前的Promise还处于PENDING状态，我们并不能确定调用onFulfilled还是onRejected\n        // 只有等待Promise的状态确定后，再做处理\n        // 所以我们需要把我们的两种情况的处理逻辑做成callback放入promise1（此处即_this/this）的回调数组内\n        // 处理逻辑和以上相似\n        return promise2 = new MyPromise(function(resolve, reject) {\n            _this.onResolvedCallbacks.push(function() {\n                try {\n                    var x = onFulfilled(_this.value)\n                    resolutionProcedure(promise2, x, resolve, reject)\n                } catch(err) {\n                    reject(err)\n                }\n            })\n            _this.onRejectedCallbacks.push(function() {\n                try {\n                    var x = onRejected(_this.value)\n                    resolutionProcedure(promise2, x, resolve, reject)\n                } catch (err) {\n                    reject(err)\n                }\n            })\n        })\n    }\n\n    // 规范 2.3\n    /*\n    resolutionProcedure函数即为根据x的值来决定promise2的状态的函数\n    也即标准中的[Promise Resolution Procedure](https://promisesaplus.com/#point-47)\n    x 为 promise2 = promise1.then(onFulfilled, onRejected)里onFulfilled/onRejected的返回值\n    resolve 和 reject 实际上是 promise2 的executor的两个实参，因为很难挂在其他地方，所以一并传过来。\n    相信各位一定可以对照标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释。\n    */\n    function resolutionProcedure(promise2, x, resolve, reject) {\n        // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用\n        if (promise2 === x) {\n            return reject(new TypeError(\"Chaining cycle detected for promise!\"))\n        }\n        // 规范 2.3.2\n        // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行\n        if (x instanceof MyPromise) {\n            // 2.3.2.1 如果x为pending状态，promise必须保持pending状态，直到x为fulfilled/rejected\n            if (x.currentState === PENDING) {\n                x.then(function(value) {\n                    // 再次调用该函数是为了确认 x resolve 的\n                    // 参数是什么类型，如果是基本类型就再次 resolve\n                    // 把值传给下个 then\n                    resolutionProcedure(promise2, value, resolve, reject)\n                }, reject)\n            } else { // 但如果这个promise的状态已经确定了，那么它肯定有一个正常的值，而不是一个thenable，所以这里可以取它的状态\n                x.then(resolve, reject)\n            }\n            return\n        }\n\n        let called = false\n        // 规范 2.3.3，判断 x 是否为对象或函数\n        if (x !== null && (typeof x === \"object\" || typeof x === \"function\")) {\n            // 规范 2.3.3.2，如果不能取出 then，就 reject\n            try {\n                // 规范2.3.3.1 因为x.then可能是一个getter，这种情况下多次读取就有可能产生副作用\n                // 既要判断它的类型，又要调用它，这就是两次读取\n                let then = x.then\n                // 规范2.3.3.3，如果 then 是函数，调用 x.then\n                if (typeof then === \"function\") {\n                    // 规范 2.3.3.3\n                    // reject 或 reject 其中一个执行过的话，忽略其他的\n                    then.call(\n                        x,\n                        y ={ // 规范 2.3.3.3.1\n                            if (called) return // 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准\n                            called = true\n                            // 规范 2.3.3.3.1\n                            return resolutionProcedure(promise2, y, resolve, reject)\n                        },\n                        r ={\n                            if (called) return // 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准\n                            called = true\n                            return reject(r)\n                        }\n                    )\n                } else {\n                    // 规范 2.3.3.4\n                    resolve(x)\n                }\n            } catch (e) { // 规范 2.3.3.2\n                if (called) return // 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准\n                called = true\n                return reject(e)\n            }\n        } else {\n            // 规范 2.3.4，x 为基本类型\n            resolve(x)\n        }\n    }\n}\n// catch 的实现\nMyPromise.prototype.catch = function (onRejected) {\n    return this.then(null, onRejected)\n}\n// finally 的实现\nMyPromise.prototype.finally = function (callback) {\n  return this.then(function (value) {\n    return MyPromise.resolve(callback()).then(function () {\n      return value\n    })\n  }, function (err) {\n    return MyPromise.resolve(callback()).then(function () {\n      throw err\n    })\n  })\n}\n```\n\n额外，附加 `Promise.race` 与 `Promise.all` 的实现，有兴趣的可以了解一下\n\n```js\n// race\nMyPromise.race = function(values) {\n    return new MyPromise(function(resolve, reject) {\n        values.forEach(function(value) {\n            MyPromise.resolve(value).then(resolve, reject)\n        })\n    })\n}\n// all\nMyPromise.all = function(arr) {\n    var args = Array.prototype.slice.call(arr)\n    return new MyPromise(function (resolve, reject) {\n        if (args.length === 0) return resolve([])\n        var remaining = args.length\n        for (var i = 0; i < args.length; i++) {\n            res(i, args[i])\n        }\n        function res(i, val) {\n            if (val && (typeof val === 'object' || typeof val === 'function')) {\n                if (val instanceof MyPromise && val.then === MyPromise.prototype.then) {\n                    if (val.currentState === RESOLVED) return res(i, val.value)\n                    if (val.currentState === REJECTED) reject(val.value)\n                    val.then(function (val) {\n                        res(i, val)\n                    }, reject)\n                    return\n                } else {\n                    var then = val.then\n                    if (typeof then === 'function') {\n                        var p = new MyPromise(then.bind(val))\n                        p.then(function(val) {\n                            res(i, val)\n                        }, reject)\n                        return\n                    }\n                }\n            }\n            args[i] = val\n            if (--remaining === 0) {\n                resolve(args)\n            }\n        }\n    })\n}\n```\n\nVoid 0 其实可以理解成undefined，因为undefined可以在局部函数里被覆盖，void 0 不会。\n\nvoid是一个运算符，给表达式求值，返回undefined。void 0 是表达式中最短的，最节省字节。\n\nsetTimeout 如果不传时间，默认取0。\n\n\n\n\n\n“参考”\n\n[promise取消的一些讨论](https://segmentfault.com/q/1010000009781257)\n\n","source":"_posts/浏览器异步（三）之Promise实现.md","raw":"---\ntitle: 浏览器异步（三）\ndate: 2020-07-18 00:54:40\ntags: Promise 工具\n---\n\n> 此篇博文转载自瓶子君的blog [链接](https://github.com/sisterAn/blog/issues/13)，并加以自己的理解和注释。\n\n### Promise本质\n\n**Promise就是为了解决callback的问题而产生的。**\n\nPromise 本质上就是一个绑定了回调的对象，而不是将回调传回函数内部。\n\n**开门见山，Promise解决的是回调函数处理异步的第2个问题：控制反转**。\n\n我们把上面那个多层回调嵌套的例子用Promise的方式重构：\n\n```js\nlet getPromise1 = function () {\n    return new Promsie(function (resolve, reject) {\n        $.ajax({\n            url: 'XXX1',\n            success: function (data) {\n               let key = data;\n               resolve(key);         \n            },\n            error: function (err) {\n                reject(err);\n            }\n        });\n    });\n};\n\nlet getPromise2 = function (key) {\n    return new Promsie(function (resolve, reject) {\n        $.ajax({\n            url: 'XXX2',\n            data: {\n                key: key\n            },\n            success: function (data) {\n                resolve(data);         \n            },\n            error: function (err) {\n                reject(err);\n            }\n        });\n    });\n};\n\nlet getPromise3 = function () {\n    \n    return new Promsie(function (resolve, reject) {\n        $.ajax({\n            url: 'XXX3',\n            success: function (data) {\n                resolve(data);         \n            },\n            error: function (err) {\n                reject(err);\n            }\n        });\n    });\n};\n\ngetPromise1()\n    .then(function (key) {\n        return getPromise2(key);\n    })\n    .then(function (data) {\n        return getPromise3(data);\n    })\n    .then(function (data) {\n    \t// todo\n        console.log('业务数据：', data);\n    })\n    .catch(function (err) {\n        console.log(err);\n    }); \n```\n\nPromise 在一定程度上其实改善了回调函数的书写方式；另外逻辑性更明显了，将异步业务提取成单个函数，整个流程可以看到是一步步向下执行的，依赖层级也很清晰，最后需要的数据是在整个代码的最后一步获得。\n\n所以，Promise在一定程度上解决了回调函数的书写结构问题，但回调函数依然在主流程上存在，只不过都放到了then(...)里面，和我们大脑顺序线性的思维逻辑还是有出入的。\n\n### Promise 是什么\nPromise是什么，无论是ES6的Promise也好，jQuery的Promise也好，不同的库有不同的实现，但是大家遵循的都是同一套规范，所以，Promise并不指特定的某个实现，**它是一种规范，是一套处理JavaScript异步的机制**。\n\nPromise的规范会多，如Promise/A、Promise/B、Promise/D以及Promise/A的升级版Promise/A+，其中ES6遵循Promise/A+规范，有关Promise/A+，你可以参考一下：\n\n* 英文版：[Promise/A+](https://promisesaplus.com)\n* 翻译版：[【翻译】Promises/A+规范](http://www.ituring.com.cn/article/66566)\n\n这里只简要介绍下几点与接下来内容相关的规范：\n\n* Promise 本质是一个状态机，每个 Promise 有三种状态：pending、resolved以及rejected。状态转变只能是pending —resolved 或者 pending —rejected。状态转变不可逆。\n* then 方法可以被同一个 promise 调用多次。\n* then 方法必须返回一个 promise。规范2.2.7中规定， then 必须返回一个新的 Promise\n* 值穿透\n\n### Promise 实现及源码解读\n首先，我们看一下Promise的简单使用：\n\n```js\nvar p = new Promise(function(resolve, reject) {\n    // Do an async task async task and then...\n    if(/* good condition */) {\n        resolve('Success!');\n    }\n    else {\n        reject('Failure!');\n    }\n});\np.then(function() { \n    /* do something with the result */\n}).catch(function() {\n    /* error :( */\n})\n```\n\n我们通过这种使用构建Promise实现的第一个版本\n\n**自己的写法也是结合调用实例的逆推过程**。\n\n为什么要将callback单独传入呢？因为啊，new Promise(... ) 这括号里的函数逻辑是由我们编写的，可调整可修改，在任何条件下的resolve和reject，所以封装的时候最好写成一个通用的回调函数。\n\n#### Promise构建版本一\n\n```js\nfunction MyPromise(callback) {\n    var _this = this\n    _this.value = void 0 // Promise的值\n    var onResolvedCallback  // Promise resolve回调函数\n    var onRejectedCallback  // Promise reject回调函数\n    // resolve 处理函数\n    _this.resolve = function (value) {\n        onResolvedCallback()\n    } \n    // reject 处理函数\n    _this.reject = function (error) {\n        onRejectedCallback()\n    } \n    callback(_this.resolve, _this.reject) // 执行callback并传入相应的参数\n}\n// 添加 then 方法 因为是promise的实例需要用到，所以then最好挂载在promise的原型上\nMyPromise.prototype.then = function(resolve, reject) {}\n```\n\n大致框架已经出来了，但我们看到Promise状态、reslove函数、reject函数以及then等都没有处理。\n\n#### Promise构建之二：链式存储\n\n链式存储：讲的就是promise实例会有很多次then，然后下一次的then都会获得上一次的then的结果，就像链式一般。将结果存储下去，直至return。\n\n首先，举个例子：\n\n```js\nnew Promise(function (resolve, reject) {\n    setTimeout(function () {\n        var a=1;\n        resolve(a);\n    }, 1000);\n}).then(function (res) {\n    console.log(res);\n    return new Promise(function (resolve, reject) {\n        setTimeout(function () {\n            var b=2;\n            resolve(b);\n        }, 1000);\n    })\n}).then(function (res) {\n    console.log(res);\n    return new Promise(function (resolve, reject) {\n        setTimeout(function () {\n            var c=3\n            resolve(c);\n        }, 1000);\n    })\n}).then(function (res) {\n    console.log(res);\n})\n```\n\n上例结果是每间隔1s打印一个数字，顺序为1、2、3。\n\n这里保证了：\n\n* 让a,b,c的值能在then里面的回调接收到\n* 在连续调用异步，如何确保异步函数的执行顺序\n\nPromise一个常见的需求就是连续执行两个或者多个异步操作，这种情况下，每一个后来的操作都在前面的操作执行成功之后，带着上一步操作所返回的结果开始执行。这里用`setTimeout`来处理\n\n```js\nfunction MyPromise(callback) {\n    var _this = this\n    _this.value = void 0 // Promise的值\n    // 用于保存 then 的回调， 只有当 promise\n    // 状态为 pending 时才会缓存，并且每个实例至多缓存一个\n    _this.onResolvedCallbacks = [] // Promise resolve时的回调函数集\n    _this.onRejectedCallbacks = [] // Promise reject时的回调函数集\n    _this.resolve = function (value) {\n        setTimeout(() => { // 异步执行\n            _this.onResolvedCallbacks.forEach(cb =cb())\n        })\n    } // resolve 处理函数\n    _this.reject = function (error) {\n        setTimeout(() => { // 异步执行\n            _this.onRejectedCallbacks.forEach(cb =cb())\n        })\n    } // reject 处理函数\n    callback(_this.resolve, _this.reject) // 执行callback并传入相应的参数\n}\n// 添加 then 方法\nMyPromise.prototype.then = function() {}\n```\n\n#### Promise构建之三：状态机制、顺序执行\n为了保证Promise的异步操作时的顺序执行，这里给Promise加上状态机制\n\n```js\n// 三种状态\nconst PENDING = \"pending\"\nconst RESOLVED = \"resolved\"\nconst REJECTED = \"rejected\"\nfunction MyPromise(callback) {\n    var _this = this\n    _this.currentState = PENDING // Promise当前的状态\n    _this.value = void 0 // Promise的值\n    // 用于保存 then 的回调， 只有当 promise\n    // 状态为 pending 时才会缓存，并且每个实例至多缓存一个\n    _this.onResolvedCallbacks = [] // Promise resolve时的回调函数集\n    _this.onRejectedCallbacks = [] // Promise reject时的回调函数集\n    _this.resolve = function (value) {\n        setTimeout(() => { // 异步执行，保证顺序执行\n            if (_this.currentState === PENDING) {\n                _this.currentState = RESOLVED // 状态管理\n                _this.value = value\n                _this.onResolvedCallbacks.forEach(cb => cb())\n            }\n        })\n    } // resolve 处理函数\n    _this.reject = function (value) {\n        setTimeout(() => { // 异步执行，保证顺序执行\n            if (_this.currentState === PENDING) {\n            \t_this.currentState = REJECTED // 状态管理\n            \t_this.value = value\n            \t_this.onRejectedCallbacks.forEach(cb => cb())\n        \t}\n        })\n    } // reject 处理函数\n    callback(_this.resolve, _this.reject) // 执行callback并传入相应的参数\n}\n// 添加 then 方法\nMyPromise.prototype.then = function() {}\n```\n\n#### Promise构建之四：递归执行\n每个Promise后面链接一个对象，该对象包含onresolved,onrejected,子promise三个属性.\n\n当父Promise 状态改变完毕,执行完相应的onresolved/onrejected的时候，拿到子promise,在等待这个子promise状态改变，在执行相应的onresolved/onrejected。依次循环直到当前promise没有子promise。\n\n```js\n// 三种状态\nconst PENDING = \"pending\"\nconst RESOLVED = \"resolved\"\nconst REJECTED = \"rejected\"\nfunction MyPromise(callback) {\n    var _this = this\n    _this.currentState = PENDING // Promise当前的状态\n    _this.value = void 0 // Promise的值\n    // 用于保存 then 的回调， 只有当 promise\n    // 状态为 pending 时才会缓存，并且每个实例至多缓存一个\n    _this.onResolvedCallbacks = [] // Promise resolve时的回调函数集\n    _this.onRejectedCallbacks = [] // Promise reject时的回调函数集\n    _this.resolve = function (value) {\n        if (value instanceof MyPromise) {\n            // 如果 value 是个 MyPromise， 递归执行\n            return value.then(_this.resolve, _this.reject)\n        }\n        setTimeout(() => { // 异步执行，保证顺序执行\n            if (_this.currentState === PENDING) {\n                _this.currentState = RESOLVED // 状态管理\n                _this.value = value\n                _this.onResolvedCallbacks.forEach(cb => cb())\n            }\n        })\n    } // resolve 处理函数\n    _this.reject = function (value) {\n        setTimeout(() => { // 异步执行，保证顺序执行\n            if (_this.currentState === PENDING) {\n            \t_this.currentState = REJECTED // 状态管理\n            \t_this.value = value\n            \t_this.onRejectedCallbacks.forEach(cb => cb())\n        \t}\n        })\n    } // reject 处理函数\n    callback(_this.resolve, _this.reject) // 执行callback并传入相应的参数\n}\n// 添加 then 方法\nMyPromise.prototype.then = function() {}\n```\n\n#### Promise构建之五：异常处理\n```js\n// 三种状态\nconst PENDING = \"pending\"\nconst RESOLVED = \"resolved\"\nconst REJECTED = \"rejected\"\nfunction MyPromise(callback) {\n    var _this = this\n    _this.currentState = PENDING // Promise当前的状态\n    _this.value = void 0 // Promise的值\n    // 用于保存 then 的回调， 只有当 promise\n    // 状态为 pending 时才会缓存，并且每个实例至多缓存一个\n    _this.onResolvedCallbacks = [] // Promise resolve时的回调函数集\n    _this.onRejectedCallbacks = [] // Promise reject时的回调函数集\n    _this.resolve = function (value) {\n        if (value instanceof MyPromise) {\n            // 如果 value 是个 MyPromise， 递归执行\n            return value.then(_this.resolve, _this.reject)\n        }\n        setTimeout(() => { // 异步执行，保证顺序执行\n            if (_this.currentState === PENDING) {\n                _this.currentState = RESOLVED // 状态管理\n                _this.value = value\n                _this.onResolvedCallbacks.forEach(cb => cb())\n            }\n        })\n    } // resolve 处理函数\n    _this.reject = function (error) {\n        setTimeout(() => { // 异步执行，保证顺序执行\n            if (_this.currentState === PENDING) {\n            \t_this.currentState = REJECTED // 状态管理\n            \t_this.value = value\n            \t_this.onRejectedCallbacks.forEach(cb => cb())\n        \t}\n        })\n    } // reject 处理函数\n    \n    // 异常处理\n    // new Promise(() =throw Error('error'))\n    try {\n        callback(_this.resolve, _this.reject) // 执行callback并传入相应的参数\n    } catch(e) {\n        _this.reject(e)\n    }\n}\n// 添加 then 方法\nMyPromise.prototype.then = function() {}\n```\n\n#### Promise构建之六：then的实现\nthen 方法是 Promise 的核心，这里做一下详细介绍。\n\n```js\npromise.then(onFulfilled, onRejected)\n```\n\n一个 Promise 的then接受两个参数： onFulfilled和onRejected（都是可选参数，并且为函数，若不是函数将被忽略）\n\n* onFulfilled 特性：\n  \n  * 当 Promise 执行结束后其必须被调用，其第一个参数为 promise 的终值，也就是 resolve 传过来的值\n  * 在 Promise 执行结束前不可被调用\n  * 其调用次数不可超过一次\n* onRejected 特性\n  \n  * 当 Promise 被拒绝执行后其必须被调用，第一个参数为 Promise 的拒绝原因，也就是reject传过来的值\n  * 在 Promise 执行结束前不可被调用\n  * 其调用次数不可超过一次\n* 调用时机\n  `onFulfilled` 和 `onRejected` 只有在[执行环境](http://es5.github.io/#x10.3)堆栈仅包含**平台代码**时才可被调用（平台代码指引擎、环境以及 promise 的实施代码）\n* 调用要求\n  `onFulfilled` 和 `onRejected` 必须被作为函数调用（即没有 `this` 值，在 **严格模式（strict）** 中，函数 `this` 的值为 `undefined` ；在非严格模式中其为全局对象。）\n* 多次调用\n  `then` 方法可以被同一个 `promise` 调用多次\n  \n  * 当 `promise` 成功执行时，所有 `onFulfilled` 需按照其注册顺序依次回调\n  * 当 `promise` 被拒绝执行时，所有的 `onRejected` 需按照其注册顺序依次回调\n* 返回\n  `then`方法会返回一个`Promise`，关于这一点，Promise/A+标准并没有要求返回的这个Promise是一个新的对象，但在Promise/A标准中，明确规定了then要返回一个新的对象，目前的Promise实现中then几乎都是返回一个新的Promise([详情](https://promisesaplus.com/differences-from-promises-a#point-5))对象，所以在我们的实现中，也让then返回一个新的Promise对象。\n  ```\n  promise2 = promise1.then(onFulfilled, onRejected);\n  ```\n  \n  \n  \n  * 如果 `onFulfilled` 或者 `onRejected` 返回一个值 `x` ，则运行下面的 **Promise 解决过程**：`[[Resolve]](promise2, x)`\n  * 如果 `onFulfilled` 或者 `onRejected` 抛出一个异常 `e` ，则 `promise2` 必须拒绝执行，并返回拒因 `e`\n  * 如果 `onFulfilled` 不是函数且 `promise1` 成功执行， `promise2` 必须成功执行并返回相同的值\n  * 如果 `onRejected` 不是函数且 `promise1` 拒绝执行， `promise2` 必须拒绝执行并返回相同的拒因\n  \n  **不论 promise1 被 reject 还是被 resolve ， promise2 都会被 resolve，只有出现异常时才会被 rejected**。\n  每个Promise对象都可以在其上多次调用then方法，而每次调用then返回的Promise的状态取决于那一次调用then时传入参数的返回值，所以then不能返回this，因为then每次返回的Promise的结果都有可能不同。\n\n下面代码实现：\n\n```js\n// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调\nMyPromise.prototype.then = function(onFulfilled, onRejected) {\n    var _this = this\n    // 规范 2.2.7，then 必须返回一个新的 promise\n    var promise2\n    // 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数\n    // onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =value\n    onRejected = typeof onRejected === 'function' ? onRejected : error ={throw error}\n    \n    if (_this.currentState === RESOLVED) {\n        return promise2 = new MyPromise(function(resolve, reject) {\n            \n        })\n    }\n    if (_this.currentState === REJECTED) {\n        return promise2 = new MyPromise(function(resolve, reject) {\n            \n        })\n    }\n    if (_this.currentState === PENDING) {\n        return promise2 = new MyPromise(function(resolve, reject) {\n            \n        })\n    }\n}\n```\n\n**附：值穿透解读**\n\n```js\nMyPromise.prototype.then = function (onFulfilled, onRejected) {\n    ...\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =value\n    onRejected = typeof onRejected === 'function' ? onRejected : error ={throw error}\n    ...\n}\n```\n\n上面提到值穿透，值穿透即：\n\n```js\nvar promise = new MyPromise((resolve, reject) ={\n    setTimeout(() ={\n        resolve('1')\n    }, 1000)\n})\npromise.then('2').then(console.log)\n```\n\n最终打结果是`1`而不是`2`\n\n再例如：\n\n```js\nnew MyPromise(resolve =resolve('1'))\n    .then()\n    .then()\n    .then(function foo(value) {\n        alert(value)\n    })\n// output: alert 出 1\n```\n\n通过 `return this` 只实现了值穿透的一种情况，其实值穿透有两种情况：\n\n1. promise 已经是 RESOLVED/REJECTED 时，通过 return this 实现的值穿透：\n   ```js\n   var promise = new Promise(function (resolve) {\n       setTimeout(() ={\n           resolve('1')\n       }, 1000)\n   })\n   promise.then(() ={\n       promise.then().then((res) ={ // 状况A\n           console.log(res) // output: 1\n       })\n       promise.catch().then((res) ={ // 状况B\n           console.log(res) // output: 1\n       })\n       console.log(promise.then() === promise.catch()) // output: true\n       console.log(promise.then(1) === promise.catch({name: 'anran'})) // output: true\n   })\n   ```\n   \n   \n   状况A与B处 promise 已经是 RESOLVED 了符合条件，所以执行了 `return this`。\n   注意：原生的Promise实现里并不是这样实现的，会打印出两个false\n2. promise 是 PENDING时，通过生成新的 promise 加入到父 promise 的 queue，父 promise 有值时调用 callFulfilled->doResolve 或 callRejected->doReject（因为 then/catch 传入的参数不是函数）设置子 promise 的状态和值为父 promise 的状态与值。如：\n   ```js\n   var promise = new Promise((resolve) ={\n       setTimeout(() ={\n           resolve('1')\n       }, 1000)\n   })\n   var a = promise.then()\n   a.then((res) ={\n       console.log(res) // output: 1\n   })\n   var b = promise.catch()\n   b.then((res) ={\n       console.log(res) // output: 1\n   })\n   console.log(a === b) // output: false\n   ```\n\nPromise 有三种状态，我们分3个if块来处理，每块都返回一个new Promise。\n\n根据标准，我们知道，对于一下代码，promise2的值取决于then里面的返回值：\n\n```js\npromise2 = promise1.then(function(value) {\n    return 1\n}, function(err) {\n    throw new Error('error')\n})\n```\n\n如果promise1被resolve了，promise2的被`1`resolve，如果promise1 被reject了，promise2将被`new Error('error')`reject。\n\n所以，我们需要在then里面执行onFulfilled或者onRejected，并根据返回着（标记中记为`x`）来确定promise2的结果，并且，如果onFulfilled/onRejected返回的是一个Promise，promise将直接取这个Promise的结果。\n\n```js\n// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调\nMyPromise.prototype.then = function(onFulfilled, onRejected) {\n    var _this = this\n    // 规范 2.2.7，then 必须返回一个新的 promise\n    var promise2\n    // 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数\n    // onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =value\n    onRejected = typeof onRejected === 'function' ? onRejected : error ={throw error}\n    \n    if (_this.currentState === RESOLVED) {\n        // 如果promise1（此处为self/this）的状态已经确定并且为resolved，我们调用onFulfilled\n        // 如果考虑到有可能throw，所以我们将其包在try/catch块中\n        return promise2 = new MyPromise(function(resolve, reject) {\n            // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行\n      \t\t// 所以用了 setTimeout 包裹下\n            setTimeout(function() {\n                try {\n                \tvar x = onFulfilled(_this.value)\n                \t// 如果 onFulfilled 的返回值是一个 Promise 对象，直接取它的结果作为 promise2 的结果\n                \tif (x instanceof MyPromise) {\n                    \tx.then(resolve, reject)\n                \t}\n                \tresolve(x) // 否则，以它的返回值为 promise2 的结果\n            \t} catch (err) {\n                \treject(err) // 如果出错，以捕获到的错误作为promise2的结果\n            \t}\n            })\n        })\n    }\n    // 此处实现与FULFILLED相似，区别在使用的是onRejected而不是onFulfilled\n    if (_this.currentState === REJECTED) {\n        return promise2 = new MyPromise(function(resolve, reject) {\n            setTimeout(function() {\n                try {\n                \tvar x = onRejected(_this.value)\n                \tif (x instanceof Promise){\n                    \tx.then(resolve, reject)\n                \t}\n            \t} catch(err) {\n                \treject(err)\n            \t}\n            })\n        })\n    }\n    if (_this.currentState === PENDING) {\n        // 如果当前的Promise还处于PENDING状态，我们并不能确定调用onFulfilled还是onRejected\n        // 只有等待Promise的状态确定后，再做处理\n        // 所以我们需要把我们的两种情况的处理逻辑做成callback放入promise1（此处即self/this）的回调数组内\n        // 处理逻辑和以上相似\n        return promise2 = new MyPromise(function(resolve, reject) {\n            _this.onResolvedCallbacks.push(function() {\n                try {\n                    var x = onFulfilled(_this.value)\n                    if (x instanceof MyPromise) {\n                        x.then(resolve, reject)\n                    }\n                    resolve(x)\n                } catch(err) {\n                    reject(err)\n                }\n            })\n            _this.onRejectedCallbacks.push(function() {\n                try {\n                    var x = onRejected(_this.value)\n                    if (x instanceof MyPromise) {\n                        x.then(resolve, reject)\n                    }\n                } catch (err) {\n                    reject(err)\n                }\n            })\n        })\n    }\n}\n```\n\n#### Promise构建之七：catch的实现\n```js\n// catch 的实现\nMyPromise.prototype.catch = function (onRejected) {\n    return this.then(null, onRejected)\n}\n```\n\n至此，我们大致实现了Promise标准中所涉及到的内容。\n\n#### Promise构建之八：问题补充：无缝调用\n不同的Promise实现之间需要无缝的可交互，如ES6的Promise，和我们自己实现的Promise之间以及其他的Promise实现，必须是无缝调用的。\n\n```js\nnew MyPromise(function(resolve, reject) {\n    setTimeout(function() {\n        resolve('1')\n    }, 1000)\n}).then(function() {\n    return new Promise.reject('2') // ES6 的 Promise\n}).then(function() {\n    return Q.all([ // Q 的 Promise\n        new MyPromise(resolve =resolve('3')) // 我们实现的Promise\n        new Promise.eresolve('4') // ES6 的 Promise\n        Q.resolve('5') // Q 的 Promise\n    ])\n})\n```\n\n我之前实现的代码只是判断OnFullfilled/onRejected的返回值是否为我们自己实现的实例，并没有对其他类型Promise的判断，所以，上面的代码无法正常运行。\n\n接下来，我们解决这个问题\n\n关于不同Promise之间的交互，其实[Promise/A+标准](https://promisesaplus.com/#point-46)中有介绍，其中详细的指定了如何通过then的实参返回的值来决定promise2的状态，我们只需要按照标准把标准的内容转成代码即可。\n\n即我们要**把onFulfilled/onRejected的返回值x。当成是一个可能是Promise的对象**，也即标准中的thenable，并以最保险的姿势调用x上的then方法，如果大家都按照标准来实现，那么不同的Promise之间就可以交互了。\n\n而标准为了保险起见，即使x返回了一个带有then属性但不遵循Promise标准的对象（不如说这个x把它then里的两个参数都调用了，同步或者异步调用（PS，原则上then的两个参数需要异步调用，下文会讲到），或者是出错后又调用了它们，或者then根本不是一个函数），也能尽可能正确处理。\n\n关于为何需要不同的Promise实现能够相互交互，我想原因应该是显然的，Promise并不是JS一早就有的标准，不同第三方的实现之间是并不相互知晓的，如果你使用的某一个库中封装了一个Promise实现，想象一下如果它不能跟你自己使用的Promise实现交互的场景。。。\n\n代码实现：\n\n```js\n// 规范 2.3\n/*\nresolutionProcedure函数即为根据x的值来决定promise2的状态的函数\n也即标准中的[Promise Resolution Procedure](https://promisesaplus.com/#point-47)\nx 为 promise2 = promise1.then(onFulfilled, onRejected)里onFulfilled/onRejected的返回值\nresolve 和 reject 实际上是 promise2 的executor的两个实参，因为很难挂在其他地方，所以一并传过来。\n相信各位一定可以对照标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释。\n*/\nfunction resolutionProcedure(promise2, x, resolve, reject) {\n    // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用\n    if (promise2 === x) {\n        return reject(new TypeError(\"Chaining cycle detected for promise!\"))\n    }\n    // 规范 2.3.2\n    // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行\n    if (x instanceof MyPromise) {\n        // 2.3.2.1 如果x为pending状态，promise必须保持pending状态，直到x为fulfilled/rejected\n        if (x.currentState === PENDING) {\n            x.then(function(value) {\n                // 再次调用该函数是为了确认 x resolve 的\n                // 参数是什么类型，如果是基本类型就再次 resolve\n                // 把值传给下个 then\n                resolutionProcedure(promise2, value, resolve, reject)\n            }, reject)\n        } else { // 但如果这个promise的状态已经确定了，那么它肯定有一个正常的值，而不是一个thenable，所以这里可以取它的状态\n            x.then(resolve, reject)\n        }\n        return\n    }\n    \n    let called = false\n    // 规范 2.3.3，判断 x 是否为对象或函数\n    if (x !== null && (typeof x === \"object\" || typeof x === \"function\")) {\n        // 规范 2.3.3.2，如果不能取出 then，就 reject\n        try {\n            // 规范2.3.3.1 因为x.then可能是一个getter，这种情况下多次读取就有可能产生副作用\n            // 既要判断它的类型，又要调用它，这就是两次读取\n            let then = x.then\n            // 规范2.3.3.3，如果 then 是函数，调用 x.then\n            if (typeof then === \"function\") {\n                // 规范 2.3.3.3\n    \t\t\t// reject 或 reject 其中一个执行过的话，忽略其他的\n                then.call(\n                    x,\n                    y ={ // 规范 2.3.3.3.1\n                        if (called) return // 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准\n                        called = true\n                        // 规范 2.3.3.3.1\n                        return resolutionProcedure(promise2, y, resolve, reject)\n                    },\n                    r ={\n                        if (called) return // 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准\n                        called = true\n                         return reject(r)\n                    }\n                )\n            } else {\n                // 规范 2.3.3.4\n                resolve(x)\n            }\n        } catch (e) { // 规范 2.3.3.2\n            if (called) return // 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准\n            called = true\n            return reject(e)\n        }\n    } else {\n        // 规范 2.3.4，x 为基本类型\n        resolve(x)\n    }\n}\n```\n\n然后，我们使用`resolutionProcedure`函数替换`MyPromise.prototype.then`里面几处判断x是否为MyPromise对象的位置即可。即：\n\n```js\nif (x instanceof MyPromise) {\n    x.then(resolve, reject)\n}\n// resolve(x) // 否则，以它的返回值为 promise2 的结果\n```\n\n替换为：\n\n```js\nresolutionProcedure(promise2, x, resolve, reject)\n```\n\n总共四处，不要遗漏了\n\n#### Promise构建九：完整代码实现\n```js\n// 三种状态\nconst PENDING = \"pending\"\nconst RESOLVED = \"resolved\"\nconst REJECTED = \"rejected\"\nfunction MyPromise(callback) {\n    var _this = this\n    _this.currentState = PENDING // Promise当前的状态\n    _this.value = void 0 // Promise的值\n    // 用于保存 then 的回调， 只有当 promise\n    // 状态为 pending 时才会缓存，并且每个实例至多缓存一个\n    _this.onResolvedCallbacks = [] // Promise resolve时的回调函数集\n    _this.onRejectedCallbacks = [] // Promise reject时的回调函数集\n    _this.resolve = function (value) {\n        if (value instanceof MyPromise) {\n            // 如果 value 是个 Promise， 递归执行\n            return value.then(_this.resolve, _this.reject)\n        }\n        setTimeout(() ={ // 异步执行，保证顺序执行\n            if (_this.currentState === PENDING) {\n                _this.currentState = RESOLVED // 状态管理\n                _this.value = value\n                _this.onResolvedCallbacks.forEach(cb =cb())\n            }\n        })\n    } // resolve 处理函数\n    _this.reject = function (value) {\n        setTimeout(() ={ // 异步执行，保证顺序执行\n            if (_this.currentState === PENDING) {\n                _this.currentState = REJECTED // 状态管理\n                _this.value = value\n                _this.onRejectedCallbacks.forEach(cb =cb())\n            }\n        })\n    } // reject 处理函数\n\n    // 异常处理\n    // new Promise(() =throw Error('error'))\n    try {\n        callback(_this.resolve, _this.reject) // 执行callback并传入相应的参数\n    } catch(e) {\n        _this.reject(e)\n    }\n}\n// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调\nMyPromise.prototype.then = function(onFulfilled, onRejected) {\n    var _this = this\n    // 规范 2.2.7，then 必须返回一个新的 promise\n    var promise2\n    // 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数\n    // onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =value\n    onRejected = typeof onRejected === 'function' ? onRejected : error ={throw error}\n\n    if (_this.currentState === RESOLVED) {\n        // 如果promise1（此处为self/this）的状态已经确定并且为resolved，我们调用onFulfilled\n        // 如果考虑到有可能throw，所以我们将其包在try/catch块中\n        return promise2 = new MyPromise(function(resolve, reject) {\n            try {\n                var x = onFulfilled(_this.value)\n                // 如果 onFulfilled 的返回值是一个 Promise 对象，直接取它的结果作为 promise2 的结果\n                resolutionProcedure(promise2, x, resolve, reject)\n            } catch (err) {\n                reject(err) // 如果出错，以捕获到的错误作为promise2的结果\n            }\n        })\n    }\n    // 此处实现与FULFILLED相似，区别在使用的是onRejected而不是onFulfilled\n    if (_this.currentState === REJECTED) {\n        return promise2 = new MyPromise(function(resolve, reject) {\n            try {\n                var x = onRejected(_this.value)\n                resolutionProcedure(promise2, x, resolve, reject)\n            } catch(err) {\n                reject(err)\n            }\n        })\n    }\n    if (_this.currentState === PENDING) {\n        // 如果当前的Promise还处于PENDING状态，我们并不能确定调用onFulfilled还是onRejected\n        // 只有等待Promise的状态确定后，再做处理\n        // 所以我们需要把我们的两种情况的处理逻辑做成callback放入promise1（此处即_this/this）的回调数组内\n        // 处理逻辑和以上相似\n        return promise2 = new MyPromise(function(resolve, reject) {\n            _this.onResolvedCallbacks.push(function() {\n                try {\n                    var x = onFulfilled(_this.value)\n                    resolutionProcedure(promise2, x, resolve, reject)\n                } catch(err) {\n                    reject(err)\n                }\n            })\n            _this.onRejectedCallbacks.push(function() {\n                try {\n                    var x = onRejected(_this.value)\n                    resolutionProcedure(promise2, x, resolve, reject)\n                } catch (err) {\n                    reject(err)\n                }\n            })\n        })\n    }\n\n    // 规范 2.3\n    /*\n    resolutionProcedure函数即为根据x的值来决定promise2的状态的函数\n    也即标准中的[Promise Resolution Procedure](https://promisesaplus.com/#point-47)\n    x 为 promise2 = promise1.then(onFulfilled, onRejected)里onFulfilled/onRejected的返回值\n    resolve 和 reject 实际上是 promise2 的executor的两个实参，因为很难挂在其他地方，所以一并传过来。\n    相信各位一定可以对照标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释。\n    */\n    function resolutionProcedure(promise2, x, resolve, reject) {\n        // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用\n        if (promise2 === x) {\n            return reject(new TypeError(\"Chaining cycle detected for promise!\"))\n        }\n        // 规范 2.3.2\n        // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行\n        if (x instanceof MyPromise) {\n            // 2.3.2.1 如果x为pending状态，promise必须保持pending状态，直到x为fulfilled/rejected\n            if (x.currentState === PENDING) {\n                x.then(function(value) {\n                    // 再次调用该函数是为了确认 x resolve 的\n                    // 参数是什么类型，如果是基本类型就再次 resolve\n                    // 把值传给下个 then\n                    resolutionProcedure(promise2, value, resolve, reject)\n                }, reject)\n            } else { // 但如果这个promise的状态已经确定了，那么它肯定有一个正常的值，而不是一个thenable，所以这里可以取它的状态\n                x.then(resolve, reject)\n            }\n            return\n        }\n\n        let called = false\n        // 规范 2.3.3，判断 x 是否为对象或函数\n        if (x !== null && (typeof x === \"object\" || typeof x === \"function\")) {\n            // 规范 2.3.3.2，如果不能取出 then，就 reject\n            try {\n                // 规范2.3.3.1 因为x.then可能是一个getter，这种情况下多次读取就有可能产生副作用\n                // 既要判断它的类型，又要调用它，这就是两次读取\n                let then = x.then\n                // 规范2.3.3.3，如果 then 是函数，调用 x.then\n                if (typeof then === \"function\") {\n                    // 规范 2.3.3.3\n                    // reject 或 reject 其中一个执行过的话，忽略其他的\n                    then.call(\n                        x,\n                        y ={ // 规范 2.3.3.3.1\n                            if (called) return // 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准\n                            called = true\n                            // 规范 2.3.3.3.1\n                            return resolutionProcedure(promise2, y, resolve, reject)\n                        },\n                        r ={\n                            if (called) return // 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准\n                            called = true\n                            return reject(r)\n                        }\n                    )\n                } else {\n                    // 规范 2.3.3.4\n                    resolve(x)\n                }\n            } catch (e) { // 规范 2.3.3.2\n                if (called) return // 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准\n                called = true\n                return reject(e)\n            }\n        } else {\n            // 规范 2.3.4，x 为基本类型\n            resolve(x)\n        }\n    }\n}\n// catch 的实现\nMyPromise.prototype.catch = function (onRejected) {\n    return this.then(null, onRejected)\n}\n// finally 的实现\nMyPromise.prototype.finally = function (callback) {\n  return this.then(function (value) {\n    return MyPromise.resolve(callback()).then(function () {\n      return value\n    })\n  }, function (err) {\n    return MyPromise.resolve(callback()).then(function () {\n      throw err\n    })\n  })\n}\n```\n\n额外，附加 `Promise.race` 与 `Promise.all` 的实现，有兴趣的可以了解一下\n\n```js\n// race\nMyPromise.race = function(values) {\n    return new MyPromise(function(resolve, reject) {\n        values.forEach(function(value) {\n            MyPromise.resolve(value).then(resolve, reject)\n        })\n    })\n}\n// all\nMyPromise.all = function(arr) {\n    var args = Array.prototype.slice.call(arr)\n    return new MyPromise(function (resolve, reject) {\n        if (args.length === 0) return resolve([])\n        var remaining = args.length\n        for (var i = 0; i < args.length; i++) {\n            res(i, args[i])\n        }\n        function res(i, val) {\n            if (val && (typeof val === 'object' || typeof val === 'function')) {\n                if (val instanceof MyPromise && val.then === MyPromise.prototype.then) {\n                    if (val.currentState === RESOLVED) return res(i, val.value)\n                    if (val.currentState === REJECTED) reject(val.value)\n                    val.then(function (val) {\n                        res(i, val)\n                    }, reject)\n                    return\n                } else {\n                    var then = val.then\n                    if (typeof then === 'function') {\n                        var p = new MyPromise(then.bind(val))\n                        p.then(function(val) {\n                            res(i, val)\n                        }, reject)\n                        return\n                    }\n                }\n            }\n            args[i] = val\n            if (--remaining === 0) {\n                resolve(args)\n            }\n        }\n    })\n}\n```\n\nVoid 0 其实可以理解成undefined，因为undefined可以在局部函数里被覆盖，void 0 不会。\n\nvoid是一个运算符，给表达式求值，返回undefined。void 0 是表达式中最短的，最节省字节。\n\nsetTimeout 如果不传时间，默认取0。\n\n\n\n\n\n“参考”\n\n[promise取消的一些讨论](https://segmentfault.com/q/1010000009781257)\n\n","slug":"浏览器异步（三）之Promise实现","published":1,"updated":"2020-07-20T12:26:27.638Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmrk2002az5o864xpfwho","content":"<blockquote>\n<p>此篇博文转载自瓶子君的blog <a href=\"https://github.com/sisterAn/blog/issues/13\" target=\"_blank\" rel=\"noopener\">链接</a>，并加以自己的理解和注释。</p>\n</blockquote>\n<h3 id=\"Promise本质\"><a href=\"#Promise本质\" class=\"headerlink\" title=\"Promise本质\"></a>Promise本质</h3><p><strong>Promise就是为了解决callback的问题而产生的。</strong></p>\n<p>Promise 本质上就是一个绑定了回调的对象，而不是将回调传回函数内部。</p>\n<p><strong>开门见山，Promise解决的是回调函数处理异步的第2个问题：控制反转</strong>。</p>\n<p>我们把上面那个多层回调嵌套的例子用Promise的方式重构：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> getPromise1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Promsie(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        $.ajax(&#123;</span><br><span class=\"line\">            url: <span class=\"string\">'XXX1'</span>,</span><br><span class=\"line\">            success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">let</span> key = data;</span><br><span class=\"line\">               resolve(key);         </span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            error: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">                reject(err);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> getPromise2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Promsie(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        $.ajax(&#123;</span><br><span class=\"line\">            url: <span class=\"string\">'XXX2'</span>,</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\">                key: key</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">                resolve(data);         </span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            error: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">                reject(err);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> getPromise3 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Promsie(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        $.ajax(&#123;</span><br><span class=\"line\">            url: <span class=\"string\">'XXX3'</span>,</span><br><span class=\"line\">            success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">                resolve(data);         </span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            error: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">                reject(err);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">getPromise1()</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getPromise2(key);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getPromise3(data);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// todo</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'业务数据：'</span>, data);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>Promise 在一定程度上其实改善了回调函数的书写方式；另外逻辑性更明显了，将异步业务提取成单个函数，整个流程可以看到是一步步向下执行的，依赖层级也很清晰，最后需要的数据是在整个代码的最后一步获得。</p>\n<p>所以，Promise在一定程度上解决了回调函数的书写结构问题，但回调函数依然在主流程上存在，只不过都放到了then(…)里面，和我们大脑顺序线性的思维逻辑还是有出入的。</p>\n<h3 id=\"Promise-是什么\"><a href=\"#Promise-是什么\" class=\"headerlink\" title=\"Promise 是什么\"></a>Promise 是什么</h3><p>Promise是什么，无论是ES6的Promise也好，jQuery的Promise也好，不同的库有不同的实现，但是大家遵循的都是同一套规范，所以，Promise并不指特定的某个实现，<strong>它是一种规范，是一套处理JavaScript异步的机制</strong>。</p>\n<p>Promise的规范会多，如Promise/A、Promise/B、Promise/D以及Promise/A的升级版Promise/A+，其中ES6遵循Promise/A+规范，有关Promise/A+，你可以参考一下：</p>\n<ul>\n<li>英文版：<a href=\"https://promisesaplus.com\" target=\"_blank\" rel=\"noopener\">Promise/A+</a></li>\n<li>翻译版：<a href=\"http://www.ituring.com.cn/article/66566\" target=\"_blank\" rel=\"noopener\">【翻译】Promises/A+规范</a></li>\n</ul>\n<p>这里只简要介绍下几点与接下来内容相关的规范：</p>\n<ul>\n<li>Promise 本质是一个状态机，每个 Promise 有三种状态：pending、resolved以及rejected。状态转变只能是pending —resolved 或者 pending —rejected。状态转变不可逆。</li>\n<li>then 方法可以被同一个 promise 调用多次。</li>\n<li>then 方法必须返回一个 promise。规范2.2.7中规定， then 必须返回一个新的 Promise</li>\n<li>值穿透</li>\n</ul>\n<h3 id=\"Promise-实现及源码解读\"><a href=\"#Promise-实现及源码解读\" class=\"headerlink\" title=\"Promise 实现及源码解读\"></a>Promise 实现及源码解读</h3><p>首先，我们看一下Promise的简单使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Do an async task async task and then...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"comment\">/* good condition */</span>) &#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">'Success!'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        reject(<span class=\"string\">'Failure!'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">/* do something with the result */</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* error :( */</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>我们通过这种使用构建Promise实现的第一个版本</p>\n<p><strong>自己的写法也是结合调用实例的逆推过程</strong>。</p>\n<p>为什么要将callback单独传入呢？因为啊，new Promise(… ) 这括号里的函数逻辑是由我们编写的，可调整可修改，在任何条件下的resolve和reject，所以封装的时候最好写成一个通用的回调函数。</p>\n<h4 id=\"Promise构建版本一\"><a href=\"#Promise构建版本一\" class=\"headerlink\" title=\"Promise构建版本一\"></a>Promise构建版本一</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    _this.value = <span class=\"keyword\">void</span> <span class=\"number\">0</span> <span class=\"comment\">// Promise的值</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> onResolvedCallback  <span class=\"comment\">// Promise resolve回调函数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> onRejectedCallback  <span class=\"comment\">// Promise reject回调函数</span></span><br><span class=\"line\">    <span class=\"comment\">// resolve 处理函数</span></span><br><span class=\"line\">    _this.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        onResolvedCallback()</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// reject 处理函数</span></span><br><span class=\"line\">    _this.reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">        onRejectedCallback()</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    callback(_this.resolve, _this.reject) <span class=\"comment\">// 执行callback并传入相应的参数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 添加 then 方法 因为是promise的实例需要用到，所以then最好挂载在promise的原型上</span></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大致框架已经出来了，但我们看到Promise状态、reslove函数、reject函数以及then等都没有处理。</p>\n<h4 id=\"Promise构建之二：链式存储\"><a href=\"#Promise构建之二：链式存储\" class=\"headerlink\" title=\"Promise构建之二：链式存储\"></a>Promise构建之二：链式存储</h4><p>链式存储：讲的就是promise实例会有很多次then，然后下一次的then都会获得上一次的then的结果，就像链式一般。将结果存储下去，直至return。</p>\n<p>首先，举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">        resolve(a);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> b=<span class=\"number\">2</span>;</span><br><span class=\"line\">            resolve(b);</span><br><span class=\"line\">        &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> c=<span class=\"number\">3</span></span><br><span class=\"line\">            resolve(c);</span><br><span class=\"line\">        &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>上例结果是每间隔1s打印一个数字，顺序为1、2、3。</p>\n<p>这里保证了：</p>\n<ul>\n<li>让a,b,c的值能在then里面的回调接收到</li>\n<li>在连续调用异步，如何确保异步函数的执行顺序</li>\n</ul>\n<p>Promise一个常见的需求就是连续执行两个或者多个异步操作，这种情况下，每一个后来的操作都在前面的操作执行成功之后，带着上一步操作所返回的结果开始执行。这里用<code>setTimeout</code>来处理</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    _this.value = <span class=\"keyword\">void</span> <span class=\"number\">0</span> <span class=\"comment\">// Promise的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class=\"line\">    <span class=\"comment\">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class=\"line\">    _this.onResolvedCallbacks = [] <span class=\"comment\">// Promise resolve时的回调函数集</span></span><br><span class=\"line\">    _this.onRejectedCallbacks = [] <span class=\"comment\">// Promise reject时的回调函数集</span></span><br><span class=\"line\">    _this.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 异步执行</span></span><br><span class=\"line\">            _this.onResolvedCallbacks.forEach(cb =cb())</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// resolve 处理函数</span></span><br><span class=\"line\">    _this.reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 异步执行</span></span><br><span class=\"line\">            _this.onRejectedCallbacks.forEach(cb =cb())</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// reject 处理函数</span></span><br><span class=\"line\">    callback(_this.resolve, _this.reject) <span class=\"comment\">// 执行callback并传入相应的参数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 添加 then 方法</span></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise构建之三：状态机制、顺序执行\"><a href=\"#Promise构建之三：状态机制、顺序执行\" class=\"headerlink\" title=\"Promise构建之三：状态机制、顺序执行\"></a>Promise构建之三：状态机制、顺序执行</h4><p>为了保证Promise的异步操作时的顺序执行，这里给Promise加上状态机制</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 三种状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">\"pending\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> RESOLVED = <span class=\"string\">\"resolved\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">\"rejected\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    _this.currentState = PENDING <span class=\"comment\">// Promise当前的状态</span></span><br><span class=\"line\">    _this.value = <span class=\"keyword\">void</span> <span class=\"number\">0</span> <span class=\"comment\">// Promise的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class=\"line\">    <span class=\"comment\">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class=\"line\">    _this.onResolvedCallbacks = [] <span class=\"comment\">// Promise resolve时的回调函数集</span></span><br><span class=\"line\">    _this.onRejectedCallbacks = [] <span class=\"comment\">// Promise reject时的回调函数集</span></span><br><span class=\"line\">    _this.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 异步执行，保证顺序执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">                _this.currentState = RESOLVED <span class=\"comment\">// 状态管理</span></span><br><span class=\"line\">                _this.value = value</span><br><span class=\"line\">                _this.onResolvedCallbacks.forEach(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> cb())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// resolve 处理函数</span></span><br><span class=\"line\">    _this.reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 异步执行，保证顺序执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">            \t_this.currentState = REJECTED <span class=\"comment\">// 状态管理</span></span><br><span class=\"line\">            \t_this.value = value</span><br><span class=\"line\">            \t_this.onRejectedCallbacks.forEach(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> cb())</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// reject 处理函数</span></span><br><span class=\"line\">    callback(_this.resolve, _this.reject) <span class=\"comment\">// 执行callback并传入相应的参数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 添加 then 方法</span></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise构建之四：递归执行\"><a href=\"#Promise构建之四：递归执行\" class=\"headerlink\" title=\"Promise构建之四：递归执行\"></a>Promise构建之四：递归执行</h4><p>每个Promise后面链接一个对象，该对象包含onresolved,onrejected,子promise三个属性.</p>\n<p>当父Promise 状态改变完毕,执行完相应的onresolved/onrejected的时候，拿到子promise,在等待这个子promise状态改变，在执行相应的onresolved/onrejected。依次循环直到当前promise没有子promise。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 三种状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">\"pending\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> RESOLVED = <span class=\"string\">\"resolved\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">\"rejected\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    _this.currentState = PENDING <span class=\"comment\">// Promise当前的状态</span></span><br><span class=\"line\">    _this.value = <span class=\"keyword\">void</span> <span class=\"number\">0</span> <span class=\"comment\">// Promise的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class=\"line\">    <span class=\"comment\">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class=\"line\">    _this.onResolvedCallbacks = [] <span class=\"comment\">// Promise resolve时的回调函数集</span></span><br><span class=\"line\">    _this.onRejectedCallbacks = [] <span class=\"comment\">// Promise reject时的回调函数集</span></span><br><span class=\"line\">    _this.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 value 是个 MyPromise， 递归执行</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> value.then(_this.resolve, _this.reject)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 异步执行，保证顺序执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">                _this.currentState = RESOLVED <span class=\"comment\">// 状态管理</span></span><br><span class=\"line\">                _this.value = value</span><br><span class=\"line\">                _this.onResolvedCallbacks.forEach(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> cb())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// resolve 处理函数</span></span><br><span class=\"line\">    _this.reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 异步执行，保证顺序执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">            \t_this.currentState = REJECTED <span class=\"comment\">// 状态管理</span></span><br><span class=\"line\">            \t_this.value = value</span><br><span class=\"line\">            \t_this.onRejectedCallbacks.forEach(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> cb())</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// reject 处理函数</span></span><br><span class=\"line\">    callback(_this.resolve, _this.reject) <span class=\"comment\">// 执行callback并传入相应的参数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 添加 then 方法</span></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise构建之五：异常处理\"><a href=\"#Promise构建之五：异常处理\" class=\"headerlink\" title=\"Promise构建之五：异常处理\"></a>Promise构建之五：异常处理</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 三种状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">\"pending\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> RESOLVED = <span class=\"string\">\"resolved\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">\"rejected\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    _this.currentState = PENDING <span class=\"comment\">// Promise当前的状态</span></span><br><span class=\"line\">    _this.value = <span class=\"keyword\">void</span> <span class=\"number\">0</span> <span class=\"comment\">// Promise的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class=\"line\">    <span class=\"comment\">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class=\"line\">    _this.onResolvedCallbacks = [] <span class=\"comment\">// Promise resolve时的回调函数集</span></span><br><span class=\"line\">    _this.onRejectedCallbacks = [] <span class=\"comment\">// Promise reject时的回调函数集</span></span><br><span class=\"line\">    _this.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 value 是个 MyPromise， 递归执行</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> value.then(_this.resolve, _this.reject)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 异步执行，保证顺序执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">                _this.currentState = RESOLVED <span class=\"comment\">// 状态管理</span></span><br><span class=\"line\">                _this.value = value</span><br><span class=\"line\">                _this.onResolvedCallbacks.forEach(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> cb())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// resolve 处理函数</span></span><br><span class=\"line\">    _this.reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 异步执行，保证顺序执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">            \t_this.currentState = REJECTED <span class=\"comment\">// 状态管理</span></span><br><span class=\"line\">            \t_this.value = value</span><br><span class=\"line\">            \t_this.onRejectedCallbacks.forEach(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> cb())</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// reject 处理函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 异常处理</span></span><br><span class=\"line\">    <span class=\"comment\">// new Promise(() =throw Error('error'))</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        callback(_this.resolve, _this.reject) <span class=\"comment\">// 执行callback并传入相应的参数</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">        _this.reject(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 添加 then 方法</span></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise构建之六：then的实现\"><a href=\"#Promise构建之六：then的实现\" class=\"headerlink\" title=\"Promise构建之六：then的实现\"></a>Promise构建之六：then的实现</h4><p>then 方法是 Promise 的核心，这里做一下详细介绍。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>\n\n<p>一个 Promise 的then接受两个参数： onFulfilled和onRejected（都是可选参数，并且为函数，若不是函数将被忽略）</p>\n<ul>\n<li><p>onFulfilled 特性：</p>\n<ul>\n<li>当 Promise 执行结束后其必须被调用，其第一个参数为 promise 的终值，也就是 resolve 传过来的值</li>\n<li>在 Promise 执行结束前不可被调用</li>\n<li>其调用次数不可超过一次</li>\n</ul>\n</li>\n<li><p>onRejected 特性</p>\n<ul>\n<li>当 Promise 被拒绝执行后其必须被调用，第一个参数为 Promise 的拒绝原因，也就是reject传过来的值</li>\n<li>在 Promise 执行结束前不可被调用</li>\n<li>其调用次数不可超过一次</li>\n</ul>\n</li>\n<li><p>调用时机<br><code>onFulfilled</code> 和 <code>onRejected</code> 只有在<a href=\"http://es5.github.io/#x10.3\" target=\"_blank\" rel=\"noopener\">执行环境</a>堆栈仅包含<strong>平台代码</strong>时才可被调用（平台代码指引擎、环境以及 promise 的实施代码）</p>\n</li>\n<li><p>调用要求<br><code>onFulfilled</code> 和 <code>onRejected</code> 必须被作为函数调用（即没有 <code>this</code> 值，在 <strong>严格模式（strict）</strong> 中，函数 <code>this</code> 的值为 <code>undefined</code> ；在非严格模式中其为全局对象。）</p>\n</li>\n<li><p>多次调用<br><code>then</code> 方法可以被同一个 <code>promise</code> 调用多次</p>\n<ul>\n<li>当 <code>promise</code> 成功执行时，所有 <code>onFulfilled</code> 需按照其注册顺序依次回调</li>\n<li>当 <code>promise</code> 被拒绝执行时，所有的 <code>onRejected</code> 需按照其注册顺序依次回调</li>\n</ul>\n</li>\n<li><p>返回<br><code>then</code>方法会返回一个<code>Promise</code>，关于这一点，Promise/A+标准并没有要求返回的这个Promise是一个新的对象，但在Promise/A标准中，明确规定了then要返回一个新的对象，目前的Promise实现中then几乎都是返回一个新的Promise(<a href=\"https://promisesaplus.com/differences-from-promises-a#point-5\" target=\"_blank\" rel=\"noopener\">详情</a>)对象，所以在我们的实现中，也让then返回一个新的Promise对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise2 &#x3D; promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<ul>\n<li><p>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 <code>x</code> ，则运行下面的 <strong>Promise 解决过程</strong>：<code>[[Resolve]](promise2, x)</code></p>\n</li>\n<li><p>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须拒绝执行，并返回拒因 <code>e</code></p>\n</li>\n<li><p>如果 <code>onFulfilled</code> 不是函数且 <code>promise1</code> 成功执行， <code>promise2</code> 必须成功执行并返回相同的值</p>\n</li>\n<li><p>如果 <code>onRejected</code> 不是函数且 <code>promise1</code> 拒绝执行， <code>promise2</code> 必须拒绝执行并返回相同的拒因</p>\n</li>\n<li><p><em>不论 promise1 被 reject 还是被 resolve ， promise2 都会被 resolve，只有出现异常时才会被 rejected*</em>。<br>每个Promise对象都可以在其上多次调用then方法，而每次调用then返回的Promise的状态取决于那一次调用then时传入参数的返回值，所以then不能返回this，因为then每次返回的Promise的结果都有可能不同。</p>\n</li>\n</ul>\n<p>下面代码实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调</span></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"comment\">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> promise2</span><br><span class=\"line\">    <span class=\"comment\">// 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">// onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透</span></span><br><span class=\"line\">    onFulfilled = <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> ? onFulfilled : value =value</span><br><span class=\"line\">    onRejected = <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span> ? onRejected : error =&#123;<span class=\"keyword\">throw</span> error&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === RESOLVED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === REJECTED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>附：值穿透解读</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    onFulfilled = <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> ? onFulfilled : value =value</span><br><span class=\"line\">    onRejected = <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span> ? onRejected : error =&#123;<span class=\"keyword\">throw</span> error&#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面提到值穿透，值穿透即：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> MyPromise((resolve, reject) =&#123;</span><br><span class=\"line\">    setTimeout(() =&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">'1'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.then(<span class=\"string\">'2'</span>).then(<span class=\"built_in\">console</span>.log)</span><br></pre></td></tr></table></figure>\n\n<p>最终打结果是<code>1</code>而不是<code>2</code></p>\n<p>再例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> MyPromise(resolve =resolve(<span class=\"string\">'1'</span>))</span><br><span class=\"line\">    .then()</span><br><span class=\"line\">    .then()</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        alert(value)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"><span class=\"comment\">// output: alert 出 1</span></span><br></pre></td></tr></table></figure>\n\n<p>通过 <code>return this</code> 只实现了值穿透的一种情况，其实值穿透有两种情况：</p>\n<ol>\n<li>promise 已经是 RESOLVED/REJECTED 时，通过 return this 实现的值穿透：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(() =&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">'1'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.then(() =&#123;</span><br><span class=\"line\">    promise.then().then((res) =&#123; <span class=\"comment\">// 状况A</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res) <span class=\"comment\">// output: 1</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    promise.catch().then((res) =&#123; <span class=\"comment\">// 状况B</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res) <span class=\"comment\">// output: 1</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(promise.then() === promise.catch()) <span class=\"comment\">// output: true</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(promise.then(<span class=\"number\">1</span>) === promise.catch(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'anran'</span>&#125;)) <span class=\"comment\">// output: true</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ol>\n<p>   状况A与B处 promise 已经是 RESOLVED 了符合条件，所以执行了 <code>return this</code>。<br>   注意：原生的Promise实现里并不是这样实现的，会打印出两个false<br>2. promise 是 PENDING时，通过生成新的 promise 加入到父 promise 的 queue，父 promise 有值时调用 callFulfilled-&gt;doResolve 或 callRejected-&gt;doReject（因为 then/catch 传入的参数不是函数）设置子 promise 的状态和值为父 promise 的状态与值。如：<br>   <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>((resolve) =&#123;</span><br><span class=\"line\">    setTimeout(() =&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">'1'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = promise.then()</span><br><span class=\"line\">a.then((res) =&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res) <span class=\"comment\">// output: 1</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = promise.catch()</span><br><span class=\"line\">b.then((res) =&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res) <span class=\"comment\">// output: 1</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b) <span class=\"comment\">// output: false</span></span><br></pre></td></tr></table></figure></p>\n<p>Promise 有三种状态，我们分3个if块来处理，每块都返回一个new Promise。</p>\n<p>根据标准，我们知道，对于一下代码，promise2的值取决于then里面的返回值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise2 = promise1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'error'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>如果promise1被resolve了，promise2的被<code>1</code>resolve，如果promise1 被reject了，promise2将被<code>new Error(&#39;error&#39;)</code>reject。</p>\n<p>所以，我们需要在then里面执行onFulfilled或者onRejected，并根据返回着（标记中记为<code>x</code>）来确定promise2的结果，并且，如果onFulfilled/onRejected返回的是一个Promise，promise将直接取这个Promise的结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调</span></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"comment\">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> promise2</span><br><span class=\"line\">    <span class=\"comment\">// 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">// onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透</span></span><br><span class=\"line\">    onFulfilled = <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> ? onFulfilled : value =value</span><br><span class=\"line\">    onRejected = <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span> ? onRejected : error =&#123;<span class=\"keyword\">throw</span> error&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === RESOLVED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果promise1（此处为self/this）的状态已经确定并且为resolved，我们调用onFulfilled</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果考虑到有可能throw，所以我们将其包在try/catch块中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 规范 2.2.4，保证 onFulfilled，onRjected 异步执行</span></span><br><span class=\"line\">      \t\t<span class=\"comment\">// 所以用了 setTimeout 包裹下</span></span><br><span class=\"line\">            setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                \t<span class=\"keyword\">var</span> x = onFulfilled(_this.value)</span><br><span class=\"line\">                \t<span class=\"comment\">// 如果 onFulfilled 的返回值是一个 Promise 对象，直接取它的结果作为 promise2 的结果</span></span><br><span class=\"line\">                \t<span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">                    \tx.then(resolve, reject)</span><br><span class=\"line\">                \t&#125;</span><br><span class=\"line\">                \tresolve(x) <span class=\"comment\">// 否则，以它的返回值为 promise2 的结果</span></span><br><span class=\"line\">            \t&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">                \treject(err) <span class=\"comment\">// 如果出错，以捕获到的错误作为promise2的结果</span></span><br><span class=\"line\">            \t&#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 此处实现与FULFILLED相似，区别在使用的是onRejected而不是onFulfilled</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === REJECTED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                \t<span class=\"keyword\">var</span> x = onRejected(_this.value)</span><br><span class=\"line\">                \t<span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>)&#123;</span><br><span class=\"line\">                    \tx.then(resolve, reject)</span><br><span class=\"line\">                \t&#125;</span><br><span class=\"line\">            \t&#125; <span class=\"keyword\">catch</span>(err) &#123;</span><br><span class=\"line\">                \treject(err)</span><br><span class=\"line\">            \t&#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前的Promise还处于PENDING状态，我们并不能确定调用onFulfilled还是onRejected</span></span><br><span class=\"line\">        <span class=\"comment\">// 只有等待Promise的状态确定后，再做处理</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以我们需要把我们的两种情况的处理逻辑做成callback放入promise1（此处即self/this）的回调数组内</span></span><br><span class=\"line\">        <span class=\"comment\">// 处理逻辑和以上相似</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            _this.onResolvedCallbacks.push(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> x = onFulfilled(_this.value)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">                        x.then(resolve, reject)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    resolve(x)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span>(err) &#123;</span><br><span class=\"line\">                    reject(err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            _this.onRejectedCallbacks.push(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> x = onRejected(_this.value)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">                        x.then(resolve, reject)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">                    reject(err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise构建之七：catch的实现\"><a href=\"#Promise构建之七：catch的实现\" class=\"headerlink\" title=\"Promise构建之七：catch的实现\"></a>Promise构建之七：catch的实现</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// catch 的实现</span></span><br><span class=\"line\">MyPromise.prototype.catch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"literal\">null</span>, onRejected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此，我们大致实现了Promise标准中所涉及到的内容。</p>\n<h4 id=\"Promise构建之八：问题补充：无缝调用\"><a href=\"#Promise构建之八：问题补充：无缝调用\" class=\"headerlink\" title=\"Promise构建之八：问题补充：无缝调用\"></a>Promise构建之八：问题补充：无缝调用</h4><p>不同的Promise实现之间需要无缝的可交互，如ES6的Promise，和我们自己实现的Promise之间以及其他的Promise实现，必须是无缝调用的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">'1'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'2'</span>) <span class=\"comment\">// ES6 的 Promise</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Q.all([ <span class=\"comment\">// Q 的 Promise</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> MyPromise(resolve =resolve(<span class=\"string\">'3'</span>)) <span class=\"comment\">// 我们实现的Promise</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>.eresolve(<span class=\"string\">'4'</span>) <span class=\"comment\">// ES6 的 Promise</span></span><br><span class=\"line\">        Q.resolve(<span class=\"string\">'5'</span>) <span class=\"comment\">// Q 的 Promise</span></span><br><span class=\"line\">    ])</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>我之前实现的代码只是判断OnFullfilled/onRejected的返回值是否为我们自己实现的实例，并没有对其他类型Promise的判断，所以，上面的代码无法正常运行。</p>\n<p>接下来，我们解决这个问题</p>\n<p>关于不同Promise之间的交互，其实<a href=\"https://promisesaplus.com/#point-46\" target=\"_blank\" rel=\"noopener\">Promise/A+标准</a>中有介绍，其中详细的指定了如何通过then的实参返回的值来决定promise2的状态，我们只需要按照标准把标准的内容转成代码即可。</p>\n<p>即我们要<strong>把onFulfilled/onRejected的返回值x。当成是一个可能是Promise的对象</strong>，也即标准中的thenable，并以最保险的姿势调用x上的then方法，如果大家都按照标准来实现，那么不同的Promise之间就可以交互了。</p>\n<p>而标准为了保险起见，即使x返回了一个带有then属性但不遵循Promise标准的对象（不如说这个x把它then里的两个参数都调用了，同步或者异步调用（PS，原则上then的两个参数需要异步调用，下文会讲到），或者是出错后又调用了它们，或者then根本不是一个函数），也能尽可能正确处理。</p>\n<p>关于为何需要不同的Promise实现能够相互交互，我想原因应该是显然的，Promise并不是JS一早就有的标准，不同第三方的实现之间是并不相互知晓的，如果你使用的某一个库中封装了一个Promise实现，想象一下如果它不能跟你自己使用的Promise实现交互的场景。。。</p>\n<p>代码实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 规范 2.3</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">resolutionProcedure函数即为根据x的值来决定promise2的状态的函数</span></span><br><span class=\"line\"><span class=\"comment\">也即标准中的[Promise Resolution Procedure](https://promisesaplus.com/#point-47)</span></span><br><span class=\"line\"><span class=\"comment\">x 为 promise2 = promise1.then(onFulfilled, onRejected)里onFulfilled/onRejected的返回值</span></span><br><span class=\"line\"><span class=\"comment\">resolve 和 reject 实际上是 promise2 的executor的两个实参，因为很难挂在其他地方，所以一并传过来。</span></span><br><span class=\"line\"><span class=\"comment\">相信各位一定可以对照标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolutionProcedure</span>(<span class=\"params\">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (promise2 === x) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Chaining cycle detected for promise!\"</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 规范 2.3.2</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 x 为 Promise，状态为 pending 需要继续等待否则执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.3.2.1 如果x为pending状态，promise必须保持pending状态，直到x为fulfilled/rejected</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x.currentState === PENDING) &#123;</span><br><span class=\"line\">            x.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 再次调用该函数是为了确认 x resolve 的</span></span><br><span class=\"line\">                <span class=\"comment\">// 参数是什么类型，如果是基本类型就再次 resolve</span></span><br><span class=\"line\">                <span class=\"comment\">// 把值传给下个 then</span></span><br><span class=\"line\">                resolutionProcedure(promise2, value, resolve, reject)</span><br><span class=\"line\">            &#125;, reject)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 但如果这个promise的状态已经确定了，那么它肯定有一个正常的值，而不是一个thenable，所以这里可以取它的状态</span></span><br><span class=\"line\">            x.then(resolve, reject)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> called = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"comment\">// 规范 2.3.3，判断 x 是否为对象或函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x !== <span class=\"literal\">null</span> &amp;&amp; (<span class=\"keyword\">typeof</span> x === <span class=\"string\">\"object\"</span> || <span class=\"keyword\">typeof</span> x === <span class=\"string\">\"function\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 规范 2.3.3.2，如果不能取出 then，就 reject</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 规范2.3.3.1 因为x.then可能是一个getter，这种情况下多次读取就有可能产生副作用</span></span><br><span class=\"line\">            <span class=\"comment\">// 既要判断它的类型，又要调用它，这就是两次读取</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> then = x.then</span><br><span class=\"line\">            <span class=\"comment\">// 规范2.3.3.3，如果 then 是函数，调用 x.then</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> then === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 规范 2.3.3.3</span></span><br><span class=\"line\">    \t\t\t<span class=\"comment\">// reject 或 reject 其中一个执行过的话，忽略其他的</span></span><br><span class=\"line\">                then.call(</span><br><span class=\"line\">                    x,</span><br><span class=\"line\">                    y =&#123; <span class=\"comment\">// 规范 2.3.3.3.1</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span> <span class=\"comment\">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class=\"line\">                        called = <span class=\"literal\">true</span></span><br><span class=\"line\">                        <span class=\"comment\">// 规范 2.3.3.3.1</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> resolutionProcedure(promise2, y, resolve, reject)</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    r =&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span> <span class=\"comment\">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class=\"line\">                        called = <span class=\"literal\">true</span></span><br><span class=\"line\">                         <span class=\"keyword\">return</span> reject(r)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 规范 2.3.3.4</span></span><br><span class=\"line\">                resolve(x)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123; <span class=\"comment\">// 规范 2.3.3.2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span> <span class=\"comment\">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class=\"line\">            called = <span class=\"literal\">true</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> reject(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 规范 2.3.4，x 为基本类型</span></span><br><span class=\"line\">        resolve(x)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，我们使用<code>resolutionProcedure</code>函数替换<code>MyPromise.prototype.then</code>里面几处判断x是否为MyPromise对象的位置即可。即：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">    x.then(resolve, reject)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// resolve(x) // 否则，以它的返回值为 promise2 的结果</span></span><br></pre></td></tr></table></figure>\n\n<p>替换为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolutionProcedure(promise2, x, resolve, reject)</span><br></pre></td></tr></table></figure>\n\n<p>总共四处，不要遗漏了</p>\n<h4 id=\"Promise构建九：完整代码实现\"><a href=\"#Promise构建九：完整代码实现\" class=\"headerlink\" title=\"Promise构建九：完整代码实现\"></a>Promise构建九：完整代码实现</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 三种状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">\"pending\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> RESOLVED = <span class=\"string\">\"resolved\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">\"rejected\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    _this.currentState = PENDING <span class=\"comment\">// Promise当前的状态</span></span><br><span class=\"line\">    _this.value = <span class=\"keyword\">void</span> <span class=\"number\">0</span> <span class=\"comment\">// Promise的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class=\"line\">    <span class=\"comment\">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class=\"line\">    _this.onResolvedCallbacks = [] <span class=\"comment\">// Promise resolve时的回调函数集</span></span><br><span class=\"line\">    _this.onRejectedCallbacks = [] <span class=\"comment\">// Promise reject时的回调函数集</span></span><br><span class=\"line\">    _this.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 value 是个 Promise， 递归执行</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> value.then(_this.resolve, _this.reject)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setTimeout(() =&#123; <span class=\"comment\">// 异步执行，保证顺序执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">                _this.currentState = RESOLVED <span class=\"comment\">// 状态管理</span></span><br><span class=\"line\">                _this.value = value</span><br><span class=\"line\">                _this.onResolvedCallbacks.forEach(cb =cb())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// resolve 处理函数</span></span><br><span class=\"line\">    _this.reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(() =&#123; <span class=\"comment\">// 异步执行，保证顺序执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">                _this.currentState = REJECTED <span class=\"comment\">// 状态管理</span></span><br><span class=\"line\">                _this.value = value</span><br><span class=\"line\">                _this.onRejectedCallbacks.forEach(cb =cb())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// reject 处理函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 异常处理</span></span><br><span class=\"line\">    <span class=\"comment\">// new Promise(() =throw Error('error'))</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        callback(_this.resolve, _this.reject) <span class=\"comment\">// 执行callback并传入相应的参数</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">        _this.reject(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调</span></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"comment\">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> promise2</span><br><span class=\"line\">    <span class=\"comment\">// 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">// onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透</span></span><br><span class=\"line\">    onFulfilled = <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> ? onFulfilled : value =value</span><br><span class=\"line\">    onRejected = <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span> ? onRejected : error =&#123;<span class=\"keyword\">throw</span> error&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === RESOLVED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果promise1（此处为self/this）的状态已经确定并且为resolved，我们调用onFulfilled</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果考虑到有可能throw，所以我们将其包在try/catch块中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> x = onFulfilled(_this.value)</span><br><span class=\"line\">                <span class=\"comment\">// 如果 onFulfilled 的返回值是一个 Promise 对象，直接取它的结果作为 promise2 的结果</span></span><br><span class=\"line\">                resolutionProcedure(promise2, x, resolve, reject)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">                reject(err) <span class=\"comment\">// 如果出错，以捕获到的错误作为promise2的结果</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 此处实现与FULFILLED相似，区别在使用的是onRejected而不是onFulfilled</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === REJECTED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> x = onRejected(_this.value)</span><br><span class=\"line\">                resolutionProcedure(promise2, x, resolve, reject)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>(err) &#123;</span><br><span class=\"line\">                reject(err)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前的Promise还处于PENDING状态，我们并不能确定调用onFulfilled还是onRejected</span></span><br><span class=\"line\">        <span class=\"comment\">// 只有等待Promise的状态确定后，再做处理</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以我们需要把我们的两种情况的处理逻辑做成callback放入promise1（此处即_this/this）的回调数组内</span></span><br><span class=\"line\">        <span class=\"comment\">// 处理逻辑和以上相似</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            _this.onResolvedCallbacks.push(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> x = onFulfilled(_this.value)</span><br><span class=\"line\">                    resolutionProcedure(promise2, x, resolve, reject)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span>(err) &#123;</span><br><span class=\"line\">                    reject(err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            _this.onRejectedCallbacks.push(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> x = onRejected(_this.value)</span><br><span class=\"line\">                    resolutionProcedure(promise2, x, resolve, reject)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">                    reject(err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 规范 2.3</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    resolutionProcedure函数即为根据x的值来决定promise2的状态的函数</span></span><br><span class=\"line\"><span class=\"comment\">    也即标准中的[Promise Resolution Procedure](https://promisesaplus.com/#point-47)</span></span><br><span class=\"line\"><span class=\"comment\">    x 为 promise2 = promise1.then(onFulfilled, onRejected)里onFulfilled/onRejected的返回值</span></span><br><span class=\"line\"><span class=\"comment\">    resolve 和 reject 实际上是 promise2 的executor的两个实参，因为很难挂在其他地方，所以一并传过来。</span></span><br><span class=\"line\"><span class=\"comment\">    相信各位一定可以对照标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolutionProcedure</span>(<span class=\"params\">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (promise2 === x) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Chaining cycle detected for promise!\"</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 规范 2.3.2</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果 x 为 Promise，状态为 pending 需要继续等待否则执行</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 2.3.2.1 如果x为pending状态，promise必须保持pending状态，直到x为fulfilled/rejected</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x.currentState === PENDING) &#123;</span><br><span class=\"line\">                x.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 再次调用该函数是为了确认 x resolve 的</span></span><br><span class=\"line\">                    <span class=\"comment\">// 参数是什么类型，如果是基本类型就再次 resolve</span></span><br><span class=\"line\">                    <span class=\"comment\">// 把值传给下个 then</span></span><br><span class=\"line\">                    resolutionProcedure(promise2, value, resolve, reject)</span><br><span class=\"line\">                &#125;, reject)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 但如果这个promise的状态已经确定了，那么它肯定有一个正常的值，而不是一个thenable，所以这里可以取它的状态</span></span><br><span class=\"line\">                x.then(resolve, reject)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> called = <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"comment\">// 规范 2.3.3，判断 x 是否为对象或函数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x !== <span class=\"literal\">null</span> &amp;&amp; (<span class=\"keyword\">typeof</span> x === <span class=\"string\">\"object\"</span> || <span class=\"keyword\">typeof</span> x === <span class=\"string\">\"function\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 规范 2.3.3.2，如果不能取出 then，就 reject</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 规范2.3.3.1 因为x.then可能是一个getter，这种情况下多次读取就有可能产生副作用</span></span><br><span class=\"line\">                <span class=\"comment\">// 既要判断它的类型，又要调用它，这就是两次读取</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> then = x.then</span><br><span class=\"line\">                <span class=\"comment\">// 规范2.3.3.3，如果 then 是函数，调用 x.then</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> then === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 规范 2.3.3.3</span></span><br><span class=\"line\">                    <span class=\"comment\">// reject 或 reject 其中一个执行过的话，忽略其他的</span></span><br><span class=\"line\">                    then.call(</span><br><span class=\"line\">                        x,</span><br><span class=\"line\">                        y =&#123; <span class=\"comment\">// 规范 2.3.3.3.1</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span> <span class=\"comment\">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class=\"line\">                            called = <span class=\"literal\">true</span></span><br><span class=\"line\">                            <span class=\"comment\">// 规范 2.3.3.3.1</span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> resolutionProcedure(promise2, y, resolve, reject)</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                        r =&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span> <span class=\"comment\">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class=\"line\">                            called = <span class=\"literal\">true</span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> reject(r)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 规范 2.3.3.4</span></span><br><span class=\"line\">                    resolve(x)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (e) &#123; <span class=\"comment\">// 规范 2.3.3.2</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span> <span class=\"comment\">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class=\"line\">                called = <span class=\"literal\">true</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> reject(e)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 规范 2.3.4，x 为基本类型</span></span><br><span class=\"line\">            resolve(x)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// catch 的实现</span></span><br><span class=\"line\">MyPromise.prototype.catch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"literal\">null</span>, onRejected)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// finally 的实现</span></span><br><span class=\"line\">MyPromise.prototype.finally = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MyPromise.resolve(callback()).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MyPromise.resolve(callback()).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>额外，附加 <code>Promise.race</code> 与 <code>Promise.all</code> 的实现，有兴趣的可以了解一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// race</span></span><br><span class=\"line\">MyPromise.race = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">values</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        values.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">            MyPromise.resolve(value).then(resolve, reject)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// all</span></span><br><span class=\"line\">MyPromise.all = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(arr)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> resolve([])</span><br><span class=\"line\">        <span class=\"keyword\">var</span> remaining = args.length</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; args.length; i++) &#123;</span><br><span class=\"line\">            res(i, args[i])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">res</span>(<span class=\"params\">i, val</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val &amp;&amp; (<span class=\"keyword\">typeof</span> val === <span class=\"string\">'object'</span> || <span class=\"keyword\">typeof</span> val === <span class=\"string\">'function'</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (val <span class=\"keyword\">instanceof</span> MyPromise &amp;&amp; val.then === MyPromise.prototype.then) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (val.currentState === RESOLVED) <span class=\"keyword\">return</span> res(i, val.value)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (val.currentState === REJECTED) reject(val.value)</span><br><span class=\"line\">                    val.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">                        res(i, val)</span><br><span class=\"line\">                    &#125;, reject)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> then = val.then</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> then === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> MyPromise(then.bind(val))</span><br><span class=\"line\">                        p.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">                            res(i, val)</span><br><span class=\"line\">                        &#125;, reject)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            args[i] = val</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (--remaining === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                resolve(args)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Void 0 其实可以理解成undefined，因为undefined可以在局部函数里被覆盖，void 0 不会。</p>\n<p>void是一个运算符，给表达式求值，返回undefined。void 0 是表达式中最短的，最节省字节。</p>\n<p>setTimeout 如果不传时间，默认取0。</p>\n<p>“参考”</p>\n<p><a href=\"https://segmentfault.com/q/1010000009781257\" target=\"_blank\" rel=\"noopener\">promise取消的一些讨论</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>此篇博文转载自瓶子君的blog <a href=\"https://github.com/sisterAn/blog/issues/13\" target=\"_blank\" rel=\"noopener\">链接</a>，并加以自己的理解和注释。</p>\n</blockquote>\n<h3 id=\"Promise本质\"><a href=\"#Promise本质\" class=\"headerlink\" title=\"Promise本质\"></a>Promise本质</h3><p><strong>Promise就是为了解决callback的问题而产生的。</strong></p>\n<p>Promise 本质上就是一个绑定了回调的对象，而不是将回调传回函数内部。</p>\n<p><strong>开门见山，Promise解决的是回调函数处理异步的第2个问题：控制反转</strong>。</p>\n<p>我们把上面那个多层回调嵌套的例子用Promise的方式重构：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> getPromise1 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Promsie(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        $.ajax(&#123;</span><br><span class=\"line\">            url: <span class=\"string\">'XXX1'</span>,</span><br><span class=\"line\">            success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">let</span> key = data;</span><br><span class=\"line\">               resolve(key);         </span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            error: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">                reject(err);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> getPromise2 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Promsie(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        $.ajax(&#123;</span><br><span class=\"line\">            url: <span class=\"string\">'XXX2'</span>,</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\">                key: key</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">                resolve(data);         </span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            error: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">                reject(err);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> getPromise3 = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Promsie(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        $.ajax(&#123;</span><br><span class=\"line\">            url: <span class=\"string\">'XXX3'</span>,</span><br><span class=\"line\">            success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">                resolve(data);         </span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            error: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">                reject(err);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">getPromise1()</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getPromise2(key);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getPromise3(data);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// todo</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'业务数据：'</span>, data);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>Promise 在一定程度上其实改善了回调函数的书写方式；另外逻辑性更明显了，将异步业务提取成单个函数，整个流程可以看到是一步步向下执行的，依赖层级也很清晰，最后需要的数据是在整个代码的最后一步获得。</p>\n<p>所以，Promise在一定程度上解决了回调函数的书写结构问题，但回调函数依然在主流程上存在，只不过都放到了then(…)里面，和我们大脑顺序线性的思维逻辑还是有出入的。</p>\n<h3 id=\"Promise-是什么\"><a href=\"#Promise-是什么\" class=\"headerlink\" title=\"Promise 是什么\"></a>Promise 是什么</h3><p>Promise是什么，无论是ES6的Promise也好，jQuery的Promise也好，不同的库有不同的实现，但是大家遵循的都是同一套规范，所以，Promise并不指特定的某个实现，<strong>它是一种规范，是一套处理JavaScript异步的机制</strong>。</p>\n<p>Promise的规范会多，如Promise/A、Promise/B、Promise/D以及Promise/A的升级版Promise/A+，其中ES6遵循Promise/A+规范，有关Promise/A+，你可以参考一下：</p>\n<ul>\n<li>英文版：<a href=\"https://promisesaplus.com\" target=\"_blank\" rel=\"noopener\">Promise/A+</a></li>\n<li>翻译版：<a href=\"http://www.ituring.com.cn/article/66566\" target=\"_blank\" rel=\"noopener\">【翻译】Promises/A+规范</a></li>\n</ul>\n<p>这里只简要介绍下几点与接下来内容相关的规范：</p>\n<ul>\n<li>Promise 本质是一个状态机，每个 Promise 有三种状态：pending、resolved以及rejected。状态转变只能是pending —resolved 或者 pending —rejected。状态转变不可逆。</li>\n<li>then 方法可以被同一个 promise 调用多次。</li>\n<li>then 方法必须返回一个 promise。规范2.2.7中规定， then 必须返回一个新的 Promise</li>\n<li>值穿透</li>\n</ul>\n<h3 id=\"Promise-实现及源码解读\"><a href=\"#Promise-实现及源码解读\" class=\"headerlink\" title=\"Promise 实现及源码解读\"></a>Promise 实现及源码解读</h3><p>首先，我们看一下Promise的简单使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Do an async task async task and then...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"comment\">/* good condition */</span>) &#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">'Success!'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        reject(<span class=\"string\">'Failure!'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">/* do something with the result */</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* error :( */</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>我们通过这种使用构建Promise实现的第一个版本</p>\n<p><strong>自己的写法也是结合调用实例的逆推过程</strong>。</p>\n<p>为什么要将callback单独传入呢？因为啊，new Promise(… ) 这括号里的函数逻辑是由我们编写的，可调整可修改，在任何条件下的resolve和reject，所以封装的时候最好写成一个通用的回调函数。</p>\n<h4 id=\"Promise构建版本一\"><a href=\"#Promise构建版本一\" class=\"headerlink\" title=\"Promise构建版本一\"></a>Promise构建版本一</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    _this.value = <span class=\"keyword\">void</span> <span class=\"number\">0</span> <span class=\"comment\">// Promise的值</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> onResolvedCallback  <span class=\"comment\">// Promise resolve回调函数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> onRejectedCallback  <span class=\"comment\">// Promise reject回调函数</span></span><br><span class=\"line\">    <span class=\"comment\">// resolve 处理函数</span></span><br><span class=\"line\">    _this.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        onResolvedCallback()</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// reject 处理函数</span></span><br><span class=\"line\">    _this.reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">        onRejectedCallback()</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    callback(_this.resolve, _this.reject) <span class=\"comment\">// 执行callback并传入相应的参数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 添加 then 方法 因为是promise的实例需要用到，所以then最好挂载在promise的原型上</span></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大致框架已经出来了，但我们看到Promise状态、reslove函数、reject函数以及then等都没有处理。</p>\n<h4 id=\"Promise构建之二：链式存储\"><a href=\"#Promise构建之二：链式存储\" class=\"headerlink\" title=\"Promise构建之二：链式存储\"></a>Promise构建之二：链式存储</h4><p>链式存储：讲的就是promise实例会有很多次then，然后下一次的then都会获得上一次的then的结果，就像链式一般。将结果存储下去，直至return。</p>\n<p>首先，举个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">        resolve(a);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> b=<span class=\"number\">2</span>;</span><br><span class=\"line\">            resolve(b);</span><br><span class=\"line\">        &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> c=<span class=\"number\">3</span></span><br><span class=\"line\">            resolve(c);</span><br><span class=\"line\">        &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>上例结果是每间隔1s打印一个数字，顺序为1、2、3。</p>\n<p>这里保证了：</p>\n<ul>\n<li>让a,b,c的值能在then里面的回调接收到</li>\n<li>在连续调用异步，如何确保异步函数的执行顺序</li>\n</ul>\n<p>Promise一个常见的需求就是连续执行两个或者多个异步操作，这种情况下，每一个后来的操作都在前面的操作执行成功之后，带着上一步操作所返回的结果开始执行。这里用<code>setTimeout</code>来处理</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    _this.value = <span class=\"keyword\">void</span> <span class=\"number\">0</span> <span class=\"comment\">// Promise的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class=\"line\">    <span class=\"comment\">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class=\"line\">    _this.onResolvedCallbacks = [] <span class=\"comment\">// Promise resolve时的回调函数集</span></span><br><span class=\"line\">    _this.onRejectedCallbacks = [] <span class=\"comment\">// Promise reject时的回调函数集</span></span><br><span class=\"line\">    _this.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 异步执行</span></span><br><span class=\"line\">            _this.onResolvedCallbacks.forEach(cb =cb())</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// resolve 处理函数</span></span><br><span class=\"line\">    _this.reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 异步执行</span></span><br><span class=\"line\">            _this.onRejectedCallbacks.forEach(cb =cb())</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// reject 处理函数</span></span><br><span class=\"line\">    callback(_this.resolve, _this.reject) <span class=\"comment\">// 执行callback并传入相应的参数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 添加 then 方法</span></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise构建之三：状态机制、顺序执行\"><a href=\"#Promise构建之三：状态机制、顺序执行\" class=\"headerlink\" title=\"Promise构建之三：状态机制、顺序执行\"></a>Promise构建之三：状态机制、顺序执行</h4><p>为了保证Promise的异步操作时的顺序执行，这里给Promise加上状态机制</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 三种状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">\"pending\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> RESOLVED = <span class=\"string\">\"resolved\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">\"rejected\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    _this.currentState = PENDING <span class=\"comment\">// Promise当前的状态</span></span><br><span class=\"line\">    _this.value = <span class=\"keyword\">void</span> <span class=\"number\">0</span> <span class=\"comment\">// Promise的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class=\"line\">    <span class=\"comment\">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class=\"line\">    _this.onResolvedCallbacks = [] <span class=\"comment\">// Promise resolve时的回调函数集</span></span><br><span class=\"line\">    _this.onRejectedCallbacks = [] <span class=\"comment\">// Promise reject时的回调函数集</span></span><br><span class=\"line\">    _this.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 异步执行，保证顺序执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">                _this.currentState = RESOLVED <span class=\"comment\">// 状态管理</span></span><br><span class=\"line\">                _this.value = value</span><br><span class=\"line\">                _this.onResolvedCallbacks.forEach(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> cb())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// resolve 处理函数</span></span><br><span class=\"line\">    _this.reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 异步执行，保证顺序执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">            \t_this.currentState = REJECTED <span class=\"comment\">// 状态管理</span></span><br><span class=\"line\">            \t_this.value = value</span><br><span class=\"line\">            \t_this.onRejectedCallbacks.forEach(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> cb())</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// reject 处理函数</span></span><br><span class=\"line\">    callback(_this.resolve, _this.reject) <span class=\"comment\">// 执行callback并传入相应的参数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 添加 then 方法</span></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise构建之四：递归执行\"><a href=\"#Promise构建之四：递归执行\" class=\"headerlink\" title=\"Promise构建之四：递归执行\"></a>Promise构建之四：递归执行</h4><p>每个Promise后面链接一个对象，该对象包含onresolved,onrejected,子promise三个属性.</p>\n<p>当父Promise 状态改变完毕,执行完相应的onresolved/onrejected的时候，拿到子promise,在等待这个子promise状态改变，在执行相应的onresolved/onrejected。依次循环直到当前promise没有子promise。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 三种状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">\"pending\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> RESOLVED = <span class=\"string\">\"resolved\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">\"rejected\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    _this.currentState = PENDING <span class=\"comment\">// Promise当前的状态</span></span><br><span class=\"line\">    _this.value = <span class=\"keyword\">void</span> <span class=\"number\">0</span> <span class=\"comment\">// Promise的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class=\"line\">    <span class=\"comment\">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class=\"line\">    _this.onResolvedCallbacks = [] <span class=\"comment\">// Promise resolve时的回调函数集</span></span><br><span class=\"line\">    _this.onRejectedCallbacks = [] <span class=\"comment\">// Promise reject时的回调函数集</span></span><br><span class=\"line\">    _this.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 value 是个 MyPromise， 递归执行</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> value.then(_this.resolve, _this.reject)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 异步执行，保证顺序执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">                _this.currentState = RESOLVED <span class=\"comment\">// 状态管理</span></span><br><span class=\"line\">                _this.value = value</span><br><span class=\"line\">                _this.onResolvedCallbacks.forEach(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> cb())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// resolve 处理函数</span></span><br><span class=\"line\">    _this.reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 异步执行，保证顺序执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">            \t_this.currentState = REJECTED <span class=\"comment\">// 状态管理</span></span><br><span class=\"line\">            \t_this.value = value</span><br><span class=\"line\">            \t_this.onRejectedCallbacks.forEach(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> cb())</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// reject 处理函数</span></span><br><span class=\"line\">    callback(_this.resolve, _this.reject) <span class=\"comment\">// 执行callback并传入相应的参数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 添加 then 方法</span></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise构建之五：异常处理\"><a href=\"#Promise构建之五：异常处理\" class=\"headerlink\" title=\"Promise构建之五：异常处理\"></a>Promise构建之五：异常处理</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 三种状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">\"pending\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> RESOLVED = <span class=\"string\">\"resolved\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">\"rejected\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    _this.currentState = PENDING <span class=\"comment\">// Promise当前的状态</span></span><br><span class=\"line\">    _this.value = <span class=\"keyword\">void</span> <span class=\"number\">0</span> <span class=\"comment\">// Promise的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class=\"line\">    <span class=\"comment\">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class=\"line\">    _this.onResolvedCallbacks = [] <span class=\"comment\">// Promise resolve时的回调函数集</span></span><br><span class=\"line\">    _this.onRejectedCallbacks = [] <span class=\"comment\">// Promise reject时的回调函数集</span></span><br><span class=\"line\">    _this.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 value 是个 MyPromise， 递归执行</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> value.then(_this.resolve, _this.reject)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 异步执行，保证顺序执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">                _this.currentState = RESOLVED <span class=\"comment\">// 状态管理</span></span><br><span class=\"line\">                _this.value = value</span><br><span class=\"line\">                _this.onResolvedCallbacks.forEach(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> cb())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// resolve 处理函数</span></span><br><span class=\"line\">    _this.reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">// 异步执行，保证顺序执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">            \t_this.currentState = REJECTED <span class=\"comment\">// 状态管理</span></span><br><span class=\"line\">            \t_this.value = value</span><br><span class=\"line\">            \t_this.onRejectedCallbacks.forEach(<span class=\"function\"><span class=\"params\">cb</span> =&gt;</span> cb())</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// reject 处理函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 异常处理</span></span><br><span class=\"line\">    <span class=\"comment\">// new Promise(() =throw Error('error'))</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        callback(_this.resolve, _this.reject) <span class=\"comment\">// 执行callback并传入相应的参数</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">        _this.reject(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 添加 then 方法</span></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise构建之六：then的实现\"><a href=\"#Promise构建之六：then的实现\" class=\"headerlink\" title=\"Promise构建之六：then的实现\"></a>Promise构建之六：then的实现</h4><p>then 方法是 Promise 的核心，这里做一下详细介绍。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>\n\n<p>一个 Promise 的then接受两个参数： onFulfilled和onRejected（都是可选参数，并且为函数，若不是函数将被忽略）</p>\n<ul>\n<li><p>onFulfilled 特性：</p>\n<ul>\n<li>当 Promise 执行结束后其必须被调用，其第一个参数为 promise 的终值，也就是 resolve 传过来的值</li>\n<li>在 Promise 执行结束前不可被调用</li>\n<li>其调用次数不可超过一次</li>\n</ul>\n</li>\n<li><p>onRejected 特性</p>\n<ul>\n<li>当 Promise 被拒绝执行后其必须被调用，第一个参数为 Promise 的拒绝原因，也就是reject传过来的值</li>\n<li>在 Promise 执行结束前不可被调用</li>\n<li>其调用次数不可超过一次</li>\n</ul>\n</li>\n<li><p>调用时机<br><code>onFulfilled</code> 和 <code>onRejected</code> 只有在<a href=\"http://es5.github.io/#x10.3\" target=\"_blank\" rel=\"noopener\">执行环境</a>堆栈仅包含<strong>平台代码</strong>时才可被调用（平台代码指引擎、环境以及 promise 的实施代码）</p>\n</li>\n<li><p>调用要求<br><code>onFulfilled</code> 和 <code>onRejected</code> 必须被作为函数调用（即没有 <code>this</code> 值，在 <strong>严格模式（strict）</strong> 中，函数 <code>this</code> 的值为 <code>undefined</code> ；在非严格模式中其为全局对象。）</p>\n</li>\n<li><p>多次调用<br><code>then</code> 方法可以被同一个 <code>promise</code> 调用多次</p>\n<ul>\n<li>当 <code>promise</code> 成功执行时，所有 <code>onFulfilled</code> 需按照其注册顺序依次回调</li>\n<li>当 <code>promise</code> 被拒绝执行时，所有的 <code>onRejected</code> 需按照其注册顺序依次回调</li>\n</ul>\n</li>\n<li><p>返回<br><code>then</code>方法会返回一个<code>Promise</code>，关于这一点，Promise/A+标准并没有要求返回的这个Promise是一个新的对象，但在Promise/A标准中，明确规定了then要返回一个新的对象，目前的Promise实现中then几乎都是返回一个新的Promise(<a href=\"https://promisesaplus.com/differences-from-promises-a#point-5\" target=\"_blank\" rel=\"noopener\">详情</a>)对象，所以在我们的实现中，也让then返回一个新的Promise对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise2 &#x3D; promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<ul>\n<li><p>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 <code>x</code> ，则运行下面的 <strong>Promise 解决过程</strong>：<code>[[Resolve]](promise2, x)</code></p>\n</li>\n<li><p>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须拒绝执行，并返回拒因 <code>e</code></p>\n</li>\n<li><p>如果 <code>onFulfilled</code> 不是函数且 <code>promise1</code> 成功执行， <code>promise2</code> 必须成功执行并返回相同的值</p>\n</li>\n<li><p>如果 <code>onRejected</code> 不是函数且 <code>promise1</code> 拒绝执行， <code>promise2</code> 必须拒绝执行并返回相同的拒因</p>\n</li>\n<li><p><em>不论 promise1 被 reject 还是被 resolve ， promise2 都会被 resolve，只有出现异常时才会被 rejected*</em>。<br>每个Promise对象都可以在其上多次调用then方法，而每次调用then返回的Promise的状态取决于那一次调用then时传入参数的返回值，所以then不能返回this，因为then每次返回的Promise的结果都有可能不同。</p>\n</li>\n</ul>\n<p>下面代码实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调</span></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"comment\">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> promise2</span><br><span class=\"line\">    <span class=\"comment\">// 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">// onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透</span></span><br><span class=\"line\">    onFulfilled = <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> ? onFulfilled : value =value</span><br><span class=\"line\">    onRejected = <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span> ? onRejected : error =&#123;<span class=\"keyword\">throw</span> error&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === RESOLVED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === REJECTED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>附：值穿透解读</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    onFulfilled = <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> ? onFulfilled : value =value</span><br><span class=\"line\">    onRejected = <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span> ? onRejected : error =&#123;<span class=\"keyword\">throw</span> error&#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面提到值穿透，值穿透即：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> MyPromise((resolve, reject) =&#123;</span><br><span class=\"line\">    setTimeout(() =&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">'1'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.then(<span class=\"string\">'2'</span>).then(<span class=\"built_in\">console</span>.log)</span><br></pre></td></tr></table></figure>\n\n<p>最终打结果是<code>1</code>而不是<code>2</code></p>\n<p>再例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> MyPromise(resolve =resolve(<span class=\"string\">'1'</span>))</span><br><span class=\"line\">    .then()</span><br><span class=\"line\">    .then()</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        alert(value)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"><span class=\"comment\">// output: alert 出 1</span></span><br></pre></td></tr></table></figure>\n\n<p>通过 <code>return this</code> 只实现了值穿透的一种情况，其实值穿透有两种情况：</p>\n<ol>\n<li>promise 已经是 RESOLVED/REJECTED 时，通过 return this 实现的值穿透：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(() =&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">'1'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.then(() =&#123;</span><br><span class=\"line\">    promise.then().then((res) =&#123; <span class=\"comment\">// 状况A</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res) <span class=\"comment\">// output: 1</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    promise.catch().then((res) =&#123; <span class=\"comment\">// 状况B</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(res) <span class=\"comment\">// output: 1</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(promise.then() === promise.catch()) <span class=\"comment\">// output: true</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(promise.then(<span class=\"number\">1</span>) === promise.catch(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'anran'</span>&#125;)) <span class=\"comment\">// output: true</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ol>\n<p>   状况A与B处 promise 已经是 RESOLVED 了符合条件，所以执行了 <code>return this</code>。<br>   注意：原生的Promise实现里并不是这样实现的，会打印出两个false<br>2. promise 是 PENDING时，通过生成新的 promise 加入到父 promise 的 queue，父 promise 有值时调用 callFulfilled-&gt;doResolve 或 callRejected-&gt;doReject（因为 then/catch 传入的参数不是函数）设置子 promise 的状态和值为父 promise 的状态与值。如：<br>   <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>((resolve) =&#123;</span><br><span class=\"line\">    setTimeout(() =&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">'1'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = promise.then()</span><br><span class=\"line\">a.then((res) =&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res) <span class=\"comment\">// output: 1</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = promise.catch()</span><br><span class=\"line\">b.then((res) =&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res) <span class=\"comment\">// output: 1</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b) <span class=\"comment\">// output: false</span></span><br></pre></td></tr></table></figure></p>\n<p>Promise 有三种状态，我们分3个if块来处理，每块都返回一个new Promise。</p>\n<p>根据标准，我们知道，对于一下代码，promise2的值取决于then里面的返回值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise2 = promise1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'error'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>如果promise1被resolve了，promise2的被<code>1</code>resolve，如果promise1 被reject了，promise2将被<code>new Error(&#39;error&#39;)</code>reject。</p>\n<p>所以，我们需要在then里面执行onFulfilled或者onRejected，并根据返回着（标记中记为<code>x</code>）来确定promise2的结果，并且，如果onFulfilled/onRejected返回的是一个Promise，promise将直接取这个Promise的结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调</span></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"comment\">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> promise2</span><br><span class=\"line\">    <span class=\"comment\">// 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">// onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透</span></span><br><span class=\"line\">    onFulfilled = <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> ? onFulfilled : value =value</span><br><span class=\"line\">    onRejected = <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span> ? onRejected : error =&#123;<span class=\"keyword\">throw</span> error&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === RESOLVED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果promise1（此处为self/this）的状态已经确定并且为resolved，我们调用onFulfilled</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果考虑到有可能throw，所以我们将其包在try/catch块中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 规范 2.2.4，保证 onFulfilled，onRjected 异步执行</span></span><br><span class=\"line\">      \t\t<span class=\"comment\">// 所以用了 setTimeout 包裹下</span></span><br><span class=\"line\">            setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                \t<span class=\"keyword\">var</span> x = onFulfilled(_this.value)</span><br><span class=\"line\">                \t<span class=\"comment\">// 如果 onFulfilled 的返回值是一个 Promise 对象，直接取它的结果作为 promise2 的结果</span></span><br><span class=\"line\">                \t<span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">                    \tx.then(resolve, reject)</span><br><span class=\"line\">                \t&#125;</span><br><span class=\"line\">                \tresolve(x) <span class=\"comment\">// 否则，以它的返回值为 promise2 的结果</span></span><br><span class=\"line\">            \t&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">                \treject(err) <span class=\"comment\">// 如果出错，以捕获到的错误作为promise2的结果</span></span><br><span class=\"line\">            \t&#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 此处实现与FULFILLED相似，区别在使用的是onRejected而不是onFulfilled</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === REJECTED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                \t<span class=\"keyword\">var</span> x = onRejected(_this.value)</span><br><span class=\"line\">                \t<span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>)&#123;</span><br><span class=\"line\">                    \tx.then(resolve, reject)</span><br><span class=\"line\">                \t&#125;</span><br><span class=\"line\">            \t&#125; <span class=\"keyword\">catch</span>(err) &#123;</span><br><span class=\"line\">                \treject(err)</span><br><span class=\"line\">            \t&#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前的Promise还处于PENDING状态，我们并不能确定调用onFulfilled还是onRejected</span></span><br><span class=\"line\">        <span class=\"comment\">// 只有等待Promise的状态确定后，再做处理</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以我们需要把我们的两种情况的处理逻辑做成callback放入promise1（此处即self/this）的回调数组内</span></span><br><span class=\"line\">        <span class=\"comment\">// 处理逻辑和以上相似</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            _this.onResolvedCallbacks.push(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> x = onFulfilled(_this.value)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">                        x.then(resolve, reject)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    resolve(x)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span>(err) &#123;</span><br><span class=\"line\">                    reject(err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            _this.onRejectedCallbacks.push(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> x = onRejected(_this.value)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">                        x.then(resolve, reject)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">                    reject(err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise构建之七：catch的实现\"><a href=\"#Promise构建之七：catch的实现\" class=\"headerlink\" title=\"Promise构建之七：catch的实现\"></a>Promise构建之七：catch的实现</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// catch 的实现</span></span><br><span class=\"line\">MyPromise.prototype.catch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"literal\">null</span>, onRejected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此，我们大致实现了Promise标准中所涉及到的内容。</p>\n<h4 id=\"Promise构建之八：问题补充：无缝调用\"><a href=\"#Promise构建之八：问题补充：无缝调用\" class=\"headerlink\" title=\"Promise构建之八：问题补充：无缝调用\"></a>Promise构建之八：问题补充：无缝调用</h4><p>不同的Promise实现之间需要无缝的可交互，如ES6的Promise，和我们自己实现的Promise之间以及其他的Promise实现，必须是无缝调用的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"string\">'1'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">'2'</span>) <span class=\"comment\">// ES6 的 Promise</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Q.all([ <span class=\"comment\">// Q 的 Promise</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> MyPromise(resolve =resolve(<span class=\"string\">'3'</span>)) <span class=\"comment\">// 我们实现的Promise</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>.eresolve(<span class=\"string\">'4'</span>) <span class=\"comment\">// ES6 的 Promise</span></span><br><span class=\"line\">        Q.resolve(<span class=\"string\">'5'</span>) <span class=\"comment\">// Q 的 Promise</span></span><br><span class=\"line\">    ])</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>我之前实现的代码只是判断OnFullfilled/onRejected的返回值是否为我们自己实现的实例，并没有对其他类型Promise的判断，所以，上面的代码无法正常运行。</p>\n<p>接下来，我们解决这个问题</p>\n<p>关于不同Promise之间的交互，其实<a href=\"https://promisesaplus.com/#point-46\" target=\"_blank\" rel=\"noopener\">Promise/A+标准</a>中有介绍，其中详细的指定了如何通过then的实参返回的值来决定promise2的状态，我们只需要按照标准把标准的内容转成代码即可。</p>\n<p>即我们要<strong>把onFulfilled/onRejected的返回值x。当成是一个可能是Promise的对象</strong>，也即标准中的thenable，并以最保险的姿势调用x上的then方法，如果大家都按照标准来实现，那么不同的Promise之间就可以交互了。</p>\n<p>而标准为了保险起见，即使x返回了一个带有then属性但不遵循Promise标准的对象（不如说这个x把它then里的两个参数都调用了，同步或者异步调用（PS，原则上then的两个参数需要异步调用，下文会讲到），或者是出错后又调用了它们，或者then根本不是一个函数），也能尽可能正确处理。</p>\n<p>关于为何需要不同的Promise实现能够相互交互，我想原因应该是显然的，Promise并不是JS一早就有的标准，不同第三方的实现之间是并不相互知晓的，如果你使用的某一个库中封装了一个Promise实现，想象一下如果它不能跟你自己使用的Promise实现交互的场景。。。</p>\n<p>代码实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 规范 2.3</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">resolutionProcedure函数即为根据x的值来决定promise2的状态的函数</span></span><br><span class=\"line\"><span class=\"comment\">也即标准中的[Promise Resolution Procedure](https://promisesaplus.com/#point-47)</span></span><br><span class=\"line\"><span class=\"comment\">x 为 promise2 = promise1.then(onFulfilled, onRejected)里onFulfilled/onRejected的返回值</span></span><br><span class=\"line\"><span class=\"comment\">resolve 和 reject 实际上是 promise2 的executor的两个实参，因为很难挂在其他地方，所以一并传过来。</span></span><br><span class=\"line\"><span class=\"comment\">相信各位一定可以对照标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolutionProcedure</span>(<span class=\"params\">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (promise2 === x) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Chaining cycle detected for promise!\"</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 规范 2.3.2</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 x 为 Promise，状态为 pending 需要继续等待否则执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2.3.2.1 如果x为pending状态，promise必须保持pending状态，直到x为fulfilled/rejected</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x.currentState === PENDING) &#123;</span><br><span class=\"line\">            x.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 再次调用该函数是为了确认 x resolve 的</span></span><br><span class=\"line\">                <span class=\"comment\">// 参数是什么类型，如果是基本类型就再次 resolve</span></span><br><span class=\"line\">                <span class=\"comment\">// 把值传给下个 then</span></span><br><span class=\"line\">                resolutionProcedure(promise2, value, resolve, reject)</span><br><span class=\"line\">            &#125;, reject)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 但如果这个promise的状态已经确定了，那么它肯定有一个正常的值，而不是一个thenable，所以这里可以取它的状态</span></span><br><span class=\"line\">            x.then(resolve, reject)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> called = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"comment\">// 规范 2.3.3，判断 x 是否为对象或函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x !== <span class=\"literal\">null</span> &amp;&amp; (<span class=\"keyword\">typeof</span> x === <span class=\"string\">\"object\"</span> || <span class=\"keyword\">typeof</span> x === <span class=\"string\">\"function\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 规范 2.3.3.2，如果不能取出 then，就 reject</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 规范2.3.3.1 因为x.then可能是一个getter，这种情况下多次读取就有可能产生副作用</span></span><br><span class=\"line\">            <span class=\"comment\">// 既要判断它的类型，又要调用它，这就是两次读取</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> then = x.then</span><br><span class=\"line\">            <span class=\"comment\">// 规范2.3.3.3，如果 then 是函数，调用 x.then</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> then === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 规范 2.3.3.3</span></span><br><span class=\"line\">    \t\t\t<span class=\"comment\">// reject 或 reject 其中一个执行过的话，忽略其他的</span></span><br><span class=\"line\">                then.call(</span><br><span class=\"line\">                    x,</span><br><span class=\"line\">                    y =&#123; <span class=\"comment\">// 规范 2.3.3.3.1</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span> <span class=\"comment\">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class=\"line\">                        called = <span class=\"literal\">true</span></span><br><span class=\"line\">                        <span class=\"comment\">// 规范 2.3.3.3.1</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> resolutionProcedure(promise2, y, resolve, reject)</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    r =&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span> <span class=\"comment\">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class=\"line\">                        called = <span class=\"literal\">true</span></span><br><span class=\"line\">                         <span class=\"keyword\">return</span> reject(r)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 规范 2.3.3.4</span></span><br><span class=\"line\">                resolve(x)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123; <span class=\"comment\">// 规范 2.3.3.2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span> <span class=\"comment\">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class=\"line\">            called = <span class=\"literal\">true</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> reject(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 规范 2.3.4，x 为基本类型</span></span><br><span class=\"line\">        resolve(x)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，我们使用<code>resolutionProcedure</code>函数替换<code>MyPromise.prototype.then</code>里面几处判断x是否为MyPromise对象的位置即可。即：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">    x.then(resolve, reject)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// resolve(x) // 否则，以它的返回值为 promise2 的结果</span></span><br></pre></td></tr></table></figure>\n\n<p>替换为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolutionProcedure(promise2, x, resolve, reject)</span><br></pre></td></tr></table></figure>\n\n<p>总共四处，不要遗漏了</p>\n<h4 id=\"Promise构建九：完整代码实现\"><a href=\"#Promise构建九：完整代码实现\" class=\"headerlink\" title=\"Promise构建九：完整代码实现\"></a>Promise构建九：完整代码实现</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 三种状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PENDING = <span class=\"string\">\"pending\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> RESOLVED = <span class=\"string\">\"resolved\"</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> REJECTED = <span class=\"string\">\"rejected\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPromise</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    _this.currentState = PENDING <span class=\"comment\">// Promise当前的状态</span></span><br><span class=\"line\">    _this.value = <span class=\"keyword\">void</span> <span class=\"number\">0</span> <span class=\"comment\">// Promise的值</span></span><br><span class=\"line\">    <span class=\"comment\">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class=\"line\">    <span class=\"comment\">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class=\"line\">    _this.onResolvedCallbacks = [] <span class=\"comment\">// Promise resolve时的回调函数集</span></span><br><span class=\"line\">    _this.onRejectedCallbacks = [] <span class=\"comment\">// Promise reject时的回调函数集</span></span><br><span class=\"line\">    _this.resolve = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 value 是个 Promise， 递归执行</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> value.then(_this.resolve, _this.reject)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setTimeout(() =&#123; <span class=\"comment\">// 异步执行，保证顺序执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">                _this.currentState = RESOLVED <span class=\"comment\">// 状态管理</span></span><br><span class=\"line\">                _this.value = value</span><br><span class=\"line\">                _this.onResolvedCallbacks.forEach(cb =cb())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// resolve 处理函数</span></span><br><span class=\"line\">    _this.reject = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        setTimeout(() =&#123; <span class=\"comment\">// 异步执行，保证顺序执行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">                _this.currentState = REJECTED <span class=\"comment\">// 状态管理</span></span><br><span class=\"line\">                _this.value = value</span><br><span class=\"line\">                _this.onRejectedCallbacks.forEach(cb =cb())</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"comment\">// reject 处理函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 异常处理</span></span><br><span class=\"line\">    <span class=\"comment\">// new Promise(() =throw Error('error'))</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        callback(_this.resolve, _this.reject) <span class=\"comment\">// 执行callback并传入相应的参数</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">        _this.reject(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调</span></span><br><span class=\"line\">MyPromise.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"comment\">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> promise2</span><br><span class=\"line\">    <span class=\"comment\">// 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">// onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透</span></span><br><span class=\"line\">    onFulfilled = <span class=\"keyword\">typeof</span> onFulfilled === <span class=\"string\">'function'</span> ? onFulfilled : value =value</span><br><span class=\"line\">    onRejected = <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span> ? onRejected : error =&#123;<span class=\"keyword\">throw</span> error&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === RESOLVED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果promise1（此处为self/this）的状态已经确定并且为resolved，我们调用onFulfilled</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果考虑到有可能throw，所以我们将其包在try/catch块中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> x = onFulfilled(_this.value)</span><br><span class=\"line\">                <span class=\"comment\">// 如果 onFulfilled 的返回值是一个 Promise 对象，直接取它的结果作为 promise2 的结果</span></span><br><span class=\"line\">                resolutionProcedure(promise2, x, resolve, reject)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">                reject(err) <span class=\"comment\">// 如果出错，以捕获到的错误作为promise2的结果</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 此处实现与FULFILLED相似，区别在使用的是onRejected而不是onFulfilled</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === REJECTED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> x = onRejected(_this.value)</span><br><span class=\"line\">                resolutionProcedure(promise2, x, resolve, reject)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span>(err) &#123;</span><br><span class=\"line\">                reject(err)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_this.currentState === PENDING) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前的Promise还处于PENDING状态，我们并不能确定调用onFulfilled还是onRejected</span></span><br><span class=\"line\">        <span class=\"comment\">// 只有等待Promise的状态确定后，再做处理</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以我们需要把我们的两种情况的处理逻辑做成callback放入promise1（此处即_this/this）的回调数组内</span></span><br><span class=\"line\">        <span class=\"comment\">// 处理逻辑和以上相似</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">            _this.onResolvedCallbacks.push(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> x = onFulfilled(_this.value)</span><br><span class=\"line\">                    resolutionProcedure(promise2, x, resolve, reject)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span>(err) &#123;</span><br><span class=\"line\">                    reject(err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            _this.onRejectedCallbacks.push(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> x = onRejected(_this.value)</span><br><span class=\"line\">                    resolutionProcedure(promise2, x, resolve, reject)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">                    reject(err)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 规范 2.3</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    resolutionProcedure函数即为根据x的值来决定promise2的状态的函数</span></span><br><span class=\"line\"><span class=\"comment\">    也即标准中的[Promise Resolution Procedure](https://promisesaplus.com/#point-47)</span></span><br><span class=\"line\"><span class=\"comment\">    x 为 promise2 = promise1.then(onFulfilled, onRejected)里onFulfilled/onRejected的返回值</span></span><br><span class=\"line\"><span class=\"comment\">    resolve 和 reject 实际上是 promise2 的executor的两个实参，因为很难挂在其他地方，所以一并传过来。</span></span><br><span class=\"line\"><span class=\"comment\">    相信各位一定可以对照标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释。</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolutionProcedure</span>(<span class=\"params\">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (promise2 === x) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Chaining cycle detected for promise!\"</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 规范 2.3.2</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果 x 为 Promise，状态为 pending 需要继续等待否则执行</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> MyPromise) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 2.3.2.1 如果x为pending状态，promise必须保持pending状态，直到x为fulfilled/rejected</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x.currentState === PENDING) &#123;</span><br><span class=\"line\">                x.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 再次调用该函数是为了确认 x resolve 的</span></span><br><span class=\"line\">                    <span class=\"comment\">// 参数是什么类型，如果是基本类型就再次 resolve</span></span><br><span class=\"line\">                    <span class=\"comment\">// 把值传给下个 then</span></span><br><span class=\"line\">                    resolutionProcedure(promise2, value, resolve, reject)</span><br><span class=\"line\">                &#125;, reject)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 但如果这个promise的状态已经确定了，那么它肯定有一个正常的值，而不是一个thenable，所以这里可以取它的状态</span></span><br><span class=\"line\">                x.then(resolve, reject)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> called = <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"comment\">// 规范 2.3.3，判断 x 是否为对象或函数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x !== <span class=\"literal\">null</span> &amp;&amp; (<span class=\"keyword\">typeof</span> x === <span class=\"string\">\"object\"</span> || <span class=\"keyword\">typeof</span> x === <span class=\"string\">\"function\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 规范 2.3.3.2，如果不能取出 then，就 reject</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 规范2.3.3.1 因为x.then可能是一个getter，这种情况下多次读取就有可能产生副作用</span></span><br><span class=\"line\">                <span class=\"comment\">// 既要判断它的类型，又要调用它，这就是两次读取</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> then = x.then</span><br><span class=\"line\">                <span class=\"comment\">// 规范2.3.3.3，如果 then 是函数，调用 x.then</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> then === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 规范 2.3.3.3</span></span><br><span class=\"line\">                    <span class=\"comment\">// reject 或 reject 其中一个执行过的话，忽略其他的</span></span><br><span class=\"line\">                    then.call(</span><br><span class=\"line\">                        x,</span><br><span class=\"line\">                        y =&#123; <span class=\"comment\">// 规范 2.3.3.3.1</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span> <span class=\"comment\">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class=\"line\">                            called = <span class=\"literal\">true</span></span><br><span class=\"line\">                            <span class=\"comment\">// 规范 2.3.3.3.1</span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> resolutionProcedure(promise2, y, resolve, reject)</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                        r =&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span> <span class=\"comment\">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class=\"line\">                            called = <span class=\"literal\">true</span></span><br><span class=\"line\">                            <span class=\"keyword\">return</span> reject(r)</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 规范 2.3.3.4</span></span><br><span class=\"line\">                    resolve(x)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (e) &#123; <span class=\"comment\">// 规范 2.3.3.2</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span> <span class=\"comment\">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class=\"line\">                called = <span class=\"literal\">true</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> reject(e)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 规范 2.3.4，x 为基本类型</span></span><br><span class=\"line\">            resolve(x)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// catch 的实现</span></span><br><span class=\"line\">MyPromise.prototype.catch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">onRejected</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"literal\">null</span>, onRejected)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// finally 的实现</span></span><br><span class=\"line\">MyPromise.prototype.finally = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MyPromise.resolve(callback()).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MyPromise.resolve(callback()).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>额外，附加 <code>Promise.race</code> 与 <code>Promise.all</code> 的实现，有兴趣的可以了解一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// race</span></span><br><span class=\"line\">MyPromise.race = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">values</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        values.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">            MyPromise.resolve(value).then(resolve, reject)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// all</span></span><br><span class=\"line\">MyPromise.all = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(arr)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyPromise(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> resolve([])</span><br><span class=\"line\">        <span class=\"keyword\">var</span> remaining = args.length</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; args.length; i++) &#123;</span><br><span class=\"line\">            res(i, args[i])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">res</span>(<span class=\"params\">i, val</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val &amp;&amp; (<span class=\"keyword\">typeof</span> val === <span class=\"string\">'object'</span> || <span class=\"keyword\">typeof</span> val === <span class=\"string\">'function'</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (val <span class=\"keyword\">instanceof</span> MyPromise &amp;&amp; val.then === MyPromise.prototype.then) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (val.currentState === RESOLVED) <span class=\"keyword\">return</span> res(i, val.value)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (val.currentState === REJECTED) reject(val.value)</span><br><span class=\"line\">                    val.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">                        res(i, val)</span><br><span class=\"line\">                    &#125;, reject)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> then = val.then</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> then === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> MyPromise(then.bind(val))</span><br><span class=\"line\">                        p.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">                            res(i, val)</span><br><span class=\"line\">                        &#125;, reject)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            args[i] = val</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (--remaining === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                resolve(args)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Void 0 其实可以理解成undefined，因为undefined可以在局部函数里被覆盖，void 0 不会。</p>\n<p>void是一个运算符，给表达式求值，返回undefined。void 0 是表达式中最短的，最节省字节。</p>\n<p>setTimeout 如果不传时间，默认取0。</p>\n<p>“参考”</p>\n<p><a href=\"https://segmentfault.com/q/1010000009781257\" target=\"_blank\" rel=\"noopener\">promise取消的一些讨论</a></p>\n"},{"title":"移动端","date":"2018-11-03T02:23:53.000Z","_content":"\n#### 如何编写移动端😎 ？话不多说，即刻带大家进入今天主题\n\n- 如我们常规所见，移动端和PC端的最大差异就是：设备的分辨率。\n- 移动端：下面是一段默认加载在头部的设置`html标签的fontSize`的js\n```javascript\nexport default function (pageWidth= 750) { // 设计稿可以传参，普遍是750\n    !(function(win, doc){\n        function setFontSize() {\n            // 获取设备 宽度\n            var winWidth =  window.innerWidth;\n            var size = (winWidth / pageWidth) * 100;\n            doc.documentElement.style.fontSize = size + 'px' ;\n        }\n        var evt = 'onorientationchange' in win ? 'orientationchange' : 'resize';\n\n        var timer = null;\n\n        win.addEventListener(evt, function () {\n            clearTimeout(timer);\n\n            timer = setTimeout(setFontSize, 300);\n        }, false);\n\n        win.addEventListener(\"pageshow\", function(e) {\n            if (e.persisted) {\n                clearTimeout(timer);\n\n                timer = setTimeout(setFontSize, 300);\n            }\n        }, false);\n\n        setFontSize();\n\n    }(window, document));\n}\n```\n    + 动态的获取设备独立像素，然后除以设计稿的宽度(常规UI是输出750宽度)，要乘100，然后赋给根字体的`fontsize`，以致做到自适应，来动态改变根字体大小。这里拿到是百分比 。\n    + 为什么要乘100，首先假设说设备分辨率是375，375 / 750是0.5，0.5我们称为`比例R`.而浏览器默认最小字体为12px。 这时我们的0.5就会被12重置了。所以我们需要放大一些，而100又很好算。在此，就把浏览器默认字号设置为100px，刚才获取的0.5是比例。那么相乘后获得的50px，就是自适应后的html根字体大小。\n    + 为了适配移动端，把单位转换成rem。\n        ```js\n            body{\n                font-size: 16px; // 会使rem不跟随错误的12px或者10px （比如设置62.5%时，就会`bodysize`是10px，那样em和rem都会算错。）\n                }\n        ```\n    + 那么1rem 等于（2）步骤返回的html 根字体大小。但这时候问题来了，设计稿输出的是750宽的图纸，而且是px，那么中间该怎么转化？？？比如说1rem 等于50px 那我现在的banner图是690px高，我应该是输出一个690/50 = result(rem)\n      借助`sass函数`，输入值为690px，\n      ```js\n        @function pxTorem($px){//$px为需要转换的字号\n            @return $px / $browser-default-font-size * 1rem; // 其实这里可以理解为 $px * （1rem/ 100）,也就是banner图的高度 * （比例R），从而获得它在这个该设备应该有的大小。\n          }\n      ```\n      所以在我们平时写css的时候，可以这么写样式了\n      ```js\n        .city-li{\n          text-align: center;\n          height: pxTorem(56px);\n          line-height: pxTorem(56px);\n          padding-left: pxTorem(10px);\n            }\n      ```\n     \n- 在可以书写移动端样式后。继续探讨：第二差异是网络环境。网络加载速度不一致是移动端的瓶颈，所以代码量的大小和质量是移动端性能优化的关键。\n\n\n","source":"_posts/移动端.md","raw":"---\ntitle: 移动端\ndate: 2018-11-03 10:23:53\ntags: 移动端\n---\n\n#### 如何编写移动端😎 ？话不多说，即刻带大家进入今天主题\n\n- 如我们常规所见，移动端和PC端的最大差异就是：设备的分辨率。\n- 移动端：下面是一段默认加载在头部的设置`html标签的fontSize`的js\n```javascript\nexport default function (pageWidth= 750) { // 设计稿可以传参，普遍是750\n    !(function(win, doc){\n        function setFontSize() {\n            // 获取设备 宽度\n            var winWidth =  window.innerWidth;\n            var size = (winWidth / pageWidth) * 100;\n            doc.documentElement.style.fontSize = size + 'px' ;\n        }\n        var evt = 'onorientationchange' in win ? 'orientationchange' : 'resize';\n\n        var timer = null;\n\n        win.addEventListener(evt, function () {\n            clearTimeout(timer);\n\n            timer = setTimeout(setFontSize, 300);\n        }, false);\n\n        win.addEventListener(\"pageshow\", function(e) {\n            if (e.persisted) {\n                clearTimeout(timer);\n\n                timer = setTimeout(setFontSize, 300);\n            }\n        }, false);\n\n        setFontSize();\n\n    }(window, document));\n}\n```\n    + 动态的获取设备独立像素，然后除以设计稿的宽度(常规UI是输出750宽度)，要乘100，然后赋给根字体的`fontsize`，以致做到自适应，来动态改变根字体大小。这里拿到是百分比 。\n    + 为什么要乘100，首先假设说设备分辨率是375，375 / 750是0.5，0.5我们称为`比例R`.而浏览器默认最小字体为12px。 这时我们的0.5就会被12重置了。所以我们需要放大一些，而100又很好算。在此，就把浏览器默认字号设置为100px，刚才获取的0.5是比例。那么相乘后获得的50px，就是自适应后的html根字体大小。\n    + 为了适配移动端，把单位转换成rem。\n        ```js\n            body{\n                font-size: 16px; // 会使rem不跟随错误的12px或者10px （比如设置62.5%时，就会`bodysize`是10px，那样em和rem都会算错。）\n                }\n        ```\n    + 那么1rem 等于（2）步骤返回的html 根字体大小。但这时候问题来了，设计稿输出的是750宽的图纸，而且是px，那么中间该怎么转化？？？比如说1rem 等于50px 那我现在的banner图是690px高，我应该是输出一个690/50 = result(rem)\n      借助`sass函数`，输入值为690px，\n      ```js\n        @function pxTorem($px){//$px为需要转换的字号\n            @return $px / $browser-default-font-size * 1rem; // 其实这里可以理解为 $px * （1rem/ 100）,也就是banner图的高度 * （比例R），从而获得它在这个该设备应该有的大小。\n          }\n      ```\n      所以在我们平时写css的时候，可以这么写样式了\n      ```js\n        .city-li{\n          text-align: center;\n          height: pxTorem(56px);\n          line-height: pxTorem(56px);\n          padding-left: pxTorem(10px);\n            }\n      ```\n     \n- 在可以书写移动端样式后。继续探讨：第二差异是网络环境。网络加载速度不一致是移动端的瓶颈，所以代码量的大小和质量是移动端性能优化的关键。\n\n\n","slug":"移动端","published":1,"updated":"2018-11-25T06:13:44.668Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmrk3002bz5o84ppmg29n","content":"<h4 id=\"如何编写移动端😎-？话不多说，即刻带大家进入今天主题\"><a href=\"#如何编写移动端😎-？话不多说，即刻带大家进入今天主题\" class=\"headerlink\" title=\"如何编写移动端😎 ？话不多说，即刻带大家进入今天主题\"></a>如何编写移动端😎 ？话不多说，即刻带大家进入今天主题</h4><ul>\n<li><p>如我们常规所见，移动端和PC端的最大差异就是：设备的分辨率。</p>\n</li>\n<li><p>移动端：下面是一段默认加载在头部的设置<code>html标签的fontSize</code>的js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">pageWidth= <span class=\"number\">750</span></span>) </span>&#123; <span class=\"comment\">// 设计稿可以传参，普遍是750</span></span><br><span class=\"line\">    !(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">win, doc</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setFontSize</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取设备 宽度</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> winWidth =  <span class=\"built_in\">window</span>.innerWidth;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> size = (winWidth / pageWidth) * <span class=\"number\">100</span>;</span><br><span class=\"line\">            doc.documentElement.style.fontSize = size + <span class=\"string\">'px'</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> evt = <span class=\"string\">'onorientationchange'</span> <span class=\"keyword\">in</span> win ? <span class=\"string\">'orientationchange'</span> : <span class=\"string\">'resize'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        win.addEventListener(evt, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            clearTimeout(timer);</span><br><span class=\"line\"></span><br><span class=\"line\">            timer = setTimeout(setFontSize, <span class=\"number\">300</span>);</span><br><span class=\"line\">        &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        win.addEventListener(<span class=\"string\">\"pageshow\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.persisted) &#123;</span><br><span class=\"line\">                clearTimeout(timer);</span><br><span class=\"line\"></span><br><span class=\"line\">                timer = setTimeout(setFontSize, <span class=\"number\">300</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        setFontSize();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;(<span class=\"built_in\">window</span>, <span class=\"built_in\">document</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>动态的获取设备独立像素，然后除以设计稿的宽度(常规UI是输出750宽度)，要乘100，然后赋给根字体的<code>fontsize</code>，以致做到自适应，来动态改变根字体大小。这里拿到是百分比 。</li>\n<li>为什么要乘100，首先假设说设备分辨率是375，375 / 750是0.5，0.5我们称为<code>比例R</code>.而浏览器默认最小字体为12px。 这时我们的0.5就会被12重置了。所以我们需要放大一些，而100又很好算。在此，就把浏览器默认字号设置为100px，刚才获取的0.5是比例。那么相乘后获得的50px，就是自适应后的html根字体大小。</li>\n<li>为了适配移动端，把单位转换成rem。  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">body&#123;</span><br><span class=\"line\">    font-size: <span class=\"number\">16</span>px; <span class=\"comment\">// 会使rem不跟随错误的12px或者10px （比如设置62.5%时，就会`bodysize`是10px，那样em和rem都会算错。）</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n<li>那么1rem 等于（2）步骤返回的html 根字体大小。但这时候问题来了，设计稿输出的是750宽的图纸，而且是px，那么中间该怎么转化？？？比如说1rem 等于50px 那我现在的banner图是690px高，我应该是输出一个690/50 = result(rem)<br>借助<code>sass函数</code>，输入值为690px，<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pxTorem</span>(<span class=\"params\">$px</span>)</span>&#123;<span class=\"comment\">//$px为需要转换的字号</span></span><br><span class=\"line\">    @<span class=\"keyword\">return</span> $px / $browser-<span class=\"keyword\">default</span>-font-size * <span class=\"number\">1</span>rem; <span class=\"comment\">// 其实这里可以理解为 $px * （1rem/ 100）,也就是banner图的高度 * （比例R），从而获得它在这个该设备应该有的大小。</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n所以在我们平时写css的时候，可以这么写样式了<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.city-li&#123;</span><br><span class=\"line\">  text-align: center;</span><br><span class=\"line\">  height: pxTorem(<span class=\"number\">56</span>px);</span><br><span class=\"line\">  line-height: pxTorem(<span class=\"number\">56</span>px);</span><br><span class=\"line\">  padding-left: pxTorem(<span class=\"number\">10</span>px);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>在可以书写移动端样式后。继续探讨：第二差异是网络环境。网络加载速度不一致是移动端的瓶颈，所以代码量的大小和质量是移动端性能优化的关键。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"如何编写移动端😎-？话不多说，即刻带大家进入今天主题\"><a href=\"#如何编写移动端😎-？话不多说，即刻带大家进入今天主题\" class=\"headerlink\" title=\"如何编写移动端😎 ？话不多说，即刻带大家进入今天主题\"></a>如何编写移动端😎 ？话不多说，即刻带大家进入今天主题</h4><ul>\n<li><p>如我们常规所见，移动端和PC端的最大差异就是：设备的分辨率。</p>\n</li>\n<li><p>移动端：下面是一段默认加载在头部的设置<code>html标签的fontSize</code>的js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">pageWidth= <span class=\"number\">750</span></span>) </span>&#123; <span class=\"comment\">// 设计稿可以传参，普遍是750</span></span><br><span class=\"line\">    !(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">win, doc</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setFontSize</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取设备 宽度</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> winWidth =  <span class=\"built_in\">window</span>.innerWidth;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> size = (winWidth / pageWidth) * <span class=\"number\">100</span>;</span><br><span class=\"line\">            doc.documentElement.style.fontSize = size + <span class=\"string\">'px'</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> evt = <span class=\"string\">'onorientationchange'</span> <span class=\"keyword\">in</span> win ? <span class=\"string\">'orientationchange'</span> : <span class=\"string\">'resize'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        win.addEventListener(evt, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            clearTimeout(timer);</span><br><span class=\"line\"></span><br><span class=\"line\">            timer = setTimeout(setFontSize, <span class=\"number\">300</span>);</span><br><span class=\"line\">        &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        win.addEventListener(<span class=\"string\">\"pageshow\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.persisted) &#123;</span><br><span class=\"line\">                clearTimeout(timer);</span><br><span class=\"line\"></span><br><span class=\"line\">                timer = setTimeout(setFontSize, <span class=\"number\">300</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        setFontSize();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;(<span class=\"built_in\">window</span>, <span class=\"built_in\">document</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>动态的获取设备独立像素，然后除以设计稿的宽度(常规UI是输出750宽度)，要乘100，然后赋给根字体的<code>fontsize</code>，以致做到自适应，来动态改变根字体大小。这里拿到是百分比 。</li>\n<li>为什么要乘100，首先假设说设备分辨率是375，375 / 750是0.5，0.5我们称为<code>比例R</code>.而浏览器默认最小字体为12px。 这时我们的0.5就会被12重置了。所以我们需要放大一些，而100又很好算。在此，就把浏览器默认字号设置为100px，刚才获取的0.5是比例。那么相乘后获得的50px，就是自适应后的html根字体大小。</li>\n<li>为了适配移动端，把单位转换成rem。  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">body&#123;</span><br><span class=\"line\">    font-size: <span class=\"number\">16</span>px; <span class=\"comment\">// 会使rem不跟随错误的12px或者10px （比如设置62.5%时，就会`bodysize`是10px，那样em和rem都会算错。）</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n<li>那么1rem 等于（2）步骤返回的html 根字体大小。但这时候问题来了，设计稿输出的是750宽的图纸，而且是px，那么中间该怎么转化？？？比如说1rem 等于50px 那我现在的banner图是690px高，我应该是输出一个690/50 = result(rem)<br>借助<code>sass函数</code>，输入值为690px，<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pxTorem</span>(<span class=\"params\">$px</span>)</span>&#123;<span class=\"comment\">//$px为需要转换的字号</span></span><br><span class=\"line\">    @<span class=\"keyword\">return</span> $px / $browser-<span class=\"keyword\">default</span>-font-size * <span class=\"number\">1</span>rem; <span class=\"comment\">// 其实这里可以理解为 $px * （1rem/ 100）,也就是banner图的高度 * （比例R），从而获得它在这个该设备应该有的大小。</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n所以在我们平时写css的时候，可以这么写样式了<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.city-li&#123;</span><br><span class=\"line\">  text-align: center;</span><br><span class=\"line\">  height: pxTorem(<span class=\"number\">56</span>px);</span><br><span class=\"line\">  line-height: pxTorem(<span class=\"number\">56</span>px);</span><br><span class=\"line\">  padding-left: pxTorem(<span class=\"number\">10</span>px);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>在可以书写移动端样式后。继续探讨：第二差异是网络环境。网络加载速度不一致是移动端的瓶颈，所以代码量的大小和质量是移动端性能优化的关键。</p>\n</li>\n</ul>\n"},{"title":"移动端拖拽","date":"2019-02-25T12:30:49.000Z","_content":"\n> 今天聊一下移动端的拖拽，上周一个拖动的需求，正好整理下\n\n###### 场景是这样的\n    需要在H5邀请函里做名字栏位的拖拽，并且要能记住它的位置以便于图片合成。\n\n###### 用到的技术\n    它们都属于原生JS - 移动端监听拖拽的API。\n+ `touchStart` ：**开始触摸**屏幕时就触发\n+ `touchmove`：在屏幕上**滑动**时触发\n+ `touchend`:  **屏幕上离开**的时触发　　 \n\n- 其中*touchStart*和*touchmove*会提供*touch*对象,包含\n+ pageX：触摸目标在页面中的x坐标。\n+ pageY：触摸目标在页面中的y坐标。\n这次只用了这两个参数\n###### 还是上点代码吧\n```js\nfunction dragStart(e) {\n    isdrag = true;\n    tempX = parseInt($('.guest_name').css('left') + 0);\n    tempY = parseInt($('.guest_name').css('top') + 0);\n    x = e.touches[0].pageX;\n    y = e.touches[0].pageY;\n}\nfunction dragMove(e) {\n    if (isdrag) { // 这里 e.touches[0].pageY中的pageY\n        let curX = tempX + e.touches[0].pageX - x;\n        let curY = tempY + e.touches[0].pageY - y;\n        // 边界判断\n        // curX = curX < 0 ? 0 : curX;\n        curY = curY < 0 ? 0 : curY;\n        curX = curX < document.documentElement.clientWidth - 80 ? curX : document.documentElement.clientWidth - 80;\n        curY = curY < $('.firstPageBackground').height() - 25 ? curY : $('.firstPageBackground').height() - 25; // 这里的高度限制 $('.firstPageBackground').height() - 25 是来源于业务上，邀请函画布的高度，控制名字不能超出限制。25是名字本身的高度。都以px为单位。\n        $('.guest_name').css({\n            'left': 0,\n            'top': curY\n        });\n        // 禁止浏览器默认事件\n        e.preventDefault();\n    }\n}\nfunction dragEnd() {\n    isdrag = false;\n}\n```\n######     \n好啦，还是别卖关子了，其实原理就是，利用了两次监听移动提供的pageX和pageY 之差。将差值加到原来的绝对定位，left和top里。让dom的位置发生变化。从而达到拖拽的效果。\n\n###### 参考链接：\n[blog](https://blog.csdn.net/lee_magnum/article/details/17753807)\n[blog](https://blog.csdn.net/qq_35800306/article/details/59502392)\n","source":"_posts/移动端拖拽.md","raw":"---\ntitle: 移动端拖拽\ndate: 2019-02-25 20:30:49\ntags: 移动端\n---\n\n> 今天聊一下移动端的拖拽，上周一个拖动的需求，正好整理下\n\n###### 场景是这样的\n    需要在H5邀请函里做名字栏位的拖拽，并且要能记住它的位置以便于图片合成。\n\n###### 用到的技术\n    它们都属于原生JS - 移动端监听拖拽的API。\n+ `touchStart` ：**开始触摸**屏幕时就触发\n+ `touchmove`：在屏幕上**滑动**时触发\n+ `touchend`:  **屏幕上离开**的时触发　　 \n\n- 其中*touchStart*和*touchmove*会提供*touch*对象,包含\n+ pageX：触摸目标在页面中的x坐标。\n+ pageY：触摸目标在页面中的y坐标。\n这次只用了这两个参数\n###### 还是上点代码吧\n```js\nfunction dragStart(e) {\n    isdrag = true;\n    tempX = parseInt($('.guest_name').css('left') + 0);\n    tempY = parseInt($('.guest_name').css('top') + 0);\n    x = e.touches[0].pageX;\n    y = e.touches[0].pageY;\n}\nfunction dragMove(e) {\n    if (isdrag) { // 这里 e.touches[0].pageY中的pageY\n        let curX = tempX + e.touches[0].pageX - x;\n        let curY = tempY + e.touches[0].pageY - y;\n        // 边界判断\n        // curX = curX < 0 ? 0 : curX;\n        curY = curY < 0 ? 0 : curY;\n        curX = curX < document.documentElement.clientWidth - 80 ? curX : document.documentElement.clientWidth - 80;\n        curY = curY < $('.firstPageBackground').height() - 25 ? curY : $('.firstPageBackground').height() - 25; // 这里的高度限制 $('.firstPageBackground').height() - 25 是来源于业务上，邀请函画布的高度，控制名字不能超出限制。25是名字本身的高度。都以px为单位。\n        $('.guest_name').css({\n            'left': 0,\n            'top': curY\n        });\n        // 禁止浏览器默认事件\n        e.preventDefault();\n    }\n}\nfunction dragEnd() {\n    isdrag = false;\n}\n```\n######     \n好啦，还是别卖关子了，其实原理就是，利用了两次监听移动提供的pageX和pageY 之差。将差值加到原来的绝对定位，left和top里。让dom的位置发生变化。从而达到拖拽的效果。\n\n###### 参考链接：\n[blog](https://blog.csdn.net/lee_magnum/article/details/17753807)\n[blog](https://blog.csdn.net/qq_35800306/article/details/59502392)\n","slug":"移动端拖拽","published":1,"updated":"2019-03-16T13:51:24.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmrk5002dz5o855p93jxr","content":"<blockquote>\n<p>今天聊一下移动端的拖拽，上周一个拖动的需求，正好整理下</p>\n</blockquote>\n<h6 id=\"场景是这样的\"><a href=\"#场景是这样的\" class=\"headerlink\" title=\"场景是这样的\"></a>场景是这样的</h6><pre><code>需要在H5邀请函里做名字栏位的拖拽，并且要能记住它的位置以便于图片合成。</code></pre><h6 id=\"用到的技术\"><a href=\"#用到的技术\" class=\"headerlink\" title=\"用到的技术\"></a>用到的技术</h6><pre><code>它们都属于原生JS - 移动端监听拖拽的API。</code></pre><ul>\n<li><code>touchStart</code> ：<strong>开始触摸</strong>屏幕时就触发</li>\n<li><code>touchmove</code>：在屏幕上<strong>滑动</strong>时触发</li>\n<li><code>touchend</code>:  <strong>屏幕上离开</strong>的时触发　　 </li>\n</ul>\n<ul>\n<li>其中<em>touchStart</em>和<em>touchmove</em>会提供<em>touch</em>对象,包含</li>\n</ul>\n<ul>\n<li>pageX：触摸目标在页面中的x坐标。</li>\n<li>pageY：触摸目标在页面中的y坐标。<br>这次只用了这两个参数<h6 id=\"还是上点代码吧\"><a href=\"#还是上点代码吧\" class=\"headerlink\" title=\"还是上点代码吧\"></a>还是上点代码吧</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dragStart</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    isdrag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    tempX = <span class=\"built_in\">parseInt</span>($(<span class=\"string\">'.guest_name'</span>).css(<span class=\"string\">'left'</span>) + <span class=\"number\">0</span>);</span><br><span class=\"line\">    tempY = <span class=\"built_in\">parseInt</span>($(<span class=\"string\">'.guest_name'</span>).css(<span class=\"string\">'top'</span>) + <span class=\"number\">0</span>);</span><br><span class=\"line\">    x = e.touches[<span class=\"number\">0</span>].pageX;</span><br><span class=\"line\">    y = e.touches[<span class=\"number\">0</span>].pageY;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dragMove</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isdrag) &#123; <span class=\"comment\">// 这里 e.touches[0].pageY中的pageY</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> curX = tempX + e.touches[<span class=\"number\">0</span>].pageX - x;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> curY = tempY + e.touches[<span class=\"number\">0</span>].pageY - y;</span><br><span class=\"line\">        <span class=\"comment\">// 边界判断</span></span><br><span class=\"line\">        <span class=\"comment\">// curX = curX &lt; 0 ? 0 : curX;</span></span><br><span class=\"line\">        curY = curY &lt; <span class=\"number\">0</span> ? <span class=\"number\">0</span> : curY;</span><br><span class=\"line\">        curX = curX &lt; <span class=\"built_in\">document</span>.documentElement.clientWidth - <span class=\"number\">80</span> ? curX : <span class=\"built_in\">document</span>.documentElement.clientWidth - <span class=\"number\">80</span>;</span><br><span class=\"line\">        curY = curY &lt; $(<span class=\"string\">'.firstPageBackground'</span>).height() - <span class=\"number\">25</span> ? curY : $(<span class=\"string\">'.firstPageBackground'</span>).height() - <span class=\"number\">25</span>; <span class=\"comment\">// 这里的高度限制 $('.firstPageBackground').height() - 25 是来源于业务上，邀请函画布的高度，控制名字不能超出限制。25是名字本身的高度。都以px为单位。</span></span><br><span class=\"line\">        $(<span class=\"string\">'.guest_name'</span>).css(&#123;</span><br><span class=\"line\">            <span class=\"string\">'left'</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"string\">'top'</span>: curY</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 禁止浏览器默认事件</span></span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dragEnd</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    isdrag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id><a href=\"#\" class=\"headerlink\" title></a></h6>好啦，还是别卖关子了，其实原理就是，利用了两次监听移动提供的pageX和pageY 之差。将差值加到原来的绝对定位，left和top里。让dom的位置发生变化。从而达到拖拽的效果。</li>\n</ul>\n<h6 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h6><p><a href=\"https://blog.csdn.net/lee_magnum/article/details/17753807\" target=\"_blank\" rel=\"noopener\">blog</a><br><a href=\"https://blog.csdn.net/qq_35800306/article/details/59502392\" target=\"_blank\" rel=\"noopener\">blog</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>今天聊一下移动端的拖拽，上周一个拖动的需求，正好整理下</p>\n</blockquote>\n<h6 id=\"场景是这样的\"><a href=\"#场景是这样的\" class=\"headerlink\" title=\"场景是这样的\"></a>场景是这样的</h6><pre><code>需要在H5邀请函里做名字栏位的拖拽，并且要能记住它的位置以便于图片合成。</code></pre><h6 id=\"用到的技术\"><a href=\"#用到的技术\" class=\"headerlink\" title=\"用到的技术\"></a>用到的技术</h6><pre><code>它们都属于原生JS - 移动端监听拖拽的API。</code></pre><ul>\n<li><code>touchStart</code> ：<strong>开始触摸</strong>屏幕时就触发</li>\n<li><code>touchmove</code>：在屏幕上<strong>滑动</strong>时触发</li>\n<li><code>touchend</code>:  <strong>屏幕上离开</strong>的时触发　　 </li>\n</ul>\n<ul>\n<li>其中<em>touchStart</em>和<em>touchmove</em>会提供<em>touch</em>对象,包含</li>\n</ul>\n<ul>\n<li>pageX：触摸目标在页面中的x坐标。</li>\n<li>pageY：触摸目标在页面中的y坐标。<br>这次只用了这两个参数<h6 id=\"还是上点代码吧\"><a href=\"#还是上点代码吧\" class=\"headerlink\" title=\"还是上点代码吧\"></a>还是上点代码吧</h6><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dragStart</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    isdrag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    tempX = <span class=\"built_in\">parseInt</span>($(<span class=\"string\">'.guest_name'</span>).css(<span class=\"string\">'left'</span>) + <span class=\"number\">0</span>);</span><br><span class=\"line\">    tempY = <span class=\"built_in\">parseInt</span>($(<span class=\"string\">'.guest_name'</span>).css(<span class=\"string\">'top'</span>) + <span class=\"number\">0</span>);</span><br><span class=\"line\">    x = e.touches[<span class=\"number\">0</span>].pageX;</span><br><span class=\"line\">    y = e.touches[<span class=\"number\">0</span>].pageY;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dragMove</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isdrag) &#123; <span class=\"comment\">// 这里 e.touches[0].pageY中的pageY</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> curX = tempX + e.touches[<span class=\"number\">0</span>].pageX - x;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> curY = tempY + e.touches[<span class=\"number\">0</span>].pageY - y;</span><br><span class=\"line\">        <span class=\"comment\">// 边界判断</span></span><br><span class=\"line\">        <span class=\"comment\">// curX = curX &lt; 0 ? 0 : curX;</span></span><br><span class=\"line\">        curY = curY &lt; <span class=\"number\">0</span> ? <span class=\"number\">0</span> : curY;</span><br><span class=\"line\">        curX = curX &lt; <span class=\"built_in\">document</span>.documentElement.clientWidth - <span class=\"number\">80</span> ? curX : <span class=\"built_in\">document</span>.documentElement.clientWidth - <span class=\"number\">80</span>;</span><br><span class=\"line\">        curY = curY &lt; $(<span class=\"string\">'.firstPageBackground'</span>).height() - <span class=\"number\">25</span> ? curY : $(<span class=\"string\">'.firstPageBackground'</span>).height() - <span class=\"number\">25</span>; <span class=\"comment\">// 这里的高度限制 $('.firstPageBackground').height() - 25 是来源于业务上，邀请函画布的高度，控制名字不能超出限制。25是名字本身的高度。都以px为单位。</span></span><br><span class=\"line\">        $(<span class=\"string\">'.guest_name'</span>).css(&#123;</span><br><span class=\"line\">            <span class=\"string\">'left'</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"string\">'top'</span>: curY</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 禁止浏览器默认事件</span></span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dragEnd</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    isdrag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h6 id><a href=\"#\" class=\"headerlink\" title></a></h6>好啦，还是别卖关子了，其实原理就是，利用了两次监听移动提供的pageX和pageY 之差。将差值加到原来的绝对定位，left和top里。让dom的位置发生变化。从而达到拖拽的效果。</li>\n</ul>\n<h6 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h6><p><a href=\"https://blog.csdn.net/lee_magnum/article/details/17753807\" target=\"_blank\" rel=\"noopener\">blog</a><br><a href=\"https://blog.csdn.net/qq_35800306/article/details/59502392\" target=\"_blank\" rel=\"noopener\">blog</a></p>\n"},{"title":"算法","date":"2020-07-15T14:59:19.000Z","_content":"\n#### 1. 深度优先搜索 && 广度优先搜索 \n深度：一个人，一条路走到黑，路不通，则到上一个分叉口，再一次一条路走到黑，循环，直到找到出口为止\n广度：几个人，同时面对几个分叉路口，直到找到出口为止。像wifi状的数据节点分布就最适合这种算法。\n\n\n\n参考：\n[瓶子君 算法](https://github.com/sisterAn/JavaScript-Algorithms)","source":"_posts/算法.md","raw":"---\n    title: 算法\n    date: 2020-07-15 22:59:19\n    tags: 算法\n---\n\n#### 1. 深度优先搜索 && 广度优先搜索 \n深度：一个人，一条路走到黑，路不通，则到上一个分叉口，再一次一条路走到黑，循环，直到找到出口为止\n广度：几个人，同时面对几个分叉路口，直到找到出口为止。像wifi状的数据节点分布就最适合这种算法。\n\n\n\n参考：\n[瓶子君 算法](https://github.com/sisterAn/JavaScript-Algorithms)","slug":"算法","published":1,"updated":"2020-07-15T16:19:16.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmrk6002ez5o8dvlq5e9l","content":"<h4 id=\"1-深度优先搜索-amp-amp-广度优先搜索\"><a href=\"#1-深度优先搜索-amp-amp-广度优先搜索\" class=\"headerlink\" title=\"1. 深度优先搜索 &amp;&amp; 广度优先搜索\"></a>1. 深度优先搜索 &amp;&amp; 广度优先搜索</h4><p>深度：一个人，一条路走到黑，路不通，则到上一个分叉口，再一次一条路走到黑，循环，直到找到出口为止<br>广度：几个人，同时面对几个分叉路口，直到找到出口为止。像wifi状的数据节点分布就最适合这种算法。</p>\n<p>参考：<br><a href=\"https://github.com/sisterAn/JavaScript-Algorithms\" target=\"_blank\" rel=\"noopener\">瓶子君 算法</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1-深度优先搜索-amp-amp-广度优先搜索\"><a href=\"#1-深度优先搜索-amp-amp-广度优先搜索\" class=\"headerlink\" title=\"1. 深度优先搜索 &amp;&amp; 广度优先搜索\"></a>1. 深度优先搜索 &amp;&amp; 广度优先搜索</h4><p>深度：一个人，一条路走到黑，路不通，则到上一个分叉口，再一次一条路走到黑，循环，直到找到出口为止<br>广度：几个人，同时面对几个分叉路口，直到找到出口为止。像wifi状的数据节点分布就最适合这种算法。</p>\n<p>参考：<br><a href=\"https://github.com/sisterAn/JavaScript-Algorithms\" target=\"_blank\" rel=\"noopener\">瓶子君 算法</a></p>\n"},{"title":"JS的几种继承方式","date":"2020-04-07T09:20:35.000Z","_content":"\n唠嗑唠嗑JS的继承啦~~~<!--more-->\n#### 1. 原型链继承\n方式 `son.prototype = new father()`\n```javascript\nfunction grandFather() {\n    this.gF_paroperty = 'gF_paroperty'\n}\ngrandFather.prototype.getGFPropery = function() { // 祖父原型的方法\n  return this.gF_paroperty\n}\nfunction father() {\n    this.fatherPropery = 'fatherPropery'\n}\n\n// 建立 grandFather 和 father 的 连接 让父亲继承祖父（核心）\nfather.prototype = new grandFather(); \n\nfather.prototype.getFatherVal = function() { // 父亲原型的方法\n  return this.fatherPropery;\n}\n\nvar sonInstance = new father() // 儿子继承父亲\nconsole.log(sonInstance.getGFPropery()); // expect output : 'gF_paroperty'\nconsole.log(sonInstance.getFatherVal()); // expect output : fatherPropery\n\n```\n\n方法缺陷: 多个子实例会改变引用类型\n```javascript\nfunction SuperType(){\n  this.colors = [\"red\", \"blue\", \"green\"];\n}\nfunction SubType(){}\n\nSubType.prototype = new SuperType();\n\nvar instance1 = new SubType();\ninstance1.colors.push(\"black\");\nconsole.log(instance1.colors); //\"red,blue,green,black\"\n\nvar instance2 = new SubType(); \nconsole.log(instance2.colors); //\"red,blue,green,black\"\n\nconsole.log(instance2.__proto__.colors) // array[4]\n```\n\n#### 2. 构造函数 结合`call`继承\n描述：核心代码是`SuperType.call(this)`，创建子类实例时调用SuperType构造函数，于是SubType的`每个实例都会`将SuperType中的属性`复制一份`。\n```javascript\nfunction  SuperType(){\n    this.color=[\"red\",\"green\",\"blue\"];\n}\nSuperType.prototype.specialWay = '123'\n\nfunction  SubType(){\n    //继承自SuperType\n    SuperType.call(this);\n}\nvar instance1 = new SubType();\ninstance1.color.push(\"black\");\n// alert(instance1.color);//\"red,green,blue,black\"\n\nvar instance2 = new SubType();\n// alert(instance2.color);//\"red,green,blue\"\nconsole.log(instance2.specialWay); // output：undefined 原型上的属性、方法继承不了\n```\n<div class=\"tip\">\n(1) 只能继承父类的实例属性和方法，不能继承原型属性/方法\n(2) 无法实现复用，`每个子类都有父类实例函数的副本`，影响性能\n</div>\n\n#### 3. `Object.create` \n也就是提供一个返回一个新对象，并且该对象的__proto__指向传入的对象\n语法\n```javascript\nObject.create(proto[, propertiesObject])\n\n// 比较好的用法👍\nson.prototype = Object.create(father.prototype)\n```\n```javascript\n// 原理\nfunction object(obj){\n  function F(){}\n  F.prototype = obj;\n  return new F();\n}\n```\n<div class=\"tip\">\n(1) 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。\n(2) 无法传递参数\n</div>\n\n#### 4. ES6 `extends` `super`\n```javascript\nclass Rectangle {\n    // constructor\n    constructor(height, width) {\n        this.height = height;\n        this.width = width;\n    }\n    \n    // Getter\n    get area() {\n        return this.calcArea()\n    }\n    \n    // Method\n    calcArea() {\n        return this.height * this.width;\n    }\n}\n\nconst rectangle = new Rectangle(10, 20);\nconsole.log(rectangle.area);\n// 输出 200\n\n// 继承\nclass Square extends Rectangle {\n\n  constructor(length) {\n    super(length, length);\n    \n    // 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。\n    this.name = 'Square';\n  }\n\n  get area() {\n    return this.height * this.width;\n  }\n}\n\nconst square = new Square(10);\nconsole.log(square.area);\n// 输出 100\n\n```\n\n#### 5. ES5继承和ES6继承的区别\n+ ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.  \n+ ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。\n因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。\n  \n  \n  \n\n参考链接：\n[掘金](https://juejin.im/post/5bcb2e295188255c55472db0)","source":"_posts/继承.md","raw":"---\n    title: JS的几种继承方式\n    date: 2020-04-07 17:20:35\n    tags: 面试 JS \n---\n\n唠嗑唠嗑JS的继承啦~~~<!--more-->\n#### 1. 原型链继承\n方式 `son.prototype = new father()`\n```javascript\nfunction grandFather() {\n    this.gF_paroperty = 'gF_paroperty'\n}\ngrandFather.prototype.getGFPropery = function() { // 祖父原型的方法\n  return this.gF_paroperty\n}\nfunction father() {\n    this.fatherPropery = 'fatherPropery'\n}\n\n// 建立 grandFather 和 father 的 连接 让父亲继承祖父（核心）\nfather.prototype = new grandFather(); \n\nfather.prototype.getFatherVal = function() { // 父亲原型的方法\n  return this.fatherPropery;\n}\n\nvar sonInstance = new father() // 儿子继承父亲\nconsole.log(sonInstance.getGFPropery()); // expect output : 'gF_paroperty'\nconsole.log(sonInstance.getFatherVal()); // expect output : fatherPropery\n\n```\n\n方法缺陷: 多个子实例会改变引用类型\n```javascript\nfunction SuperType(){\n  this.colors = [\"red\", \"blue\", \"green\"];\n}\nfunction SubType(){}\n\nSubType.prototype = new SuperType();\n\nvar instance1 = new SubType();\ninstance1.colors.push(\"black\");\nconsole.log(instance1.colors); //\"red,blue,green,black\"\n\nvar instance2 = new SubType(); \nconsole.log(instance2.colors); //\"red,blue,green,black\"\n\nconsole.log(instance2.__proto__.colors) // array[4]\n```\n\n#### 2. 构造函数 结合`call`继承\n描述：核心代码是`SuperType.call(this)`，创建子类实例时调用SuperType构造函数，于是SubType的`每个实例都会`将SuperType中的属性`复制一份`。\n```javascript\nfunction  SuperType(){\n    this.color=[\"red\",\"green\",\"blue\"];\n}\nSuperType.prototype.specialWay = '123'\n\nfunction  SubType(){\n    //继承自SuperType\n    SuperType.call(this);\n}\nvar instance1 = new SubType();\ninstance1.color.push(\"black\");\n// alert(instance1.color);//\"red,green,blue,black\"\n\nvar instance2 = new SubType();\n// alert(instance2.color);//\"red,green,blue\"\nconsole.log(instance2.specialWay); // output：undefined 原型上的属性、方法继承不了\n```\n<div class=\"tip\">\n(1) 只能继承父类的实例属性和方法，不能继承原型属性/方法\n(2) 无法实现复用，`每个子类都有父类实例函数的副本`，影响性能\n</div>\n\n#### 3. `Object.create` \n也就是提供一个返回一个新对象，并且该对象的__proto__指向传入的对象\n语法\n```javascript\nObject.create(proto[, propertiesObject])\n\n// 比较好的用法👍\nson.prototype = Object.create(father.prototype)\n```\n```javascript\n// 原理\nfunction object(obj){\n  function F(){}\n  F.prototype = obj;\n  return new F();\n}\n```\n<div class=\"tip\">\n(1) 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。\n(2) 无法传递参数\n</div>\n\n#### 4. ES6 `extends` `super`\n```javascript\nclass Rectangle {\n    // constructor\n    constructor(height, width) {\n        this.height = height;\n        this.width = width;\n    }\n    \n    // Getter\n    get area() {\n        return this.calcArea()\n    }\n    \n    // Method\n    calcArea() {\n        return this.height * this.width;\n    }\n}\n\nconst rectangle = new Rectangle(10, 20);\nconsole.log(rectangle.area);\n// 输出 200\n\n// 继承\nclass Square extends Rectangle {\n\n  constructor(length) {\n    super(length, length);\n    \n    // 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。\n    this.name = 'Square';\n  }\n\n  get area() {\n    return this.height * this.width;\n  }\n}\n\nconst square = new Square(10);\nconsole.log(square.area);\n// 输出 100\n\n```\n\n#### 5. ES5继承和ES6继承的区别\n+ ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.  \n+ ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。\n因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。\n  \n  \n  \n\n参考链接：\n[掘金](https://juejin.im/post/5bcb2e295188255c55472db0)","slug":"继承","published":1,"updated":"2020-07-17T14:55:30.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmrk7002fz5o88b5p59lr","content":"<p>唠嗑唠嗑JS的继承啦<del>~</del><a id=\"more\"></a></p>\n<h4 id=\"1-原型链继承\"><a href=\"#1-原型链继承\" class=\"headerlink\" title=\"1. 原型链继承\"></a>1. 原型链继承</h4><p>方式 <code>son.prototype = new father()</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">grandFather</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.gF_paroperty = <span class=\"string\">'gF_paroperty'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">grandFather.prototype.getGFPropery = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 祖父原型的方法</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.gF_paroperty</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">father</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fatherPropery = <span class=\"string\">'fatherPropery'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 建立 grandFather 和 father 的 连接 让父亲继承祖父（核心）</span></span><br><span class=\"line\">father.prototype = <span class=\"keyword\">new</span> grandFather(); </span><br><span class=\"line\"></span><br><span class=\"line\">father.prototype.getFatherVal = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 父亲原型的方法</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.fatherPropery;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sonInstance = <span class=\"keyword\">new</span> father() <span class=\"comment\">// 儿子继承父亲</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sonInstance.getGFPropery()); <span class=\"comment\">// expect output : 'gF_paroperty'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sonInstance.getFatherVal()); <span class=\"comment\">// expect output : fatherPropery</span></span><br></pre></td></tr></table></figure>\n\n<p>方法缺陷: 多个子实例会改变引用类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.colors = [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"green\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\">instance1.colors.push(<span class=\"string\">\"black\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.colors); <span class=\"comment\">//\"red,blue,green,black\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType(); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.colors); <span class=\"comment\">//\"red,blue,green,black\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.__proto__.colors) <span class=\"comment\">// array[4]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-构造函数-结合call继承\"><a href=\"#2-构造函数-结合call继承\" class=\"headerlink\" title=\"2. 构造函数 结合call继承\"></a>2. 构造函数 结合<code>call</code>继承</h4><p>描述：核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用SuperType构造函数，于是SubType的<code>每个实例都会</code>将SuperType中的属性<code>复制一份</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>  <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.color=[<span class=\"string\">\"red\"</span>,<span class=\"string\">\"green\"</span>,<span class=\"string\">\"blue\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.specialWay = <span class=\"string\">'123'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>  <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//继承自SuperType</span></span><br><span class=\"line\">    SuperType.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\">instance1.color.push(<span class=\"string\">\"black\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// alert(instance1.color);//\"red,green,blue,black\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"comment\">// alert(instance2.color);//\"red,green,blue\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.specialWay); <span class=\"comment\">// output：undefined 原型上的属性、方法继承不了</span></span><br></pre></td></tr></table></figure>\n<div class=\"tip\">\n(1) 只能继承父类的实例属性和方法，不能继承原型属性/方法\n(2) 无法实现复用，`每个子类都有父类实例函数的副本`，影响性能\n</div>\n\n<h4 id=\"3-Object-create\"><a href=\"#3-Object-create\" class=\"headerlink\" title=\"3. Object.create\"></a>3. <code>Object.create</code></h4><p>也就是提供一个返回一个新对象，并且该对象的<strong>proto</strong>指向传入的对象<br>语法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.create(proto[, propertiesObject])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 比较好的用法👍</span></span><br><span class=\"line\">son.prototype = <span class=\"built_in\">Object</span>.create(father.prototype)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原理</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = obj;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"tip\">\n(1) 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。\n(2) 无法传递参数\n</div>\n\n<h4 id=\"4-ES6-extends-super\"><a href=\"#4-ES6-extends-super\" class=\"headerlink\" title=\"4. ES6 extends super\"></a>4. ES6 <code>extends</code> <code>super</code></h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// constructor</span></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(height, width) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Getter</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span> area() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.calcArea()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Method</span></span><br><span class=\"line\">    calcArea() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.height * <span class=\"keyword\">this</span>.width;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rectangle = <span class=\"keyword\">new</span> Rectangle(<span class=\"number\">10</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rectangle.area);</span><br><span class=\"line\"><span class=\"comment\">// 输出 200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 继承</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> <span class=\"keyword\">extends</span> <span class=\"title\">Rectangle</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(length, length);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'Square'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> area() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.height * <span class=\"keyword\">this</span>.width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> square = <span class=\"keyword\">new</span> Square(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(square.area);</span><br><span class=\"line\"><span class=\"comment\">// 输出 100</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-ES5继承和ES6继承的区别\"><a href=\"#5-ES5继承和ES6继承的区别\" class=\"headerlink\" title=\"5. ES5继承和ES6继承的区别\"></a>5. ES5继承和ES6继承的区别</h4><ul>\n<li>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.  </li>\n<li>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。<br>因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</li>\n</ul>\n<p>参考链接：<br><a href=\"https://juejin.im/post/5bcb2e295188255c55472db0\" target=\"_blank\" rel=\"noopener\">掘金</a></p>\n","site":{"data":{}},"excerpt":"<p>唠嗑唠嗑JS的继承啦<del>~</del></p>","more":"<p></p>\n<h4 id=\"1-原型链继承\"><a href=\"#1-原型链继承\" class=\"headerlink\" title=\"1. 原型链继承\"></a>1. 原型链继承</h4><p>方式 <code>son.prototype = new father()</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">grandFather</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.gF_paroperty = <span class=\"string\">'gF_paroperty'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">grandFather.prototype.getGFPropery = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 祖父原型的方法</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.gF_paroperty</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">father</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fatherPropery = <span class=\"string\">'fatherPropery'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 建立 grandFather 和 father 的 连接 让父亲继承祖父（核心）</span></span><br><span class=\"line\">father.prototype = <span class=\"keyword\">new</span> grandFather(); </span><br><span class=\"line\"></span><br><span class=\"line\">father.prototype.getFatherVal = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 父亲原型的方法</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.fatherPropery;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sonInstance = <span class=\"keyword\">new</span> father() <span class=\"comment\">// 儿子继承父亲</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sonInstance.getGFPropery()); <span class=\"comment\">// expect output : 'gF_paroperty'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sonInstance.getFatherVal()); <span class=\"comment\">// expect output : fatherPropery</span></span><br></pre></td></tr></table></figure>\n\n<p>方法缺陷: 多个子实例会改变引用类型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.colors = [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"green\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\">instance1.colors.push(<span class=\"string\">\"black\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance1.colors); <span class=\"comment\">//\"red,blue,green,black\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType(); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.colors); <span class=\"comment\">//\"red,blue,green,black\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.__proto__.colors) <span class=\"comment\">// array[4]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-构造函数-结合call继承\"><a href=\"#2-构造函数-结合call继承\" class=\"headerlink\" title=\"2. 构造函数 结合call继承\"></a>2. 构造函数 结合<code>call</code>继承</h4><p>描述：核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用SuperType构造函数，于是SubType的<code>每个实例都会</code>将SuperType中的属性<code>复制一份</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>  <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.color=[<span class=\"string\">\"red\"</span>,<span class=\"string\">\"green\"</span>,<span class=\"string\">\"blue\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.specialWay = <span class=\"string\">'123'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>  <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//继承自SuperType</span></span><br><span class=\"line\">    SuperType.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\">instance1.color.push(<span class=\"string\">\"black\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// alert(instance1.color);//\"red,green,blue,black\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\"><span class=\"comment\">// alert(instance2.color);//\"red,green,blue\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(instance2.specialWay); <span class=\"comment\">// output：undefined 原型上的属性、方法继承不了</span></span><br></pre></td></tr></table></figure>\n<div class=\"tip\">\n(1) 只能继承父类的实例属性和方法，不能继承原型属性/方法\n(2) 无法实现复用，`每个子类都有父类实例函数的副本`，影响性能\n</div>\n\n<h4 id=\"3-Object-create\"><a href=\"#3-Object-create\" class=\"headerlink\" title=\"3. Object.create\"></a>3. <code>Object.create</code></h4><p>也就是提供一个返回一个新对象，并且该对象的<strong>proto</strong>指向传入的对象<br>语法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.create(proto[, propertiesObject])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 比较好的用法👍</span></span><br><span class=\"line\">son.prototype = <span class=\"built_in\">Object</span>.create(father.prototype)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原理</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = obj;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<div class=\"tip\">\n(1) 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。\n(2) 无法传递参数\n</div>\n\n<h4 id=\"4-ES6-extends-super\"><a href=\"#4-ES6-extends-super\" class=\"headerlink\" title=\"4. ES6 extends super\"></a>4. ES6 <code>extends</code> <code>super</code></h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// constructor</span></span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(height, width) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Getter</span></span><br><span class=\"line\">    <span class=\"keyword\">get</span> area() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.calcArea()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Method</span></span><br><span class=\"line\">    calcArea() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.height * <span class=\"keyword\">this</span>.width;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rectangle = <span class=\"keyword\">new</span> Rectangle(<span class=\"number\">10</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rectangle.area);</span><br><span class=\"line\"><span class=\"comment\">// 输出 200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 继承</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> <span class=\"keyword\">extends</span> <span class=\"title\">Rectangle</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(length, length);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'Square'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> area() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.height * <span class=\"keyword\">this</span>.width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> square = <span class=\"keyword\">new</span> Square(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(square.area);</span><br><span class=\"line\"><span class=\"comment\">// 输出 100</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-ES5继承和ES6继承的区别\"><a href=\"#5-ES5继承和ES6继承的区别\" class=\"headerlink\" title=\"5. ES5继承和ES6继承的区别\"></a>5. ES5继承和ES6继承的区别</h4><ul>\n<li>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.  </li>\n<li>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。<br>因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</li>\n</ul>\n<p>参考链接：<br><a href=\"https://juejin.im/post/5bcb2e295188255c55472db0\" target=\"_blank\" rel=\"noopener\">掘金</a></p>"},{"title":"浏览器-重排&&重绘","date":"2020-07-20T10:00:00.000Z","_content":"\n![重绘重排1](/重绘&&重排/重绘重排1.png)\n![重绘重排2](/重绘&&重排/重绘重排2.png)\n![重绘重排3](/重绘&&重排/重绘重排3.png)\n![重绘重排4](/重绘&&重排/重绘重排4.png)\n\n\n参考：\n[segment](https://segmentfault.com/a/1190000016990089)\n","source":"_posts/重绘&&重排.md","raw":"---\ntitle: 浏览器-重排&&重绘\ndate: 2020-07-20 18:00:00\ntags: 浏览器 CSS渲染\n---\n\n![重绘重排1](/重绘&&重排/重绘重排1.png)\n![重绘重排2](/重绘&&重排/重绘重排2.png)\n![重绘重排3](/重绘&&重排/重绘重排3.png)\n![重绘重排4](/重绘&&重排/重绘重排4.png)\n\n\n参考：\n[segment](https://segmentfault.com/a/1190000016990089)\n","slug":"重绘&&重排","published":1,"updated":"2020-07-21T04:20:36.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmrk8002iz5o8bsyg2es4","content":"<p><img src=\"/2020/07/20/%E9%87%8D%E7%BB%98&&%E9%87%8D%E6%8E%92/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%921.png\" alt=\"重绘重排1\"><br><img src=\"/2020/07/20/%E9%87%8D%E7%BB%98&&%E9%87%8D%E6%8E%92/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%922.png\" alt=\"重绘重排2\"><br><img src=\"/2020/07/20/%E9%87%8D%E7%BB%98&&%E9%87%8D%E6%8E%92/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%923.png\" alt=\"重绘重排3\"><br><img src=\"/2020/07/20/%E9%87%8D%E7%BB%98&&%E9%87%8D%E6%8E%92/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%924.png\" alt=\"重绘重排4\"></p>\n<p>参考：<br><a href=\"https://segmentfault.com/a/1190000016990089\" target=\"_blank\" rel=\"noopener\">segment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/2020/07/20/%E9%87%8D%E7%BB%98&&%E9%87%8D%E6%8E%92/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%921.png\" alt=\"重绘重排1\"><br><img src=\"/2020/07/20/%E9%87%8D%E7%BB%98&&%E9%87%8D%E6%8E%92/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%922.png\" alt=\"重绘重排2\"><br><img src=\"/2020/07/20/%E9%87%8D%E7%BB%98&&%E9%87%8D%E6%8E%92/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%923.png\" alt=\"重绘重排3\"><br><img src=\"/2020/07/20/%E9%87%8D%E7%BB%98&&%E9%87%8D%E6%8E%92/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%924.png\" alt=\"重绘重排4\"></p>\n<p>参考：<br><a href=\"https://segmentfault.com/a/1190000016990089\" target=\"_blank\" rel=\"noopener\">segment</a></p>\n"},{"title":"听到请回答1988","date":"2019-04-06T14:28:36.000Z","_content":"\n啊   感动啊感动 \n![合照](https://pic2.zhimg.com/v2-73eb983ad340c514bd4c33f08032000f_r.jpg)\n很温暖，很简单，很友好的情感\n\n我现在听着1988的网易云歌单，写下这篇日志，希望看到的人也和我一样喜欢这部片子呢\n\n一部小小的电视机里，放着的是我们的润发哥和国荣哥的《英雄本色》，哇好有品位呀，我们故事里的主人公们坐在电视机前，善宇，娃娃鱼，正焕，德善，阿泽。\n\n哈哈，豹纹女士大喊一声:\"正焕啊，回家吃饭啦！\"，接着他们都回家吃饭，留下我们呆萌的阿泽，阿泽爸爸也进来房间，微笑着说，阿泽，我们也吃饭吧😊\n\n故事DuangDuangDuang开始咯~~~\n\n","source":"_posts/请回答1988.md","raw":"---\ntitle: 听到请回答1988\ndate: 2019-04-06 22:28:36\ntags: 随笔\n---\n\n啊   感动啊感动 \n![合照](https://pic2.zhimg.com/v2-73eb983ad340c514bd4c33f08032000f_r.jpg)\n很温暖，很简单，很友好的情感\n\n我现在听着1988的网易云歌单，写下这篇日志，希望看到的人也和我一样喜欢这部片子呢\n\n一部小小的电视机里，放着的是我们的润发哥和国荣哥的《英雄本色》，哇好有品位呀，我们故事里的主人公们坐在电视机前，善宇，娃娃鱼，正焕，德善，阿泽。\n\n哈哈，豹纹女士大喊一声:\"正焕啊，回家吃饭啦！\"，接着他们都回家吃饭，留下我们呆萌的阿泽，阿泽爸爸也进来房间，微笑着说，阿泽，我们也吃饭吧😊\n\n故事DuangDuangDuang开始咯~~~\n\n","slug":"请回答1988","published":1,"updated":"2020-04-10T12:20:25.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmrka002kz5o8hgfo5djr","content":"<p>啊   感动啊感动<br><img src=\"https://pic2.zhimg.com/v2-73eb983ad340c514bd4c33f08032000f_r.jpg\" alt=\"合照\"><br>很温暖，很简单，很友好的情感</p>\n<p>我现在听着1988的网易云歌单，写下这篇日志，希望看到的人也和我一样喜欢这部片子呢</p>\n<p>一部小小的电视机里，放着的是我们的润发哥和国荣哥的《英雄本色》，哇好有品位呀，我们故事里的主人公们坐在电视机前，善宇，娃娃鱼，正焕，德善，阿泽。</p>\n<p>哈哈，豹纹女士大喊一声:”正焕啊，回家吃饭啦！”，接着他们都回家吃饭，留下我们呆萌的阿泽，阿泽爸爸也进来房间，微笑着说，阿泽，我们也吃饭吧😊</p>\n<p>故事DuangDuangDuang开始咯<del>~</del></p>\n","site":{"data":{}},"excerpt":"","more":"<p>啊   感动啊感动<br><img src=\"https://pic2.zhimg.com/v2-73eb983ad340c514bd4c33f08032000f_r.jpg\" alt=\"合照\"><br>很温暖，很简单，很友好的情感</p>\n<p>我现在听着1988的网易云歌单，写下这篇日志，希望看到的人也和我一样喜欢这部片子呢</p>\n<p>一部小小的电视机里，放着的是我们的润发哥和国荣哥的《英雄本色》，哇好有品位呀，我们故事里的主人公们坐在电视机前，善宇，娃娃鱼，正焕，德善，阿泽。</p>\n<p>哈哈，豹纹女士大喊一声:”正焕啊，回家吃饭啦！”，接着他们都回家吃饭，留下我们呆萌的阿泽，阿泽爸爸也进来房间，微笑着说，阿泽，我们也吃饭吧😊</p>\n<p>故事DuangDuangDuang开始咯<del>~</del></p>\n"},{"title":"面试","date":"2020-04-12T09:19:35.000Z","_content":"\n知己知彼，百战百胜\n实力推荐\n[木易杨](https://muyiy.cn/)\n\n\n参考链接：\n\n[阿里p7要求](https://zhuanlan.zhihu.com/p/69705235)\n[阿里P6+要求](https://github.com/jawil/blog/issues/22)\n[掘金1](https://juejin.im/post/5e5522b36fb9a07ce152c51c)\n[掘金2](https://juejin.im/post/587dab348d6d810058d87a0a)\n[axuebin issue](https://github.com/axuebin/articles/issues/39)\n[前端内参github](https://github.com/coffe1891/frontend-hard-mode-interview)\n\n","source":"_posts/面试要求.md","raw":"---\ntitle: 面试\ndate: 2020-04-12 17:19:35\ntags: 面试\n---\n\n知己知彼，百战百胜\n实力推荐\n[木易杨](https://muyiy.cn/)\n\n\n参考链接：\n\n[阿里p7要求](https://zhuanlan.zhihu.com/p/69705235)\n[阿里P6+要求](https://github.com/jawil/blog/issues/22)\n[掘金1](https://juejin.im/post/5e5522b36fb9a07ce152c51c)\n[掘金2](https://juejin.im/post/587dab348d6d810058d87a0a)\n[axuebin issue](https://github.com/axuebin/articles/issues/39)\n[前端内参github](https://github.com/coffe1891/frontend-hard-mode-interview)\n\n","slug":"面试要求","published":1,"updated":"2020-07-14T17:06:19.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmrkb002mz5o8g5s63xf9","content":"<p>知己知彼，百战百胜<br>实力推荐<br><a href=\"https://muyiy.cn/\" target=\"_blank\" rel=\"noopener\">木易杨</a></p>\n<p>参考链接：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/69705235\" target=\"_blank\" rel=\"noopener\">阿里p7要求</a><br><a href=\"https://github.com/jawil/blog/issues/22\" target=\"_blank\" rel=\"noopener\">阿里P6+要求</a><br><a href=\"https://juejin.im/post/5e5522b36fb9a07ce152c51c\" target=\"_blank\" rel=\"noopener\">掘金1</a><br><a href=\"https://juejin.im/post/587dab348d6d810058d87a0a\" target=\"_blank\" rel=\"noopener\">掘金2</a><br><a href=\"https://github.com/axuebin/articles/issues/39\" target=\"_blank\" rel=\"noopener\">axuebin issue</a><br><a href=\"https://github.com/coffe1891/frontend-hard-mode-interview\" target=\"_blank\" rel=\"noopener\">前端内参github</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>知己知彼，百战百胜<br>实力推荐<br><a href=\"https://muyiy.cn/\" target=\"_blank\" rel=\"noopener\">木易杨</a></p>\n<p>参考链接：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/69705235\" target=\"_blank\" rel=\"noopener\">阿里p7要求</a><br><a href=\"https://github.com/jawil/blog/issues/22\" target=\"_blank\" rel=\"noopener\">阿里P6+要求</a><br><a href=\"https://juejin.im/post/5e5522b36fb9a07ce152c51c\" target=\"_blank\" rel=\"noopener\">掘金1</a><br><a href=\"https://juejin.im/post/587dab348d6d810058d87a0a\" target=\"_blank\" rel=\"noopener\">掘金2</a><br><a href=\"https://github.com/axuebin/articles/issues/39\" target=\"_blank\" rel=\"noopener\">axuebin issue</a><br><a href=\"https://github.com/coffe1891/frontend-hard-mode-interview\" target=\"_blank\" rel=\"noopener\">前端内参github</a></p>\n"},{"title":"防抖与节流","date":"2019-12-03T02:44:39.000Z","_content":"### 1.防抖\n✨ 业务场景：你尽管触发事件，但是我一定在事件触发 n 秒后才执行。\n如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，\n总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行.\n简单的说法是，取决于上次没操作后，delay时间后执行。\n\n👍适用场景：input的格式验证、提交按钮的点击事件（触发频不那么高）\n\n介绍三个版本：\n\n#### 1指定this\n```javascript\n    function debounce(func, wait) {\n        var timeout;\n        return function() {\n            clearTimeout(timeout)\n            timeout = setTimeout(func,wait)  // 保持只是一个定时器\n        }\n    }\n```\n \n#### 2 this指向 && 指定传参（比如`event`）\n```javascript\n    function debounce(func, wait) {\n        var timeout;\n        // console.log(this) // 这里的时候指向window\n        return function() {\n            var context = this // 这里的时候指向btn 关键是缓存这时候的this\n            var args = arguments\n            clearTimeout(timeout)\n            timeout = setTimeout(function() {\n                //没绑定context时，这里this指向window\n                func.apply(context,args)\n            }, wait)\n        }\n    }\n```\n\n#### 3 this指向 && 指定传参 && 立即执行\n```javascript\nfunction debounce(func, wait, immediate) {\n        var timeout;\n        return function() {\n            var context = this\n            var args = arguments\n            if (timeout) { clearTimeout(timeout) }\n            if (immediate) { // 立即执行\n                // timeout有值的情况下，改为延时\n                var callNow = !timeout\n                timeout = setTimeout(function () {\n                    timeout = null\n                },wait)\n                if (callNow) { func.apply(context,args) }\n                // 跑完立即执行，永远都会执行上面的timeout = null，\n                // 然后下一次进入判断callNow时，又会是立即执行。 \n            } else {\n                timeout = setTimeout(function () {\n                    func.apply(context,args)\n                },wait)\n            }\n        }\n    }\n```\n\n### 2.节流\n按指定的delay执行\n 👍 适用场景：（触发频高）resize, touchmove, mousemove, scroll 动画场景\n\n下面介绍两个版本：\n  \n #### ✨ 使用时间戳\n  使用时间戳，当触发事件的时候，我们取出当前的时间戳，\n  然后减去之前的时间戳(最一开始值设为 0 )，\n  如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，\n  如果小于，就不执行。\n \n<div class=\"tip\">\n    第一下会立刻执行\n</div>\n```javascript\n    // +new Date() 将会调用 Date.prototype 上的 valueOf() 方法，\n    // Date.prototype.value方法等同于Date.prototype.getTime()\n    function throttle(func, wait) {\n        var previous = 0\n        return function() {\n            var now = +new Date() \n            const args = arguments\n            const context = this\n            if ((now - previous) > wait) {\n                func.apply(context,args)\n                previous = now\n            }\n        }\n    }\n```\n\n#### ✨ 使用定时器\n当触发事件的时候，我们设置一个定时器，\n再触发事件的时候，如果定时器存在，就不执行，\n直到定时器执行，然后执行函数，\n清空定时器，\n这样就可以设置下个定时器。\n<div class=\"tip\">\n    第一下会延时执行\n</div>\n```javascript\n    function throttle(func, wait) {\n            var timeout;\n            return function () {\n                const context = this\n                const args = arguments\n                if (!timeout) {\n                    timeout = setTimeout(function () {\n                        timeout = null\n                        func.apply(context, args)\n                    }, wait)\n                }\n            }\n        }\n```\n\n\n\n### 3.两者的关联与区别\n两者都有控制触发的次数，防抖控制的更厉害，节流是降低频率\n假设无限次触发：防抖函数永远不会真正执行，节流函数则会按照间隔时间执行。\n\n参考链接：\n[专栏](https://zhuanlan.zhihu.com/p/38313717)\n[mqyqingfeng  issue](https://github.com/mqyqingfeng/Blog/issues/26)\n","source":"_posts/防抖与节流.md","raw":"---\ntitle: 防抖与节流\ndate: 2019-12-03 10:44:39\ntags: JS优化\n---\n### 1.防抖\n✨ 业务场景：你尽管触发事件，但是我一定在事件触发 n 秒后才执行。\n如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，\n总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行.\n简单的说法是，取决于上次没操作后，delay时间后执行。\n\n👍适用场景：input的格式验证、提交按钮的点击事件（触发频不那么高）\n\n介绍三个版本：\n\n#### 1指定this\n```javascript\n    function debounce(func, wait) {\n        var timeout;\n        return function() {\n            clearTimeout(timeout)\n            timeout = setTimeout(func,wait)  // 保持只是一个定时器\n        }\n    }\n```\n \n#### 2 this指向 && 指定传参（比如`event`）\n```javascript\n    function debounce(func, wait) {\n        var timeout;\n        // console.log(this) // 这里的时候指向window\n        return function() {\n            var context = this // 这里的时候指向btn 关键是缓存这时候的this\n            var args = arguments\n            clearTimeout(timeout)\n            timeout = setTimeout(function() {\n                //没绑定context时，这里this指向window\n                func.apply(context,args)\n            }, wait)\n        }\n    }\n```\n\n#### 3 this指向 && 指定传参 && 立即执行\n```javascript\nfunction debounce(func, wait, immediate) {\n        var timeout;\n        return function() {\n            var context = this\n            var args = arguments\n            if (timeout) { clearTimeout(timeout) }\n            if (immediate) { // 立即执行\n                // timeout有值的情况下，改为延时\n                var callNow = !timeout\n                timeout = setTimeout(function () {\n                    timeout = null\n                },wait)\n                if (callNow) { func.apply(context,args) }\n                // 跑完立即执行，永远都会执行上面的timeout = null，\n                // 然后下一次进入判断callNow时，又会是立即执行。 \n            } else {\n                timeout = setTimeout(function () {\n                    func.apply(context,args)\n                },wait)\n            }\n        }\n    }\n```\n\n### 2.节流\n按指定的delay执行\n 👍 适用场景：（触发频高）resize, touchmove, mousemove, scroll 动画场景\n\n下面介绍两个版本：\n  \n #### ✨ 使用时间戳\n  使用时间戳，当触发事件的时候，我们取出当前的时间戳，\n  然后减去之前的时间戳(最一开始值设为 0 )，\n  如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，\n  如果小于，就不执行。\n \n<div class=\"tip\">\n    第一下会立刻执行\n</div>\n```javascript\n    // +new Date() 将会调用 Date.prototype 上的 valueOf() 方法，\n    // Date.prototype.value方法等同于Date.prototype.getTime()\n    function throttle(func, wait) {\n        var previous = 0\n        return function() {\n            var now = +new Date() \n            const args = arguments\n            const context = this\n            if ((now - previous) > wait) {\n                func.apply(context,args)\n                previous = now\n            }\n        }\n    }\n```\n\n#### ✨ 使用定时器\n当触发事件的时候，我们设置一个定时器，\n再触发事件的时候，如果定时器存在，就不执行，\n直到定时器执行，然后执行函数，\n清空定时器，\n这样就可以设置下个定时器。\n<div class=\"tip\">\n    第一下会延时执行\n</div>\n```javascript\n    function throttle(func, wait) {\n            var timeout;\n            return function () {\n                const context = this\n                const args = arguments\n                if (!timeout) {\n                    timeout = setTimeout(function () {\n                        timeout = null\n                        func.apply(context, args)\n                    }, wait)\n                }\n            }\n        }\n```\n\n\n\n### 3.两者的关联与区别\n两者都有控制触发的次数，防抖控制的更厉害，节流是降低频率\n假设无限次触发：防抖函数永远不会真正执行，节流函数则会按照间隔时间执行。\n\n参考链接：\n[专栏](https://zhuanlan.zhihu.com/p/38313717)\n[mqyqingfeng  issue](https://github.com/mqyqingfeng/Blog/issues/26)\n","slug":"防抖与节流","published":1,"updated":"2020-07-12T09:36:26.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd2nmrki002oz5o89tlbeuux","content":"<h3 id=\"1-防抖\"><a href=\"#1-防抖\" class=\"headerlink\" title=\"1.防抖\"></a>1.防抖</h3><p>✨ 业务场景：你尽管触发事件，但是我一定在事件触发 n 秒后才执行。<br>如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，<br>总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行.<br>简单的说法是，取决于上次没操作后，delay时间后执行。</p>\n<p>👍适用场景：input的格式验证、提交按钮的点击事件（触发频不那么高）</p>\n<p>介绍三个版本：</p>\n<h4 id=\"1指定this\"><a href=\"#1指定this\" class=\"headerlink\" title=\"1指定this\"></a>1指定this</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        clearTimeout(timeout)</span><br><span class=\"line\">        timeout = setTimeout(func,wait)  <span class=\"comment\">// 保持只是一个定时器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-this指向-amp-amp-指定传参（比如event）\"><a href=\"#2-this指向-amp-amp-指定传参（比如event）\" class=\"headerlink\" title=\"2 this指向 &amp;&amp; 指定传参（比如event）\"></a>2 this指向 &amp;&amp; 指定传参（比如<code>event</code>）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout;</span><br><span class=\"line\">    <span class=\"comment\">// console.log(this) // 这里的时候指向window</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span> <span class=\"comment\">// 这里的时候指向btn 关键是缓存这时候的this</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span></span><br><span class=\"line\">        clearTimeout(timeout)</span><br><span class=\"line\">        timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//没绑定context时，这里this指向window</span></span><br><span class=\"line\">            func.apply(context,args)</span><br><span class=\"line\">        &#125;, wait)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-this指向-amp-amp-指定传参-amp-amp-立即执行\"><a href=\"#3-this指向-amp-amp-指定传参-amp-amp-立即执行\" class=\"headerlink\" title=\"3 this指向 &amp;&amp; 指定传参 &amp;&amp; 立即执行\"></a>3 this指向 &amp;&amp; 指定传参 &amp;&amp; 立即执行</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> timeout;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timeout) &#123; clearTimeout(timeout) &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (immediate) &#123; <span class=\"comment\">// 立即执行</span></span><br><span class=\"line\">                <span class=\"comment\">// timeout有值的情况下，改为延时</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> callNow = !timeout</span><br><span class=\"line\">                timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    timeout = <span class=\"literal\">null</span></span><br><span class=\"line\">                &#125;,wait)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (callNow) &#123; func.apply(context,args) &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 跑完立即执行，永远都会执行上面的timeout = null，</span></span><br><span class=\"line\">                <span class=\"comment\">// 然后下一次进入判断callNow时，又会是立即执行。 </span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    func.apply(context,args)</span><br><span class=\"line\">                &#125;,wait)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-节流\"><a href=\"#2-节流\" class=\"headerlink\" title=\"2.节流\"></a>2.节流</h3><p>按指定的delay执行<br> 👍 适用场景：（触发频高）resize, touchmove, mousemove, scroll 动画场景</p>\n<p>下面介绍两个版本：</p>\n<h4 id=\"✨-使用时间戳\"><a href=\"#✨-使用时间戳\" class=\"headerlink\" title=\"✨ 使用时间戳\"></a>✨ 使用时间戳</h4><p>  使用时间戳，当触发事件的时候，我们取出当前的时间戳，<br>  然后减去之前的时间戳(最一开始值设为 0 )，<br>  如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，<br>  如果小于，就不执行。</p>\n<div class=\"tip\">\n    第一下会立刻执行\n</div>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// +new Date() 将会调用 Date.prototype 上的 valueOf() 方法，</span></span><br><span class=\"line\"><span class=\"comment\">// Date.prototype.value方法等同于Date.prototype.getTime()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, wait</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() </span><br><span class=\"line\">        <span class=\"keyword\">const</span> args = <span class=\"built_in\">arguments</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> context = <span class=\"keyword\">this</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((now - previous) &gt; wait) &#123;</span><br><span class=\"line\">            func.apply(context,args)</span><br><span class=\"line\">            previous = now</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"✨-使用定时器\"><a href=\"#✨-使用定时器\" class=\"headerlink\" title=\"✨ 使用定时器\"></a>✨ 使用定时器</h4><p>当触发事件的时候，我们设置一个定时器，<br>再触发事件的时候，如果定时器存在，就不执行，<br>直到定时器执行，然后执行函数，<br>清空定时器，<br>这样就可以设置下个定时器。</p>\n<div class=\"tip\">\n    第一下会延时执行\n</div>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, wait</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> timeout;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> context = <span class=\"keyword\">this</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> args = <span class=\"built_in\">arguments</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!timeout) &#123;</span><br><span class=\"line\">                timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    timeout = <span class=\"literal\">null</span></span><br><span class=\"line\">                    func.apply(context, args)</span><br><span class=\"line\">                &#125;, wait)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-两者的关联与区别\"><a href=\"#3-两者的关联与区别\" class=\"headerlink\" title=\"3.两者的关联与区别\"></a>3.两者的关联与区别</h3><p>两者都有控制触发的次数，防抖控制的更厉害，节流是降低频率<br>假设无限次触发：防抖函数永远不会真正执行，节流函数则会按照间隔时间执行。</p>\n<p>参考链接：<br><a href=\"https://zhuanlan.zhihu.com/p/38313717\" target=\"_blank\" rel=\"noopener\">专栏</a><br><a href=\"https://github.com/mqyqingfeng/Blog/issues/26\" target=\"_blank\" rel=\"noopener\">mqyqingfeng  issue</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-防抖\"><a href=\"#1-防抖\" class=\"headerlink\" title=\"1.防抖\"></a>1.防抖</h3><p>✨ 业务场景：你尽管触发事件，但是我一定在事件触发 n 秒后才执行。<br>如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，<br>总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行.<br>简单的说法是，取决于上次没操作后，delay时间后执行。</p>\n<p>👍适用场景：input的格式验证、提交按钮的点击事件（触发频不那么高）</p>\n<p>介绍三个版本：</p>\n<h4 id=\"1指定this\"><a href=\"#1指定this\" class=\"headerlink\" title=\"1指定this\"></a>1指定this</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        clearTimeout(timeout)</span><br><span class=\"line\">        timeout = setTimeout(func,wait)  <span class=\"comment\">// 保持只是一个定时器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-this指向-amp-amp-指定传参（比如event）\"><a href=\"#2-this指向-amp-amp-指定传参（比如event）\" class=\"headerlink\" title=\"2 this指向 &amp;&amp; 指定传参（比如event）\"></a>2 this指向 &amp;&amp; 指定传参（比如<code>event</code>）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout;</span><br><span class=\"line\">    <span class=\"comment\">// console.log(this) // 这里的时候指向window</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span> <span class=\"comment\">// 这里的时候指向btn 关键是缓存这时候的this</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span></span><br><span class=\"line\">        clearTimeout(timeout)</span><br><span class=\"line\">        timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//没绑定context时，这里this指向window</span></span><br><span class=\"line\">            func.apply(context,args)</span><br><span class=\"line\">        &#125;, wait)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-this指向-amp-amp-指定传参-amp-amp-立即执行\"><a href=\"#3-this指向-amp-amp-指定传参-amp-amp-立即执行\" class=\"headerlink\" title=\"3 this指向 &amp;&amp; 指定传参 &amp;&amp; 立即执行\"></a>3 this指向 &amp;&amp; 指定传参 &amp;&amp; 立即执行</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> timeout;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timeout) &#123; clearTimeout(timeout) &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (immediate) &#123; <span class=\"comment\">// 立即执行</span></span><br><span class=\"line\">                <span class=\"comment\">// timeout有值的情况下，改为延时</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> callNow = !timeout</span><br><span class=\"line\">                timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    timeout = <span class=\"literal\">null</span></span><br><span class=\"line\">                &#125;,wait)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (callNow) &#123; func.apply(context,args) &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 跑完立即执行，永远都会执行上面的timeout = null，</span></span><br><span class=\"line\">                <span class=\"comment\">// 然后下一次进入判断callNow时，又会是立即执行。 </span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    func.apply(context,args)</span><br><span class=\"line\">                &#125;,wait)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-节流\"><a href=\"#2-节流\" class=\"headerlink\" title=\"2.节流\"></a>2.节流</h3><p>按指定的delay执行<br> 👍 适用场景：（触发频高）resize, touchmove, mousemove, scroll 动画场景</p>\n<p>下面介绍两个版本：</p>\n<h4 id=\"✨-使用时间戳\"><a href=\"#✨-使用时间戳\" class=\"headerlink\" title=\"✨ 使用时间戳\"></a>✨ 使用时间戳</h4><p>  使用时间戳，当触发事件的时候，我们取出当前的时间戳，<br>  然后减去之前的时间戳(最一开始值设为 0 )，<br>  如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，<br>  如果小于，就不执行。</p>\n<div class=\"tip\">\n    第一下会立刻执行\n</div>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// +new Date() 将会调用 Date.prototype 上的 valueOf() 方法，</span></span><br><span class=\"line\"><span class=\"comment\">// Date.prototype.value方法等同于Date.prototype.getTime()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, wait</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() </span><br><span class=\"line\">        <span class=\"keyword\">const</span> args = <span class=\"built_in\">arguments</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> context = <span class=\"keyword\">this</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((now - previous) &gt; wait) &#123;</span><br><span class=\"line\">            func.apply(context,args)</span><br><span class=\"line\">            previous = now</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"✨-使用定时器\"><a href=\"#✨-使用定时器\" class=\"headerlink\" title=\"✨ 使用定时器\"></a>✨ 使用定时器</h4><p>当触发事件的时候，我们设置一个定时器，<br>再触发事件的时候，如果定时器存在，就不执行，<br>直到定时器执行，然后执行函数，<br>清空定时器，<br>这样就可以设置下个定时器。</p>\n<div class=\"tip\">\n    第一下会延时执行\n</div>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, wait</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> timeout;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> context = <span class=\"keyword\">this</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> args = <span class=\"built_in\">arguments</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!timeout) &#123;</span><br><span class=\"line\">                timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    timeout = <span class=\"literal\">null</span></span><br><span class=\"line\">                    func.apply(context, args)</span><br><span class=\"line\">                &#125;, wait)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-两者的关联与区别\"><a href=\"#3-两者的关联与区别\" class=\"headerlink\" title=\"3.两者的关联与区别\"></a>3.两者的关联与区别</h3><p>两者都有控制触发的次数，防抖控制的更厉害，节流是降低频率<br>假设无限次触发：防抖函数永远不会真正执行，节流函数则会按照间隔时间执行。</p>\n<p>参考链接：<br><a href=\"https://zhuanlan.zhihu.com/p/38313717\" target=\"_blank\" rel=\"noopener\">专栏</a><br><a href=\"https://github.com/mqyqingfeng/Blog/issues/26\" target=\"_blank\" rel=\"noopener\">mqyqingfeng  issue</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/MVVM/MVVM5.png","slug":"MVVM5.png","post":"ckd2nmr9m0009z5o885m74lx4","modified":0,"renderable":0},{"_id":"source/_posts/MVVM/MVVM1.png","slug":"MVVM1.png","post":"ckd2nmr9m0009z5o885m74lx4","modified":0,"renderable":0},{"_id":"source/_posts/MVVM/MVVM2.png","slug":"MVVM2.png","post":"ckd2nmr9m0009z5o885m74lx4","modified":0,"renderable":0},{"_id":"source/_posts/MVVM/MVVM3.png","slug":"MVVM3.png","post":"ckd2nmr9m0009z5o885m74lx4","modified":0,"renderable":0},{"_id":"source/_posts/MVVM/MVVM4.png","slug":"MVVM4.png","post":"ckd2nmr9m0009z5o885m74lx4","modified":0,"renderable":0},{"_id":"source/_posts/重绘&&重排/重绘重排1.png","slug":"重绘重排1.png","post":"ckd2nmrk8002iz5o8bsyg2es4","modified":0,"renderable":0},{"_id":"source/_posts/重绘&&重排/重绘重排2.png","slug":"重绘重排2.png","post":"ckd2nmrk8002iz5o8bsyg2es4","modified":0,"renderable":0},{"_id":"source/_posts/重绘&&重排/重绘重排3.png","slug":"重绘重排3.png","post":"ckd2nmrk8002iz5o8bsyg2es4","modified":0,"renderable":0},{"_id":"source/_posts/重绘&&重排/重绘重排4.png","slug":"重绘重排4.png","post":"ckd2nmrk8002iz5o8bsyg2es4","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"ckd2nmr9b0001z5o89tgc2hhe","tag_id":"ckd2nmr9e0003z5o80rmea5fc","_id":"ckd2nmr9m0008z5o88zfpdll5"},{"post_id":"ckd2nmr9d0002z5o82gq72en7","tag_id":"ckd2nmr9l0007z5o8a8ubdt71","_id":"ckd2nmr9q000dz5o82u1n4t9q"},{"post_id":"ckd2nmr9g0004z5o85cwhcu0g","tag_id":"ckd2nmr9o000bz5o83tvy3q7q","_id":"ckd2nmr9s000hz5o829v81kcw"},{"post_id":"ckd2nmr9j0005z5o8ezx701yf","tag_id":"ckd2nmr9r000fz5o8ax2d3imc","_id":"ckd2nmr9v000lz5o88ampajbm"},{"post_id":"ckd2nmr9k0006z5o8a9q37yvz","tag_id":"ckd2nmr9t000jz5o80g300oil","_id":"ckd2nmr9x000pz5o860r854ol"},{"post_id":"ckd2nmr9m0009z5o885m74lx4","tag_id":"ckd2nmr9x000oz5o8d6whc2ra","_id":"ckd2nmra0000uz5o8d1tp4cvt"},{"post_id":"ckd2nmr9n000az5o8hzgn5m5j","tag_id":"ckd2nmr9z000sz5o8885ma5fb","_id":"ckd2nmra2000yz5o88saacedw"},{"post_id":"ckd2nmr9p000cz5o80xz0cav5","tag_id":"ckd2nmra1000wz5o8ht8vbc9u","_id":"ckd2nmra50012z5o8aucohzl1"},{"post_id":"ckd2nmr9q000ez5o8av371vwt","tag_id":"ckd2nmra30010z5o8745dgd2l","_id":"ckd2nmra90016z5o815uggzrl"},{"post_id":"ckd2nmr9r000gz5o8cqenfck9","tag_id":"ckd2nmra90015z5o80mm384qx","_id":"ckd2nmrac001bz5o8gl828e9h"},{"post_id":"ckd2nmraa0018z5o84zqs8tpv","tag_id":"ckd2nmra1000wz5o8ht8vbc9u","_id":"ckd2nmrad001dz5o887gs8qk0"},{"post_id":"ckd2nmr9s000iz5o86piu1qw0","tag_id":"ckd2nmrab0019z5o89at01loo","_id":"ckd2nmraf001gz5o88etn8gk6"},{"post_id":"ckd2nmr9u000kz5o89vqkck1g","tag_id":"ckd2nmrad001ez5o86agi557v","_id":"ckd2nmraf001iz5o8408mbwgm"},{"post_id":"ckd2nmr9v000mz5o83fx436le","tag_id":"ckd2nmraf001hz5o8dzrw54ai","_id":"ckd2nmrag001kz5o85dycb10t"},{"post_id":"ckd2nmr9w000nz5o8238o6h9g","tag_id":"ckd2nmraf001jz5o8625c9d1o","_id":"ckd2nmrag001mz5o8ghn0hfwv"},{"post_id":"ckd2nmr9y000rz5o81fqxfoca","tag_id":"ckd2nmrag001lz5o872aw4m2z","_id":"ckd2nmrah001oz5o816f3evm4"},{"post_id":"ckd2nmr9z000tz5o8cgxc1unj","tag_id":"ckd2nmrag001nz5o82c6kdmum","_id":"ckd2nmrah001qz5o8fd057112"},{"post_id":"ckd2nmra0000vz5o87h727ops","tag_id":"ckd2nmrah001pz5o8fx2qb1zc","_id":"ckd2nmrai001sz5o8ad3135ph"},{"post_id":"ckd2nmra1000xz5o82zgdeywj","tag_id":"ckd2nmrai001rz5o80swi7oeb","_id":"ckd2nmraj001uz5o86bbuenwl"},{"post_id":"ckd2nmra2000zz5o8fy8t6npt","tag_id":"ckd2nmrag001nz5o82c6kdmum","_id":"ckd2nmrak001wz5o8188i54c5"},{"post_id":"ckd2nmra30011z5o87xvb4des","tag_id":"ckd2nmrag001nz5o82c6kdmum","_id":"ckd2nmrak001yz5o8gtg8cgsl"},{"post_id":"ckd2nmra50013z5o8hnjlejtx","tag_id":"ckd2nmrag001nz5o82c6kdmum","_id":"ckd2nmral0020z5o88p168ivz"},{"post_id":"ckd2nmra60014z5o8fufvcbeh","tag_id":"ckd2nmrah001pz5o8fx2qb1zc","_id":"ckd2nmral0022z5o8dmnigcib"},{"post_id":"ckd2nmra90017z5o8g9bi7adj","tag_id":"ckd2nmral0021z5o89z63gvin","_id":"ckd2nmram0024z5o803xl37e1"},{"post_id":"ckd2nmrab001az5o80w0mcfrx","tag_id":"ckd2nmram0023z5o89mst7ljd","_id":"ckd2nmram0026z5o88z6u8kyw"},{"post_id":"ckd2nmrac001cz5o8fduka8qr","tag_id":"ckd2nmrag001nz5o82c6kdmum","_id":"ckd2nmran0028z5o86wvcc6sn"},{"post_id":"ckd2nmrae001fz5o83h8x87jl","tag_id":"ckd2nmrag001nz5o82c6kdmum","_id":"ckd2nmran0029z5o8avq5c5nt"},{"post_id":"ckd2nmrk2002az5o864xpfwho","tag_id":"ckd2nmrk5002cz5o8br64e6e1","_id":"ckd2nmrk8002hz5o86pyeb6rn"},{"post_id":"ckd2nmrk7002fz5o88b5p59lr","tag_id":"ckd2nmr9z000sz5o8885ma5fb","_id":"ckd2nmrk9002jz5o81wjkb5cr"},{"post_id":"ckd2nmrk3002bz5o84ppmg29n","tag_id":"ckd2nmrk8002gz5o8d19mg6q1","_id":"ckd2nmrki002nz5o8ayzdbujx"},{"post_id":"ckd2nmrkb002mz5o8g5s63xf9","tag_id":"ckd2nmr9l0007z5o8a8ubdt71","_id":"ckd2nmrkj002qz5o8cv9z0art"},{"post_id":"ckd2nmrk5002dz5o855p93jxr","tag_id":"ckd2nmrk8002gz5o8d19mg6q1","_id":"ckd2nmrkk002rz5o87csch2x6"},{"post_id":"ckd2nmrk6002ez5o8dvlq5e9l","tag_id":"ckd2nmrkj002pz5o86aojh9ts","_id":"ckd2nmrkl002tz5o89w2y9td6"},{"post_id":"ckd2nmrk8002iz5o8bsyg2es4","tag_id":"ckd2nmrkk002sz5o89ra4bmmu","_id":"ckd2nmrks002vz5o8cy6pdzn9"},{"post_id":"ckd2nmrka002kz5o8hgfo5djr","tag_id":"ckd2nmrkr002uz5o80adz5884","_id":"ckd2nmrkt002xz5o8dkod8scu"},{"post_id":"ckd2nmrki002oz5o89tlbeuux","tag_id":"ckd2nmrkt002wz5o801zghw0e","_id":"ckd2nmrkt002yz5o86cnw66zl"}],"Tag":[{"name":"ES JS","_id":"ckd2nmr9e0003z5o80rmea5fc"},{"name":"面试","_id":"ckd2nmr9l0007z5o8a8ubdt71"},{"name":"JS原理","_id":"ckd2nmr9o000bz5o83tvy3q7q"},{"name":"H5","_id":"ckd2nmr9r000fz5o8ax2d3imc"},{"name":"Apollo Hexo Valine","_id":"ckd2nmr9t000jz5o80g300oil"},{"name":"MVVM 框架","_id":"ckd2nmr9x000oz5o8d6whc2ra"},{"name":"面试 JS","_id":"ckd2nmr9z000sz5o8885ma5fb"},{"name":"Array","_id":"ckd2nmra1000wz5o8ht8vbc9u"},{"name":"nginx","_id":"ckd2nmra30010z5o8745dgd2l"},{"name":"模块化","_id":"ckd2nmra90015z5o80mm384qx"},{"name":"工具","_id":"ckd2nmrab0019z5o89at01loo"},{"name":"sql","_id":"ckd2nmrad001ez5o86agi557v"},{"name":"ES6","_id":"ckd2nmraf001hz5o8dzrw54ai"},{"name":"vue","_id":"ckd2nmraf001jz5o8625c9d1o"},{"name":"upload","_id":"ckd2nmrag001lz5o872aw4m2z"},{"name":"JS","_id":"ckd2nmrag001nz5o82c6kdmum"},{"name":"JS 拷贝","_id":"ckd2nmrah001pz5o8fx2qb1zc"},{"name":"工具 webpack","_id":"ckd2nmrai001rz5o80swi7oeb"},{"name":"小程序","_id":"ckd2nmral0021z5o89z63gvin"},{"name":"浏览器","_id":"ckd2nmram0023z5o89mst7ljd"},{"name":"Promise 工具","_id":"ckd2nmrk5002cz5o8br64e6e1"},{"name":"移动端","_id":"ckd2nmrk8002gz5o8d19mg6q1"},{"name":"算法","_id":"ckd2nmrkj002pz5o86aojh9ts"},{"name":"浏览器 CSS渲染","_id":"ckd2nmrkk002sz5o89ra4bmmu"},{"name":"随笔","_id":"ckd2nmrkr002uz5o80adz5884"},{"name":"JS优化","_id":"ckd2nmrkt002wz5o801zghw0e"}]}}