<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>防抖与节流 · Jonnzer的博客</title><meta name="description" content="防抖与节流 - Jonnzer"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/gandalfr.css"><link rel="search" type="application/opensearchdescription+xml" href="https://jonnzer.github.io/atom.xml" title="Jonnzer的博客"><script src="/js/Valine.min.js"></script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Jonnzer的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/jonnzer/" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">防抖与节流</h1><div class="tags"><a href="/tags/JS%E4%BC%98%E5%8C%96/" class="tag-title">#JS优化</a></div><div class="post-info">Dec 3, 2019</div><div class="post-content"><h3 id="1-防抖"><a href="#1-防抖" class="headerlink" title="1.防抖"></a>1.防抖</h3><p>✨ 业务场景：你尽管触发事件，但是我一定在事件触发 n 秒后才执行。<br>如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，<br>总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行.<br>简单的说法是，取决于上次没操作后，delay时间后执行。</p>
<p>👍适用场景：input的格式验证、提交按钮的点击事件（触发频不那么高）</p>
<p>介绍三个版本：</p>
<h4 id="1指定this"><a href="#1指定this" class="headerlink" title="1指定this"></a>1指定this</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout = setTimeout(func,wait)  <span class="comment">// 保持只是一个定时器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-this指向-amp-amp-指定传参（比如event）"><a href="#2-this指向-amp-amp-指定传参（比如event）" class="headerlink" title="2 this指向 &amp;&amp; 指定传参（比如event）"></a>2 this指向 &amp;&amp; 指定传参（比如<code>event</code>）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="comment">// console.log(this) // 这里的时候指向window</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span> <span class="comment">// 这里的时候指向btn 关键是缓存这时候的this</span></span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//没绑定context时，这里this指向window</span></span><br><span class="line">            func.apply(context,args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-this指向-amp-amp-指定传参-amp-amp-立即执行"><a href="#3-this指向-amp-amp-指定传参-amp-amp-立即执行" class="headerlink" title="3 this指向 &amp;&amp; 指定传参 &amp;&amp; 立即执行"></a>3 this指向 &amp;&amp; 指定传参 &amp;&amp; 立即执行</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> timeout;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> context = <span class="keyword">this</span></span><br><span class="line">            <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123; clearTimeout(timeout) &#125;</span><br><span class="line">            <span class="keyword">if</span> (immediate) &#123; <span class="comment">// 立即执行</span></span><br><span class="line">                <span class="comment">// timeout有值的情况下，改为延时</span></span><br><span class="line">                <span class="keyword">var</span> callNow = !timeout</span><br><span class="line">                timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    timeout = <span class="literal">null</span></span><br><span class="line">                &#125;,wait)</span><br><span class="line">                <span class="keyword">if</span> (callNow) &#123; func.apply(context,args) &#125;</span><br><span class="line">                <span class="comment">// 跑完立即执行，永远都会执行上面的timeout = null，</span></span><br><span class="line">                <span class="comment">// 然后下一次进入判断callNow时，又会是立即执行。 </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    func.apply(context,args)</span><br><span class="line">                &#125;,wait)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-节流"><a href="#2-节流" class="headerlink" title="2.节流"></a>2.节流</h3><p>按指定的delay执行<br> 👍 适用场景：（触发频高）resize, touchmove, mousemove, scroll 动画场景</p>
<p>下面介绍两个版本：</p>
<h4 id="✨-使用时间戳"><a href="#✨-使用时间戳" class="headerlink" title="✨ 使用时间戳"></a>✨ 使用时间戳</h4><p>  使用时间戳，当触发事件的时候，我们取出当前的时间戳，<br>  然后减去之前的时间戳(最一开始值设为 0 )，<br>  如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，<br>  如果小于，就不执行。</p>
<div class="tip">
    第一下会立刻执行
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +new Date() 将会调用 Date.prototype 上的 valueOf() 方法，</span></span><br><span class="line"><span class="comment">// Date.prototype.value方法等同于Date.prototype.getTime()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>() </span><br><span class="line">        <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">const</span> context = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">if</span> ((now - previous) &gt; wait) &#123;</span><br><span class="line">            func.apply(context,args)</span><br><span class="line">            previous = now</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="✨-使用定时器"><a href="#✨-使用定时器" class="headerlink" title="✨ 使用定时器"></a>✨ 使用定时器</h4><p>当触发事件的时候，我们设置一个定时器，<br>再触发事件的时候，如果定时器存在，就不执行，<br>直到定时器执行，然后执行函数，<br>清空定时器，<br>这样就可以设置下个定时器。</p>
<div class="tip">
    第一下会延时执行
</div>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> timeout;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> context = <span class="keyword">this</span></span><br><span class="line">            <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">            <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">                timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    timeout = <span class="literal">null</span></span><br><span class="line">                    func.apply(context, args)</span><br><span class="line">                &#125;, wait)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-两者的关联与区别"><a href="#3-两者的关联与区别" class="headerlink" title="3.两者的关联与区别"></a>3.两者的关联与区别</h3><p>两者都有控制触发的次数，防抖控制的更厉害，节流是降低频率<br>假设无限次触发：防抖函数永远不会真正执行，节流函数则会按照间隔时间执行。</p>
<p>参考链接：<br><a href="https://zhuanlan.zhihu.com/p/38313717" target="_blank" rel="noopener">专栏</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/26" target="_blank" rel="noopener">mqyqingfeng  issue</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/12/03/JS%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/" class="prev">PREV</a><a href="/2019/08/05/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8%E7%AF%87/" class="next">NEXT</a></div><div id="vcomments"></div><!--script(src="//unpkg.com/valine/dist/Valine.min.js")--><script>new Valine({ // 里面的参数配置具体参考Valine官网
    el: '#vcomments',
    appId: `Hv8Cfy93FCgDUy3fP2Av9Ies-gzGzoHsz`,
    appKey: `4fAniISvXobBOUUx5SEE89dV`,
    placeholder: '快来评论吧(#^.^#)',
    avatar: 'wavatar'
});</script><div class="copyright"><p>© 2017 - 2020 <a href="https://jonnzer.github.io">Jonnzer</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/MikeCoder/hexo-theme-gandalfr" target="_blank">hexo-theme-gandalfr</a>.</p></div></footer></div><script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script src="/js/jquery.js"></script></body></html>