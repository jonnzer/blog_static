<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jonnzer的博客</title>
  
  <subtitle>温润如玉</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jonnzer.github.io/"/>
  <updated>2020-07-28T15:14:22.795Z</updated>
  <id>https://jonnzer.github.io/</id>
  
  <author>
    <name>Jonnzer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>合并对象</title>
    <link href="https://jonnzer.github.io/2020/07/27/%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1/"/>
    <id>https://jonnzer.github.io/2020/07/27/%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-07-27T08:20:19.000Z</published>
    <updated>2020-07-28T15:14:22.795Z</updated>
    
    <content type="html"><![CDATA[<p>1 <code>Object.assign</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>:[<span class="number">1</span>], <span class="attr">b</span>:[<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>]&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">a</span>:[<span class="number">1</span>,<span class="number">2</span>], <span class="attr">c</span>:<span class="number">5</span> , <span class="attr">d</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(obj1,obj2))</span><br></pre></td></tr></table></figure><ol start="2"><li>…运算符</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>:[<span class="number">1</span>], <span class="attr">b</span>:[<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>]&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">a</span>:[<span class="number">1</span>,<span class="number">2</span>], <span class="attr">c</span>:<span class="number">5</span> , <span class="attr">d</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(&#123;...obj1, ...obj2&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1 &lt;code&gt;Object.assign&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
    
    
      <category term="对象 JS" scheme="https://jonnzer.github.io/tags/%E5%AF%B9%E8%B1%A1-JS/"/>
    
  </entry>
  
  <entry>
    <title>判断对象是否是个空对象</title>
    <link href="https://jonnzer.github.io/2020/07/27/%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/"/>
    <id>https://jonnzer.github.io/2020/07/27/%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/</id>
    <published>2020-07-27T06:28:00.000Z</published>
    <updated>2020-07-27T08:19:50.976Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-遍历，根据是否有值"><a href="#1-遍历，根据是否有值" class="headerlink" title="1. 遍历，根据是否有值"></a>1. 遍历，根据是否有值</h4><p><code>for...in...</code></p><h4 id="2-整个对象转换为数组"><a href="#2-整个对象转换为数组" class="headerlink" title="2. 整个对象转换为数组"></a>2. 整个对象转换为数组</h4><p><code>Object.entries</code></p><h4 id="3-转为JSON字符串"><a href="#3-转为JSON字符串" class="headerlink" title="3. 转为JSON字符串"></a>3. 转为JSON字符串</h4><p><code>JSON.stringify()</code></p><h4 id="4-获取对象的属性名并以数组形式返回"><a href="#4-获取对象的属性名并以数组形式返回" class="headerlink" title="4. 获取对象的属性名并以数组形式返回"></a>4. 获取对象的属性名并以数组形式返回</h4><p><code>Object.getOwnPropertyNames()</code> / <code>Object.keys()</code></p><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for...in...</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> isEmpty = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">   isEmpty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isEmpty)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key的遍历 ： Object.getOwnPropertyNames</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key的遍历： Object.keys 获取key的数组</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> isEmpty = <span class="built_in">Object</span>.keys(obj).length === <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象转化为数组的遍历： Object.entries</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> isEmpty;</span><br><span class="line">isEmpty = (<span class="built_in">Object</span>.entries(obj).length === <span class="number">0</span>) &amp;&amp; (<span class="keyword">typeof</span> obj === <span class="string">'object'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(isEmpty)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON字符串</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> isEmpty;</span><br><span class="line">isEmpty = <span class="built_in">JSON</span>.stringify(obj) === <span class="string">'&#123;&#125;'</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmpty)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-遍历，根据是否有值&quot;&gt;&lt;a href=&quot;#1-遍历，根据是否有值&quot; class=&quot;headerlink&quot; title=&quot;1. 遍历，根据是否有值&quot;&gt;&lt;/a&gt;1. 遍历，根据是否有值&lt;/h4&gt;&lt;p&gt;&lt;code&gt;for...in...&lt;/code&gt;&lt;/p&gt;
&lt;h4
      
    
    </summary>
    
    
    
      <category term="面试 JS 对象" scheme="https://jonnzer.github.io/tags/%E9%9D%A2%E8%AF%95-JS-%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>MVVM实现（Object.defineProperty &amp;&amp; 观察订阅）</title>
    <link href="https://jonnzer.github.io/2020/07/23/MVVM/"/>
    <id>https://jonnzer.github.io/2020/07/23/MVVM/</id>
    <published>2020-07-23T13:01:50.000Z</published>
    <updated>2020-07-25T11:31:21.547Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-MVVM特点图解"><a href="#1-MVVM特点图解" class="headerlink" title="1. MVVM特点图解"></a>1. MVVM特点图解</h3><p><img src="/2020/07/23/MVVM/MVVM1.png" alt="MVVM注解图1"><br><img src="/2020/07/23/MVVM/MVVM2.png" alt="MVVM注解图2"><br><img src="/2020/07/23/MVVM/MVVM3.png" alt="MVVM注解图3"><br><img src="/2020/07/23/MVVM/MVVM4.png" alt="MVVM注解图4"><br><img src="/2020/07/23/MVVM/MVVM5.png" alt="MVVM注解图5"></p><h3 id="2-MVVM的功能："><a href="#2-MVVM的功能：" class="headerlink" title="2. MVVM的功能："></a>2. MVVM的功能：</h3><ul><li>给所有data属性值都设置数据劫持，绑定好属性观察。（<em>也是深度响应原理</em>）</li><li>结合观察订阅者模式</li></ul><h3 id="3-代码实现：-MVVM包含双向数据绑定、v-model、computed"><a href="#3-代码实现：-MVVM包含双向数据绑定、v-model、computed" class="headerlink" title="3.代码实现：(MVVM包含双向数据绑定、v-model、computed)"></a>3.代码实现：(<code>MVVM</code>包含双向数据绑定、<code>v-model</code>、<code>computed</code>)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * let zs = new Vue(&#123;</span></span><br><span class="line"><span class="comment"> *     el: '#app',</span></span><br><span class="line"><span class="comment"> *     data: &#123;a: 1&#125;</span></span><br><span class="line"><span class="comment"> * &#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>options 参考vue实例化时传进的对象,代表我们存储的所有对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demoVue</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$options = options;  <span class="comment">// 当前实例，存储存进的对象</span></span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">this</span>._data = <span class="keyword">this</span>.$options.data;  <span class="comment">// 当前实例，存储options.data 准备像vue一样观察数据</span></span><br><span class="line">    observe(data);</span><br><span class="line">    <span class="comment">// 为了代理_data属性。可以直接在实例的时候取到data，再用define一次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,key,&#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>._data[key]; <span class="comment">// 将this._data.key 通过定义对象的方式 赋给了 this.key，模拟vue</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">                <span class="keyword">this</span>._data[key] = newVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> computed = <span class="keyword">this</span>.$options.computed;</span><br><span class="line">    operatedComputed.call(<span class="keyword">this</span>)  <span class="comment">// computedde 的操作需放在数据都已被观察完，并挂载到_data里</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">new</span> Compile(options.el, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">operatedComputed</span>(<span class="params"></span>) </span>&#123; <span class="comment">// computed 处理函数</span></span><br><span class="line">    <span class="keyword">let</span> vm = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> computedFn = <span class="keyword">this</span>.$options.computed</span><br><span class="line">    <span class="built_in">Object</span>.keys(computedFn).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// computed挂载到vm上</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(vm,key,&#123;</span><br><span class="line">            <span class="keyword">get</span>: typeof computedFn[key] === 'function' ?  computedFn[key] : computedFn[key].<span class="keyword">get</span>,</span><br><span class="line">            <span class="keyword">set</span>() &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123; <span class="comment">// 数据劫持，增加Object.defineProperty</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> data !== <span class="string">'object'</span>) <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Observe(data); <span class="comment">// 方便递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把数据编译到dom上，实现数据绑定</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>el 替换的dom</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>vm 实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> * note:</span></span><br><span class="line"><span class="comment"> * (1) 文档碎片</span></span><br><span class="line"><span class="comment"> * (2) regExp.$n: --[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n]</span></span><br><span class="line"><span class="comment"> * (3)正则图形化 https://regexper.com/</span></span><br><span class="line"><span class="comment"> * (4)正则对照表：http://tool.oschina.net/uploads/apidocs/jquery/regexp.html</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">el, vm</span>) </span>&#123;</span><br><span class="line">    vm.$el = <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">    <span class="keyword">let</span> fragment = <span class="built_in">document</span>.createDocumentFragment(); <span class="comment">// 之所以用了文档碎片，是因为这样造成页面渲染回流的代价最低</span></span><br><span class="line">    <span class="keyword">let</span> child;</span><br><span class="line">    <span class="comment">// 此处用到了appendChild的一个特性：对于被添加的子节点，如果之前已经存在，则会销毁自己在dom树的节点，然后把自己添加到新的地方</span></span><br><span class="line">    <span class="comment">// 因此vm.$el.firstChild才会不停地切换成下一个子节点。</span></span><br><span class="line">    <span class="comment">// --[https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (child = vm.$el.firstChild) &#123;</span><br><span class="line">        fragment.appendChild(child);</span><br><span class="line">    &#125;</span><br><span class="line">    replace(fragment);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Array.from 将伪数组对象转为数组实例</span></span><br><span class="line"><span class="comment">      textContext: 节点内容</span></span><br><span class="line"><span class="comment">      节点类型 --[https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType] nodeType为3时，是element或者属性中的字</span></span><br><span class="line"><span class="comment">      之所以抽离出方法，是因为想要重复调用，当子节点里还有子节点时，可以调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">fragment</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">Array</span>.from(fragment.childNodes).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> text = node.textContent;</span><br><span class="line">            <span class="keyword">let</span> exp;</span><br><span class="line">            <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.nodeType === <span class="number">3</span> &amp;&amp; reg.test(text)) &#123;</span><br><span class="line">               exp = text.replace(reg, <span class="string">'$1'</span>); <span class="comment">// 正则匹配中第一个括号所代表的内容</span></span><br><span class="line">                <span class="keyword">let</span> pointArr = exp.split(<span class="string">'.'</span>); <span class="comment">// a.a b</span></span><br><span class="line">                <span class="keyword">let</span> existVal = vm;</span><br><span class="line">                pointArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123; <span class="comment">// vm.a.a  vm.b</span></span><br><span class="line">                    existVal = existVal[key];</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 添加一个watcher事件 监听了值的变化</span></span><br><span class="line">                <span class="keyword">new</span> Watcher(vm,exp,<span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">                    node.textContent = text.replace(reg, newVal);</span><br><span class="line">                &#125;);</span><br><span class="line">                 <span class="comment">// @todo此处parser有待完善，只能兼容纯&#123;&#123;&#125;&#125;，带上其他字符会让existVal失效</span></span><br><span class="line">                node.textContent = text.replace(reg, existVal);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.nodeType === <span class="number">1</span> ) &#123; <span class="comment">// v-model实现</span></span><br><span class="line">                <span class="keyword">let</span> attr = <span class="built_in">Array</span>.from(node.attributes)</span><br><span class="line">                <span class="keyword">let</span> attr_value;</span><br><span class="line">                attr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (item.name === <span class="string">'v-model'</span>) &#123;</span><br><span class="line">                        attr_value = item.value</span><br><span class="line">                        <span class="keyword">new</span> Watcher(vm,attr_value, <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">                            node.value = newVal</span><br><span class="line">                        &#125;)</span><br><span class="line">                        node.addEventListener(<span class="string">'input'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">                            vm[attr_value] = e.target.value</span><br><span class="line">                        &#125;)  </span><br><span class="line">                    &#125;</span><br><span class="line">                   </span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.childNodes) &#123;</span><br><span class="line">                replace(node);</span><br><span class="line">            &#125;</span><br><span class="line">            vm.$el.appendChild(fragment); <span class="comment">// 文档碎片的内容重新添加到原来挂载的元素里</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="variable">data</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observe</span>(<span class="params">data</span>) </span>&#123; <span class="comment">// 实际观察方法,设置 Object.defineProperty</span></span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">        <span class="keyword">let</span> val = data[key];</span><br><span class="line">        observe(val); <span class="comment">// 这里就已经可以递归了</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(data,key, &#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                <span class="comment">// 此时Dep.target是this</span></span><br><span class="line">                <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">                    dep.addSub(Dep.target); <span class="comment">// 添加事件订阅（watcher 的 push）</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> val;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">                <span class="keyword">if</span> (newVal ===  val) &#123; <span class="comment">// 值没发生变化</span></span><br><span class="line">                    <span class="keyword">return</span>; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    val = newVal; <span class="comment">// 更新值。get获取值时，也可以得到最新的值。</span></span><br><span class="line">                    observe(newVal); <span class="comment">// 这里是为了给新值也添上观察者</span></span><br><span class="line">                    dep.notify(); <span class="comment">// 添加事件的通知更新（watcher的update）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发布订阅函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Dep</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = []; <span class="comment">// 事件池</span></span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype.addSub = <span class="function"><span class="keyword">function</span> (<span class="params">sub</span>) </span>&#123; <span class="comment">// 订阅</span></span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">&#125;;</span><br><span class="line">Dep.prototype.notify = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 通知</span></span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">        sub.update();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件池其中的一个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>vm: 实例环境（总的数据来源）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>正则表达式的遍历对象exp (要更改的对象)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn（处理的回调函数）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm,exp,fn</span>) </span>&#123; <span class="comment">// fn是回调函数 new的时候传进来</span></span><br><span class="line">    <span class="keyword">this</span>.vm = vm;</span><br><span class="line">    <span class="keyword">this</span>.exp = exp;</span><br><span class="line">    <span class="keyword">this</span>.fn = fn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到订阅中</span></span><br><span class="line">    <span class="comment">// Dep.target ??? 扮演着一个watcher对象，也是Watcher的实例  它和 Object.defineProperty的get会有反应</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> val = vm;</span><br><span class="line">    <span class="keyword">let</span> arr = exp.split(<span class="string">'.'</span>);</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">k</span>) </span>&#123; <span class="comment">// 这里获取 this.a.a时还是会触发到默认的getter</span></span><br><span class="line">        val = val[k];</span><br><span class="line">    &#125;);</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// watcher的更新方法</span></span><br><span class="line">    <span class="keyword">let</span> val = <span class="keyword">this</span>.vm;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">this</span>.exp.split(<span class="string">'.'</span>);</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">k</span>) </span>&#123;</span><br><span class="line">        val = val[k];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.fn(val); <span class="comment">// 把最新值传进callback</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;a.a&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;b&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"b"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;cacultate_c&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;script src="../dist/my_bundle.js"&gt;&lt;/script&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./compile.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 调用</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> little = <span class="keyword">new</span> demoVue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">"#app"</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="actionscript">            a: &#123;a:<span class="string">"是a"</span>&#125;,</span></span><br><span class="line"><span class="actionscript">            b: <span class="string">"是b"</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line"><span class="actionscript">            cacultate_c: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="keyword">this</span>.a.a + <span class="keyword">this</span>.b;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            cacultate_d: &#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">get</span>() &#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> <span class="keyword">this</span>.a.a + <span class="keyword">this</span>.b + <span class="keyword">this</span>.b</span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="javascript">                <span class="keyword">set</span>(val) &#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">this</span>.a = val</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h3><p>1、 <code>Object.defineProperty</code> 给对象设置某属性，并且可以设置setter，用于绑定属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'school'</span>,&#123;</span><br><span class="line">    configurable: <span class="literal">true</span>, <span class="comment">// 让 delete 更新属性值 生效</span></span><br><span class="line">    enumberable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>()&#123; <span class="comment">// 取值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(val)&#123; <span class="comment">// 设置值时触发</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setting '</span>)</span><br><span class="line">        obj.school = val <span class="comment">// 超出内存 mag size</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure><hr><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://juejin.im/post/5e7410ed51882549087dc365#heading-0" target="_blank" rel="noopener">掘金 - MVVM</a><br><a href="https://blog.csdn.net/hf872914334/article/details/88899326" target="_blank" rel="noopener">发布订阅模式 &amp;&amp; 观察者模式</a><br><a href="https://zhuanlan.zhihu.com/p/51357583" target="_blank" rel="noopener">发布订阅模式 &amp;&amp; 观察者模式</a><br><a href="https://segmentfault.com/a/1190000019700618" target="_blank" rel="noopener">Vue2.0响应原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-MVVM特点图解&quot;&gt;&lt;a href=&quot;#1-MVVM特点图解&quot; class=&quot;headerlink&quot; title=&quot;1. MVVM特点图解&quot;&gt;&lt;/a&gt;1. MVVM特点图解&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2020/07/23/MVVM/MVVM1.png
      
    
    </summary>
    
    
    
      <category term="MVVM 框架" scheme="https://jonnzer.github.io/tags/MVVM-%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>浏览器-重排&amp;&amp;重绘</title>
    <link href="https://jonnzer.github.io/2020/07/20/%E9%87%8D%E7%BB%98&amp;&amp;%E9%87%8D%E6%8E%92/"/>
    <id>https://jonnzer.github.io/2020/07/20/%E9%87%8D%E7%BB%98&amp;&amp;%E9%87%8D%E6%8E%92/</id>
    <published>2020-07-20T10:00:00.000Z</published>
    <updated>2020-07-21T04:20:36.440Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/07/20/%E9%87%8D%E7%BB%98&&%E9%87%8D%E6%8E%92/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%921.png" alt="重绘重排1"><br><img src="/2020/07/20/%E9%87%8D%E7%BB%98&&%E9%87%8D%E6%8E%92/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%922.png" alt="重绘重排2"><br><img src="/2020/07/20/%E9%87%8D%E7%BB%98&&%E9%87%8D%E6%8E%92/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%923.png" alt="重绘重排3"><br><img src="/2020/07/20/%E9%87%8D%E7%BB%98&&%E9%87%8D%E6%8E%92/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%924.png" alt="重绘重排4"></p><p>参考：<br><a href="https://segmentfault.com/a/1190000016990089" target="_blank" rel="noopener">segment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2020/07/20/%E9%87%8D%E7%BB%98&amp;&amp;%E9%87%8D%E6%8E%92/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%921.png&quot; alt=&quot;重绘重排1&quot;&gt;&lt;br&gt;&lt;img src=&quot;/2020/0
      
    
    </summary>
    
    
    
      <category term="浏览器 CSS渲染" scheme="https://jonnzer.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8-CSS%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>ES2019新变化</title>
    <link href="https://jonnzer.github.io/2020/07/20/ES2019%E6%96%B0%E5%B1%9E%E6%80%A7/"/>
    <id>https://jonnzer.github.io/2020/07/20/ES2019%E6%96%B0%E5%B1%9E%E6%80%A7/</id>
    <published>2020-07-20T09:37:05.000Z</published>
    <updated>2020-07-20T09:36:40.268Z</updated>
    
    <content type="html"><![CDATA[<p>1 数组：<br>数组降维：Array.prototype.flat() 递归地将嵌套数组拼合到指定深度 创建新数组，不改原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">arr1.flat(); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line">arr2.flat(<span class="number">2</span>); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]]]];</span><br><span class="line">arr3.flat(<span class="literal">Infinity</span>); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><p>flat还会移除数组空项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr4 = [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr4.flat(); <span class="comment">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure><p>2 字符串<br>去头去尾： String.prototype.trimStart() 和 String.prototype.trimEnd() 创建新字符串，不修改原字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="string">" hello "</span>;</span><br><span class="line"></span><br><span class="line">test.trim(); <span class="comment">// "hello";</span></span><br><span class="line">test.trimStart(); <span class="comment">// "hello ";</span></span><br><span class="line">test.trimEnd(); <span class="comment">// " hello";</span></span><br></pre></td></tr></table></figure><p>3 对象<br>Object.fromEntries() 数组转对象<br>与之相对应的是Object.entries() 对象转数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">prop1</span>: <span class="number">2</span>, <span class="attr">prop2</span>: <span class="number">10</span>, <span class="attr">prop3</span>: <span class="number">15</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化为键值对数组：</span></span><br><span class="line"><span class="keyword">let</span> array = <span class="built_in">Object</span>.entries(obj); </span><br><span class="line"><span class="comment">// [["prop1", 2], ["prop2", 10], ["prop3", 15]]</span></span><br><span class="line"></span><br><span class="line">array = array.map(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> [key, <span class="built_in">Math</span>.pow(value, <span class="number">2</span>)]); </span><br><span class="line"><span class="comment">// [["prop1", 4], ["prop2", 100], ["prop3", 225]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj = <span class="built_in">Object</span>.fromEntries(array); </span><br><span class="line"><span class="comment">// &#123;prop1: 4, prop2: 100, prop3: 225&#125;</span></span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://github.com/sisterAn/blog/issues/47" target="_blank" rel="noopener">瓶子君的blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1 数组：&lt;br&gt;数组降维：Array.prototype.flat() 递归地将嵌套数组拼合到指定深度 创建新数组，不改原数组&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
    
    
      <category term="ES JS" scheme="https://jonnzer.github.io/tags/ES-JS/"/>
    
  </entry>
  
  <entry>
    <title>浏览器异步（三）</title>
    <link href="https://jonnzer.github.io/2020/07/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%82%E6%AD%A5%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8BPromise%E5%AE%9E%E7%8E%B0/"/>
    <id>https://jonnzer.github.io/2020/07/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%82%E6%AD%A5%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8BPromise%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-07-17T16:54:40.000Z</published>
    <updated>2020-07-20T12:26:27.638Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此篇博文转载自瓶子君的blog <a href="https://github.com/sisterAn/blog/issues/13" target="_blank" rel="noopener">链接</a>，并加以自己的理解和注释。</p></blockquote><h3 id="Promise本质"><a href="#Promise本质" class="headerlink" title="Promise本质"></a>Promise本质</h3><p><strong>Promise就是为了解决callback的问题而产生的。</strong></p><p>Promise 本质上就是一个绑定了回调的对象，而不是将回调传回函数内部。</p><p><strong>开门见山，Promise解决的是回调函数处理异步的第2个问题：控制反转</strong>。</p><p>我们把上面那个多层回调嵌套的例子用Promise的方式重构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getPromise1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promsie(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">'XXX1'</span>,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">               <span class="keyword">let</span> key = data;</span><br><span class="line">               resolve(key);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getPromise2 = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promsie(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">'XXX2'</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">                key: key</span><br><span class="line">            &#125;,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getPromise3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promsie(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">'XXX3'</span>,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                resolve(data);         </span><br><span class="line">            &#125;,</span><br><span class="line">            error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getPromise1()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPromise2(key);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPromise3(data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'业务数据：'</span>, data);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>Promise 在一定程度上其实改善了回调函数的书写方式；另外逻辑性更明显了，将异步业务提取成单个函数，整个流程可以看到是一步步向下执行的，依赖层级也很清晰，最后需要的数据是在整个代码的最后一步获得。</p><p>所以，Promise在一定程度上解决了回调函数的书写结构问题，但回调函数依然在主流程上存在，只不过都放到了then(…)里面，和我们大脑顺序线性的思维逻辑还是有出入的。</p><h3 id="Promise-是什么"><a href="#Promise-是什么" class="headerlink" title="Promise 是什么"></a>Promise 是什么</h3><p>Promise是什么，无论是ES6的Promise也好，jQuery的Promise也好，不同的库有不同的实现，但是大家遵循的都是同一套规范，所以，Promise并不指特定的某个实现，<strong>它是一种规范，是一套处理JavaScript异步的机制</strong>。</p><p>Promise的规范会多，如Promise/A、Promise/B、Promise/D以及Promise/A的升级版Promise/A+，其中ES6遵循Promise/A+规范，有关Promise/A+，你可以参考一下：</p><ul><li>英文版：<a href="https://promisesaplus.com" target="_blank" rel="noopener">Promise/A+</a></li><li>翻译版：<a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">【翻译】Promises/A+规范</a></li></ul><p>这里只简要介绍下几点与接下来内容相关的规范：</p><ul><li>Promise 本质是一个状态机，每个 Promise 有三种状态：pending、resolved以及rejected。状态转变只能是pending —resolved 或者 pending —rejected。状态转变不可逆。</li><li>then 方法可以被同一个 promise 调用多次。</li><li>then 方法必须返回一个 promise。规范2.2.7中规定， then 必须返回一个新的 Promise</li><li>值穿透</li></ul><h3 id="Promise-实现及源码解读"><a href="#Promise-实现及源码解读" class="headerlink" title="Promise 实现及源码解读"></a>Promise 实现及源码解读</h3><p>首先，我们看一下Promise的简单使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do an async task async task and then...</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/* good condition */</span>) &#123;</span><br><span class="line">        resolve(<span class="string">'Success!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="string">'Failure!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="comment">/* do something with the result */</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* error :( */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们通过这种使用构建Promise实现的第一个版本</p><p><strong>自己的写法也是结合调用实例的逆推过程</strong>。</p><p>为什么要将callback单独传入呢？因为啊，new Promise(… ) 这括号里的函数逻辑是由我们编写的，可调整可修改，在任何条件下的resolve和reject，所以封装的时候最好写成一个通用的回调函数。</p><h4 id="Promise构建版本一"><a href="#Promise构建版本一" class="headerlink" title="Promise构建版本一"></a>Promise构建版本一</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="keyword">var</span> onResolvedCallback  <span class="comment">// Promise resolve回调函数</span></span><br><span class="line">    <span class="keyword">var</span> onRejectedCallback  <span class="comment">// Promise reject回调函数</span></span><br><span class="line">    <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        onResolvedCallback()</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// reject 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        onRejectedCallback()</span><br><span class="line">    &#125; </span><br><span class="line">    callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 then 方法 因为是promise的实例需要用到，所以then最好挂载在promise的原型上</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>大致框架已经出来了，但我们看到Promise状态、reslove函数、reject函数以及then等都没有处理。</p><h4 id="Promise构建之二：链式存储"><a href="#Promise构建之二：链式存储" class="headerlink" title="Promise构建之二：链式存储"></a>Promise构建之二：链式存储</h4><p>链式存储：讲的就是promise实例会有很多次then，然后下一次的then都会获得上一次的then的结果，就像链式一般。将结果存储下去，直至return。</p><p>首先，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line">        resolve(a);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> b=<span class="number">2</span>;</span><br><span class="line">            resolve(b);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> c=<span class="number">3</span></span><br><span class="line">            resolve(c);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上例结果是每间隔1s打印一个数字，顺序为1、2、3。</p><p>这里保证了：</p><ul><li>让a,b,c的值能在then里面的回调接收到</li><li>在连续调用异步，如何确保异步函数的执行顺序</li></ul><p>Promise一个常见的需求就是连续执行两个或者多个异步操作，这种情况下，每一个后来的操作都在前面的操作执行成功之后，带着上一步操作所返回的结果开始执行。这里用<code>setTimeout</code>来处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="comment">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class="line">    <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.onResolvedCallbacks = [] <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">    _this.onRejectedCallbacks = [] <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 异步执行</span></span><br><span class="line">            _this.onResolvedCallbacks.forEach(cb =cb())</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 异步执行</span></span><br><span class="line">            _this.onRejectedCallbacks.forEach(cb =cb())</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// reject 处理函数</span></span><br><span class="line">    callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise构建之三：状态机制、顺序执行"><a href="#Promise构建之三：状态机制、顺序执行" class="headerlink" title="Promise构建之三：状态机制、顺序执行"></a>Promise构建之三：状态机制、顺序执行</h4><p>为了保证Promise的异步操作时的顺序执行，这里给Promise加上状态机制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">"resolved"</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">    _this.currentState = PENDING <span class="comment">// Promise当前的状态</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="comment">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class="line">    <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.onResolvedCallbacks = [] <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">    _this.onRejectedCallbacks = [] <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">                _this.currentState = RESOLVED <span class="comment">// 状态管理</span></span><br><span class="line">                _this.value = value</span><br><span class="line">                _this.onResolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">            _this.currentState = REJECTED <span class="comment">// 状态管理</span></span><br><span class="line">            _this.value = value</span><br><span class="line">            _this.onRejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// reject 处理函数</span></span><br><span class="line">    callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise构建之四：递归执行"><a href="#Promise构建之四：递归执行" class="headerlink" title="Promise构建之四：递归执行"></a>Promise构建之四：递归执行</h4><p>每个Promise后面链接一个对象，该对象包含onresolved,onrejected,子promise三个属性.</p><p>当父Promise 状态改变完毕,执行完相应的onresolved/onrejected的时候，拿到子promise,在等待这个子promise状态改变，在执行相应的onresolved/onrejected。依次循环直到当前promise没有子promise。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">"resolved"</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">    _this.currentState = PENDING <span class="comment">// Promise当前的状态</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="comment">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class="line">    <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.onResolvedCallbacks = [] <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">    _this.onRejectedCallbacks = [] <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="comment">// 如果 value 是个 MyPromise， 递归执行</span></span><br><span class="line">            <span class="keyword">return</span> value.then(_this.resolve, _this.reject)</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">                _this.currentState = RESOLVED <span class="comment">// 状态管理</span></span><br><span class="line">                _this.value = value</span><br><span class="line">                _this.onResolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">            _this.currentState = REJECTED <span class="comment">// 状态管理</span></span><br><span class="line">            _this.value = value</span><br><span class="line">            _this.onRejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// reject 处理函数</span></span><br><span class="line">    callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise构建之五：异常处理"><a href="#Promise构建之五：异常处理" class="headerlink" title="Promise构建之五：异常处理"></a>Promise构建之五：异常处理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">"resolved"</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">    _this.currentState = PENDING <span class="comment">// Promise当前的状态</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="comment">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class="line">    <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.onResolvedCallbacks = [] <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">    _this.onRejectedCallbacks = [] <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="comment">// 如果 value 是个 MyPromise， 递归执行</span></span><br><span class="line">            <span class="keyword">return</span> value.then(_this.resolve, _this.reject)</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">                _this.currentState = RESOLVED <span class="comment">// 状态管理</span></span><br><span class="line">                _this.value = value</span><br><span class="line">                _this.onResolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">            _this.currentState = REJECTED <span class="comment">// 状态管理</span></span><br><span class="line">            _this.value = value</span><br><span class="line">            _this.onRejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb())</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// reject 处理函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="comment">// new Promise(() =throw Error('error'))</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        _this.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 then 方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise构建之六：then的实现"><a href="#Promise构建之六：then的实现" class="headerlink" title="Promise构建之六：then的实现"></a>Promise构建之六：then的实现</h4><p>then 方法是 Promise 的核心，这里做一下详细介绍。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure><p>一个 Promise 的then接受两个参数： onFulfilled和onRejected（都是可选参数，并且为函数，若不是函数将被忽略）</p><ul><li><p>onFulfilled 特性：</p><ul><li>当 Promise 执行结束后其必须被调用，其第一个参数为 promise 的终值，也就是 resolve 传过来的值</li><li>在 Promise 执行结束前不可被调用</li><li>其调用次数不可超过一次</li></ul></li><li><p>onRejected 特性</p><ul><li>当 Promise 被拒绝执行后其必须被调用，第一个参数为 Promise 的拒绝原因，也就是reject传过来的值</li><li>在 Promise 执行结束前不可被调用</li><li>其调用次数不可超过一次</li></ul></li><li><p>调用时机<br><code>onFulfilled</code> 和 <code>onRejected</code> 只有在<a href="http://es5.github.io/#x10.3" target="_blank" rel="noopener">执行环境</a>堆栈仅包含<strong>平台代码</strong>时才可被调用（平台代码指引擎、环境以及 promise 的实施代码）</p></li><li><p>调用要求<br><code>onFulfilled</code> 和 <code>onRejected</code> 必须被作为函数调用（即没有 <code>this</code> 值，在 <strong>严格模式（strict）</strong> 中，函数 <code>this</code> 的值为 <code>undefined</code> ；在非严格模式中其为全局对象。）</p></li><li><p>多次调用<br><code>then</code> 方法可以被同一个 <code>promise</code> 调用多次</p><ul><li>当 <code>promise</code> 成功执行时，所有 <code>onFulfilled</code> 需按照其注册顺序依次回调</li><li>当 <code>promise</code> 被拒绝执行时，所有的 <code>onRejected</code> 需按照其注册顺序依次回调</li></ul></li><li><p>返回<br><code>then</code>方法会返回一个<code>Promise</code>，关于这一点，Promise/A+标准并没有要求返回的这个Promise是一个新的对象，但在Promise/A标准中，明确规定了then要返回一个新的对象，目前的Promise实现中then几乎都是返回一个新的Promise(<a href="https://promisesaplus.com/differences-from-promises-a#point-5" target="_blank" rel="noopener">详情</a>)对象，所以在我们的实现中，也让then返回一个新的Promise对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise2 &#x3D; promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 <code>x</code> ，则运行下面的 <strong>Promise 解决过程</strong>：<code>[[Resolve]](promise2, x)</code></p></li><li><p>如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 抛出一个异常 <code>e</code> ，则 <code>promise2</code> 必须拒绝执行，并返回拒因 <code>e</code></p></li><li><p>如果 <code>onFulfilled</code> 不是函数且 <code>promise1</code> 成功执行， <code>promise2</code> 必须成功执行并返回相同的值</p></li><li><p>如果 <code>onRejected</code> 不是函数且 <code>promise1</code> 拒绝执行， <code>promise2</code> 必须拒绝执行并返回相同的拒因</p></li><li><p><em>不论 promise1 被 reject 还是被 resolve ， promise2 都会被 resolve，只有出现异常时才会被 rejected*</em>。<br>每个Promise对象都可以在其上多次调用then方法，而每次调用then返回的Promise的状态取决于那一次调用then时传入参数的返回值，所以then不能返回this，因为then每次返回的Promise的结果都有可能不同。</p></li></ul><p>下面代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class="line">    <span class="keyword">var</span> promise2</span><br><span class="line">    <span class="comment">// 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数</span></span><br><span class="line">    <span class="comment">// onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : value =value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : error =&#123;<span class="keyword">throw</span> error&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === RESOLVED) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === REJECTED) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>附：值穿透解读</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : value =value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : error =&#123;<span class="keyword">throw</span> error&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到值穿透，值穿透即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> MyPromise((resolve, reject) =&#123;</span><br><span class="line">    setTimeout(() =&#123;</span><br><span class="line">        resolve(<span class="string">'1'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="string">'2'</span>).then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure><p>最终打结果是<code>1</code>而不是<code>2</code></p><p>再例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MyPromise(resolve =resolve(<span class="string">'1'</span>))</span><br><span class="line">    .then()</span><br><span class="line">    .then()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        alert(value)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// output: alert 出 1</span></span><br></pre></td></tr></table></figure><p>通过 <code>return this</code> 只实现了值穿透的一种情况，其实值穿透有两种情况：</p><ol><li>promise 已经是 RESOLVED/REJECTED 时，通过 return this 实现的值穿透：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(() =&#123;</span><br><span class="line">        resolve(<span class="string">'1'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(() =&#123;</span><br><span class="line">    promise.then().then((res) =&#123; <span class="comment">// 状况A</span></span><br><span class="line">        <span class="built_in">console</span>.log(res) <span class="comment">// output: 1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    promise.catch().then((res) =&#123; <span class="comment">// 状况B</span></span><br><span class="line">        <span class="built_in">console</span>.log(res) <span class="comment">// output: 1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(promise.then() === promise.catch()) <span class="comment">// output: true</span></span><br><span class="line">    <span class="built_in">console</span>.log(promise.then(<span class="number">1</span>) === promise.catch(&#123;<span class="attr">name</span>: <span class="string">'anran'</span>&#125;)) <span class="comment">// output: true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>   状况A与B处 promise 已经是 RESOLVED 了符合条件，所以执行了 <code>return this</code>。<br>   注意：原生的Promise实现里并不是这样实现的，会打印出两个false<br>2. promise 是 PENDING时，通过生成新的 promise 加入到父 promise 的 queue，父 promise 有值时调用 callFulfilled-&gt;doResolve 或 callRejected-&gt;doReject（因为 then/catch 传入的参数不是函数）设置子 promise 的状态和值为父 promise 的状态与值。如：<br>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve) =&#123;</span><br><span class="line">    setTimeout(() =&#123;</span><br><span class="line">        resolve(<span class="string">'1'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> a = promise.then()</span><br><span class="line">a.then((res) =&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// output: 1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> b = promise.catch()</span><br><span class="line">b.then((res) =&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// output: 1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(a === b) <span class="comment">// output: false</span></span><br></pre></td></tr></table></figure></p><p>Promise 有三种状态，我们分3个if块来处理，每块都返回一个new Promise。</p><p>根据标准，我们知道，对于一下代码，promise2的值取决于then里面的返回值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise2 = promise1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果promise1被resolve了，promise2的被<code>1</code>resolve，如果promise1 被reject了，promise2将被<code>new Error(&#39;error&#39;)</code>reject。</p><p>所以，我们需要在then里面执行onFulfilled或者onRejected，并根据返回着（标记中记为<code>x</code>）来确定promise2的结果，并且，如果onFulfilled/onRejected返回的是一个Promise，promise将直接取这个Promise的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class="line">    <span class="keyword">var</span> promise2</span><br><span class="line">    <span class="comment">// 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数</span></span><br><span class="line">    <span class="comment">// onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : value =value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : error =&#123;<span class="keyword">throw</span> error&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === RESOLVED) &#123;</span><br><span class="line">        <span class="comment">// 如果promise1（此处为self/this）的状态已经确定并且为resolved，我们调用onFulfilled</span></span><br><span class="line">        <span class="comment">// 如果考虑到有可能throw，所以我们将其包在try/catch块中</span></span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 规范 2.2.4，保证 onFulfilled，onRjected 异步执行</span></span><br><span class="line">      <span class="comment">// 所以用了 setTimeout 包裹下</span></span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> x = onFulfilled(_this.value)</span><br><span class="line">                <span class="comment">// 如果 onFulfilled 的返回值是一个 Promise 对象，直接取它的结果作为 promise2 的结果</span></span><br><span class="line">                <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                    x.then(resolve, reject)</span><br><span class="line">                &#125;</span><br><span class="line">                resolve(x) <span class="comment">// 否则，以它的返回值为 promise2 的结果</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                reject(err) <span class="comment">// 如果出错，以捕获到的错误作为promise2的结果</span></span><br><span class="line">            &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处实现与FULFILLED相似，区别在使用的是onRejected而不是onFulfilled</span></span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === REJECTED) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> x = onRejected(_this.value)</span><br><span class="line">                <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span><br><span class="line">                    x.then(resolve, reject)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 如果当前的Promise还处于PENDING状态，我们并不能确定调用onFulfilled还是onRejected</span></span><br><span class="line">        <span class="comment">// 只有等待Promise的状态确定后，再做处理</span></span><br><span class="line">        <span class="comment">// 所以我们需要把我们的两种情况的处理逻辑做成callback放入promise1（此处即self/this）的回调数组内</span></span><br><span class="line">        <span class="comment">// 处理逻辑和以上相似</span></span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            _this.onResolvedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> x = onFulfilled(_this.value)</span><br><span class="line">                    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                        x.then(resolve, reject)</span><br><span class="line">                    &#125;</span><br><span class="line">                    resolve(x)</span><br><span class="line">                &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            _this.onRejectedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> x = onRejected(_this.value)</span><br><span class="line">                    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                        x.then(resolve, reject)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise构建之七：catch的实现"><a href="#Promise构建之七：catch的实现" class="headerlink" title="Promise构建之七：catch的实现"></a>Promise构建之七：catch的实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// catch 的实现</span></span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们大致实现了Promise标准中所涉及到的内容。</p><h4 id="Promise构建之八：问题补充：无缝调用"><a href="#Promise构建之八：问题补充：无缝调用" class="headerlink" title="Promise构建之八：问题补充：无缝调用"></a>Promise构建之八：问题补充：无缝调用</h4><p>不同的Promise实现之间需要无缝的可交互，如ES6的Promise，和我们自己实现的Promise之间以及其他的Promise实现，必须是无缝调用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">'1'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>.reject(<span class="string">'2'</span>) <span class="comment">// ES6 的 Promise</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Q.all([ <span class="comment">// Q 的 Promise</span></span><br><span class="line">        <span class="keyword">new</span> MyPromise(resolve =resolve(<span class="string">'3'</span>)) <span class="comment">// 我们实现的Promise</span></span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>.eresolve(<span class="string">'4'</span>) <span class="comment">// ES6 的 Promise</span></span><br><span class="line">        Q.resolve(<span class="string">'5'</span>) <span class="comment">// Q 的 Promise</span></span><br><span class="line">    ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我之前实现的代码只是判断OnFullfilled/onRejected的返回值是否为我们自己实现的实例，并没有对其他类型Promise的判断，所以，上面的代码无法正常运行。</p><p>接下来，我们解决这个问题</p><p>关于不同Promise之间的交互，其实<a href="https://promisesaplus.com/#point-46" target="_blank" rel="noopener">Promise/A+标准</a>中有介绍，其中详细的指定了如何通过then的实参返回的值来决定promise2的状态，我们只需要按照标准把标准的内容转成代码即可。</p><p>即我们要<strong>把onFulfilled/onRejected的返回值x。当成是一个可能是Promise的对象</strong>，也即标准中的thenable，并以最保险的姿势调用x上的then方法，如果大家都按照标准来实现，那么不同的Promise之间就可以交互了。</p><p>而标准为了保险起见，即使x返回了一个带有then属性但不遵循Promise标准的对象（不如说这个x把它then里的两个参数都调用了，同步或者异步调用（PS，原则上then的两个参数需要异步调用，下文会讲到），或者是出错后又调用了它们，或者then根本不是一个函数），也能尽可能正确处理。</p><p>关于为何需要不同的Promise实现能够相互交互，我想原因应该是显然的，Promise并不是JS一早就有的标准，不同第三方的实现之间是并不相互知晓的，如果你使用的某一个库中封装了一个Promise实现，想象一下如果它不能跟你自己使用的Promise实现交互的场景。。。</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 规范 2.3</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">resolutionProcedure函数即为根据x的值来决定promise2的状态的函数</span></span><br><span class="line"><span class="comment">也即标准中的[Promise Resolution Procedure](https://promisesaplus.com/#point-47)</span></span><br><span class="line"><span class="comment">x 为 promise2 = promise1.then(onFulfilled, onRejected)里onFulfilled/onRejected的返回值</span></span><br><span class="line"><span class="comment">resolve 和 reject 实际上是 promise2 的executor的两个实参，因为很难挂在其他地方，所以一并传过来。</span></span><br><span class="line"><span class="comment">相信各位一定可以对照标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Chaining cycle detected for promise!"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 规范 2.3.2</span></span><br><span class="line">    <span class="comment">// 如果 x 为 Promise，状态为 pending 需要继续等待否则执行</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        <span class="comment">// 2.3.2.1 如果x为pending状态，promise必须保持pending状态，直到x为fulfilled/rejected</span></span><br><span class="line">        <span class="keyword">if</span> (x.currentState === PENDING) &#123;</span><br><span class="line">            x.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 再次调用该函数是为了确认 x resolve 的</span></span><br><span class="line">                <span class="comment">// 参数是什么类型，如果是基本类型就再次 resolve</span></span><br><span class="line">                <span class="comment">// 把值传给下个 then</span></span><br><span class="line">                resolutionProcedure(promise2, value, resolve, reject)</span><br><span class="line">            &#125;, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 但如果这个promise的状态已经确定了，那么它肯定有一个正常的值，而不是一个thenable，所以这里可以取它的状态</span></span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 规范 2.3.3，判断 x 是否为对象或函数</span></span><br><span class="line">    <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">"object"</span> || <span class="keyword">typeof</span> x === <span class="string">"function"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 规范 2.3.3.2，如果不能取出 then，就 reject</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 规范2.3.3.1 因为x.then可能是一个getter，这种情况下多次读取就有可能产生副作用</span></span><br><span class="line">            <span class="comment">// 既要判断它的类型，又要调用它，这就是两次读取</span></span><br><span class="line">            <span class="keyword">let</span> then = x.then</span><br><span class="line">            <span class="comment">// 规范2.3.3.3，如果 then 是函数，调用 x.then</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">"function"</span>) &#123;</span><br><span class="line">                <span class="comment">// 规范 2.3.3.3</span></span><br><span class="line">    <span class="comment">// reject 或 reject 其中一个执行过的话，忽略其他的</span></span><br><span class="line">                then.call(</span><br><span class="line">                    x,</span><br><span class="line">                    y =&#123; <span class="comment">// 规范 2.3.3.3.1</span></span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">                        called = <span class="literal">true</span></span><br><span class="line">                        <span class="comment">// 规范 2.3.3.3.1</span></span><br><span class="line">                        <span class="keyword">return</span> resolutionProcedure(promise2, y, resolve, reject)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    r =&#123;</span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">                        called = <span class="literal">true</span></span><br><span class="line">                         <span class="keyword">return</span> reject(r)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 规范 2.3.3.4</span></span><br><span class="line">                resolve(x)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">// 规范 2.3.3.2</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 规范 2.3.4，x 为基本类型</span></span><br><span class="line">        resolve(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们使用<code>resolutionProcedure</code>函数替换<code>MyPromise.prototype.then</code>里面几处判断x是否为MyPromise对象的位置即可。即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    x.then(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// resolve(x) // 否则，以它的返回值为 promise2 的结果</span></span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolutionProcedure(promise2, x, resolve, reject)</span><br></pre></td></tr></table></figure><p>总共四处，不要遗漏了</p><h4 id="Promise构建九：完整代码实现"><a href="#Promise构建九：完整代码实现" class="headerlink" title="Promise构建九：完整代码实现"></a>Promise构建九：完整代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">"resolved"</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">    _this.currentState = PENDING <span class="comment">// Promise当前的状态</span></span><br><span class="line">    _this.value = <span class="keyword">void</span> <span class="number">0</span> <span class="comment">// Promise的值</span></span><br><span class="line">    <span class="comment">// 用于保存 then 的回调， 只有当 promise</span></span><br><span class="line">    <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.onResolvedCallbacks = [] <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">    _this.onRejectedCallbacks = [] <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="comment">// 如果 value 是个 Promise， 递归执行</span></span><br><span class="line">            <span class="keyword">return</span> value.then(_this.resolve, _this.reject)</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(() =&#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">                _this.currentState = RESOLVED <span class="comment">// 状态管理</span></span><br><span class="line">                _this.value = value</span><br><span class="line">                _this.onResolvedCallbacks.forEach(cb =cb())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// resolve 处理函数</span></span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        setTimeout(() =&#123; <span class="comment">// 异步执行，保证顺序执行</span></span><br><span class="line">            <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">                _this.currentState = REJECTED <span class="comment">// 状态管理</span></span><br><span class="line">                _this.value = value</span><br><span class="line">                _this.onRejectedCallbacks.forEach(cb =cb())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="comment">// reject 处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="comment">// new Promise(() =throw Error('error'))</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        callback(_this.resolve, _this.reject) <span class="comment">// 执行callback并传入相应的参数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        _this.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// then 方法接受两个参数，onFulfilled，onRejected，分别为Promise成功或失败的回调</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class="line">    <span class="keyword">var</span> promise2</span><br><span class="line">    <span class="comment">// 根据规范 2.2.1 ，onFulfilled、onRejected 都是可选参数</span></span><br><span class="line">    <span class="comment">// onFulfilled、onRejected不是函数需要忽略，同时也实现了值穿透</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : value =value</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : error =&#123;<span class="keyword">throw</span> error&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === RESOLVED) &#123;</span><br><span class="line">        <span class="comment">// 如果promise1（此处为self/this）的状态已经确定并且为resolved，我们调用onFulfilled</span></span><br><span class="line">        <span class="comment">// 如果考虑到有可能throw，所以我们将其包在try/catch块中</span></span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> x = onFulfilled(_this.value)</span><br><span class="line">                <span class="comment">// 如果 onFulfilled 的返回值是一个 Promise 对象，直接取它的结果作为 promise2 的结果</span></span><br><span class="line">                resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                reject(err) <span class="comment">// 如果出错，以捕获到的错误作为promise2的结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处实现与FULFILLED相似，区别在使用的是onRejected而不是onFulfilled</span></span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === REJECTED) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> x = onRejected(_this.value)</span><br><span class="line">                resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 如果当前的Promise还处于PENDING状态，我们并不能确定调用onFulfilled还是onRejected</span></span><br><span class="line">        <span class="comment">// 只有等待Promise的状态确定后，再做处理</span></span><br><span class="line">        <span class="comment">// 所以我们需要把我们的两种情况的处理逻辑做成callback放入promise1（此处即_this/this）的回调数组内</span></span><br><span class="line">        <span class="comment">// 处理逻辑和以上相似</span></span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            _this.onResolvedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> x = onFulfilled(_this.value)</span><br><span class="line">                    resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">                &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            _this.onRejectedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> x = onRejected(_this.value)</span><br><span class="line">                    resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">                &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规范 2.3</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    resolutionProcedure函数即为根据x的值来决定promise2的状态的函数</span></span><br><span class="line"><span class="comment">    也即标准中的[Promise Resolution Procedure](https://promisesaplus.com/#point-47)</span></span><br><span class="line"><span class="comment">    x 为 promise2 = promise1.then(onFulfilled, onRejected)里onFulfilled/onRejected的返回值</span></span><br><span class="line"><span class="comment">    resolve 和 reject 实际上是 promise2 的executor的两个实参，因为很难挂在其他地方，所以一并传过来。</span></span><br><span class="line"><span class="comment">    相信各位一定可以对照标准转换成代码，这里就只标出代码在标准中对应的位置，只在必要的地方做一些解释。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span></span><br><span class="line">        <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Chaining cycle detected for promise!"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 规范 2.3.2</span></span><br><span class="line">        <span class="comment">// 如果 x 为 Promise，状态为 pending 需要继续等待否则执行</span></span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            <span class="comment">// 2.3.2.1 如果x为pending状态，promise必须保持pending状态，直到x为fulfilled/rejected</span></span><br><span class="line">            <span class="keyword">if</span> (x.currentState === PENDING) &#123;</span><br><span class="line">                x.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 再次调用该函数是为了确认 x resolve 的</span></span><br><span class="line">                    <span class="comment">// 参数是什么类型，如果是基本类型就再次 resolve</span></span><br><span class="line">                    <span class="comment">// 把值传给下个 then</span></span><br><span class="line">                    resolutionProcedure(promise2, value, resolve, reject)</span><br><span class="line">                &#125;, reject)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 但如果这个promise的状态已经确定了，那么它肯定有一个正常的值，而不是一个thenable，所以这里可以取它的状态</span></span><br><span class="line">                x.then(resolve, reject)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 规范 2.3.3，判断 x 是否为对象或函数</span></span><br><span class="line">        <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">"object"</span> || <span class="keyword">typeof</span> x === <span class="string">"function"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 规范 2.3.3.2，如果不能取出 then，就 reject</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 规范2.3.3.1 因为x.then可能是一个getter，这种情况下多次读取就有可能产生副作用</span></span><br><span class="line">                <span class="comment">// 既要判断它的类型，又要调用它，这就是两次读取</span></span><br><span class="line">                <span class="keyword">let</span> then = x.then</span><br><span class="line">                <span class="comment">// 规范2.3.3.3，如果 then 是函数，调用 x.then</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">"function"</span>) &#123;</span><br><span class="line">                    <span class="comment">// 规范 2.3.3.3</span></span><br><span class="line">                    <span class="comment">// reject 或 reject 其中一个执行过的话，忽略其他的</span></span><br><span class="line">                    then.call(</span><br><span class="line">                        x,</span><br><span class="line">                        y =&#123; <span class="comment">// 规范 2.3.3.3.1</span></span><br><span class="line">                            <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">                            called = <span class="literal">true</span></span><br><span class="line">                            <span class="comment">// 规范 2.3.3.3.1</span></span><br><span class="line">                            <span class="keyword">return</span> resolutionProcedure(promise2, y, resolve, reject)</span><br><span class="line">                        &#125;,</span><br><span class="line">                        r =&#123;</span><br><span class="line">                            <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">                            called = <span class="literal">true</span></span><br><span class="line">                            <span class="keyword">return</span> reject(r)</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 规范 2.3.3.4</span></span><br><span class="line">                    resolve(x)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">// 规范 2.3.3.2</span></span><br><span class="line">                <span class="keyword">if</span> (called) <span class="keyword">return</span> <span class="comment">// 规范 2.3.3.3.3，即这三处谁先执行就以谁的结果为准</span></span><br><span class="line">                called = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span> reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 规范 2.3.4，x 为基本类型</span></span><br><span class="line">            resolve(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// catch 的实现</span></span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// finally 的实现</span></span><br><span class="line">MyPromise.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MyPromise.resolve(callback()).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MyPromise.resolve(callback()).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> err</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额外，附加 <code>Promise.race</code> 与 <code>Promise.all</code> 的实现，有兴趣的可以了解一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// race</span></span><br><span class="line">MyPromise.race = <span class="function"><span class="keyword">function</span>(<span class="params">values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        values.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            MyPromise.resolve(value).then(resolve, reject)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// all</span></span><br><span class="line">MyPromise.all = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(arr)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length === <span class="number">0</span>) <span class="keyword">return</span> resolve([])</span><br><span class="line">        <span class="keyword">var</span> remaining = args.length</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            res(i, args[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">res</span>(<span class="params">i, val</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (val &amp;&amp; (<span class="keyword">typeof</span> val === <span class="string">'object'</span> || <span class="keyword">typeof</span> val === <span class="string">'function'</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (val <span class="keyword">instanceof</span> MyPromise &amp;&amp; val.then === MyPromise.prototype.then) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (val.currentState === RESOLVED) <span class="keyword">return</span> res(i, val.value)</span><br><span class="line">                    <span class="keyword">if</span> (val.currentState === REJECTED) reject(val.value)</span><br><span class="line">                    val.then(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">                        res(i, val)</span><br><span class="line">                    &#125;, reject)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> then = val.then</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">                        <span class="keyword">var</span> p = <span class="keyword">new</span> MyPromise(then.bind(val))</span><br><span class="line">                        p.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">                            res(i, val)</span><br><span class="line">                        &#125;, reject)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            args[i] = val</span><br><span class="line">            <span class="keyword">if</span> (--remaining === <span class="number">0</span>) &#123;</span><br><span class="line">                resolve(args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Void 0 其实可以理解成undefined，因为undefined可以在局部函数里被覆盖，void 0 不会。</p><p>void是一个运算符，给表达式求值，返回undefined。void 0 是表达式中最短的，最节省字节。</p><p>setTimeout 如果不传时间，默认取0。</p><p>“参考”</p><p><a href="https://segmentfault.com/q/1010000009781257" target="_blank" rel="noopener">promise取消的一些讨论</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;此篇博文转载自瓶子君的blog &lt;a href=&quot;https://github.com/sisterAn/blog/issues/13&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;，并加以自己的理解和注释。&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="Promise 工具" scheme="https://jonnzer.github.io/tags/Promise-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>浏览器异步（二）</title>
    <link href="https://jonnzer.github.io/2020/07/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%82%E6%AD%A5%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://jonnzer.github.io/2020/07/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%82%E6%AD%A5%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-07-17T16:37:05.000Z</published>
    <updated>2020-07-20T08:51:05.190Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自瓶子君的blog <a href="https://github.com/sisterAn/blog/issues/12" target="_blank" rel="noopener">链接</a></p></blockquote><h3 id="step1：回调函数callback"><a href="#step1：回调函数callback" class="headerlink" title="step1：回调函数callback"></a>step1：回调函数callback</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asyncFunction(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种回调函数，大家是最熟悉的。一般是需要在某个耗时操作之后执行某个回调函数。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Time out'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>其中，我们称<code>setTimeout</code>为发起函数，<code>fn</code>为回调函数。都是在主线程上调用的，其中发起函数用来发动异步过程，回调函数用来处理结果。在执行<code>setTimeout</code>1s后，执行function函数。</p><p>下面，我们再看一种情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">'XXX1'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:<span class="string">'XXX2'</span>,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    url: <span class="string">'XXX3'</span>,</span><br><span class="line">                    success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// todo</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    fail: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(err)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            fail: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) </span><br><span class="line">    &#125;,</span><br><span class="line">    fail: <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在上例中，我们看到这段回调函数，不断的在回调，这只是三层回调，在实际应用中，我们遇到的需求会更复杂，回调也许更多，调试起来也就更麻烦，代码也更不美观，这就是我们要引入的第一个问题：回调地狱。</p><p><strong>问题1: 回调地狱</strong></p><p>回调地狱是JS里一个约定俗成的名称，一般情况下，一个业务依赖于上层业务，上层业务又依赖于更上一层的业务，以此类推，如果我们使用回调函数来处理异步的话，就会出现回调地狱。</p><p>主要是因为：大脑对业务的逻辑处理是线性的、阻塞的、单线程的，但是回调表达异步的方式是非线形的、非顺序的，这使得正确推导这类代码的难度很大，很容易出bug。</p><p>再例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">...</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// C</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// B</span></span><br></pre></td></tr></table></figure><p>A和B发生于现在，在JavaScript主程序的直接控制之下，而C会延迟到将来发生，并且是在第三方的控制下，在本例中就是函数$.ajax(…)。从根本上来说，这种控制的转移通常不会给程序带来很多问题。</p><p>但是，请不要被这个小概率迷惑而认为这种控制切换不是什么大问题。实际上，这是回调驱动设计最严重（也是最微妙）的问题。它以这样一个思路为中心：有时候ajax(…)，也就是你交付回调函数的第三方不是你编写的代码，也不在你的直接控制之下，它是某个第三方提供的工具。</p><p>这种情况称为<strong>控制反转</strong>，也就是把自己程序一部分的执行控制交给某个第三方，在你的代码和第三方工具直接有一份并没有明确表达的契约。</p><p>既然是无法控制的第三方在执行你的回调函数，那么就有可能存在以下问题，当然通常情况下是不会发生的：</p><ol><li>调用回调过早</li><li>调用回调过晚</li><li>调用回调次数太多或者太少</li><li>未能把所需的参数成功传给你的回调函数</li><li>吞掉可能出现的错误或异常</li><li>……</li></ol><p>这种控制反转会导致信任链的完全断裂，如果你没有采取行动来解决这些控制反转导致的信任问题，那么你的代码已经有了隐藏的Bug，尽管我们大多数人都没有这样做。</p><p>这里，我们引出了回调函数处理异步的第二个问题：<strong>控制反转</strong>。</p><h3 id="step2：控制反转"><a href="#step2：控制反转" class="headerlink" title="step2：控制反转"></a><strong>step2：控制反转</strong></h3><p>综上，回调函数处理异步流程存在2个问题：</p><p><strong>1. 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符</strong></p><p><strong>2. 缺乏可信任性： 控制反转导致的一系列信任问题</strong></p><p>那么如何来解决这两个问题，先驱者们开始了探索之路……</p><hr><p>参考：<br><a href="https://github.com/sisterAn/blog/issues/12" target="_blank" rel="noopener">瓶子君 blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;转载自瓶子君的blog &lt;a href=&quot;https://github.com/sisterAn/blog/issues/12&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3
      
    
    </summary>
    
    
    
      <category term="JS" scheme="https://jonnzer.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>浏览器异步（一）</title>
    <link href="https://jonnzer.github.io/2020/07/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%82%E6%AD%A5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://jonnzer.github.io/2020/07/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%82%E6%AD%A5%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-07-17T15:10:05.000Z</published>
    <updated>2020-07-20T12:27:02.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注： 转载瓶子君文章 <a href="https://github.com/sisterAn/blog/issues/11" target="_blank" rel="noopener">详细连接</a></p></blockquote><p>已知，JavaScript 是单线程的，天生异步，适合 IO 密集型，不适合 CPU 密集型，但是，为什么是异步的，异步由何而来的，我们将在这里逐渐讨论实现。</p><h3 id="一、进程与线程"><a href="#一、进程与线程" class="headerlink" title="一、进程与线程"></a>一、进程与线程</h3><h4 id="1-浏览器是多进程的"><a href="#1-浏览器是多进程的" class="headerlink" title="1. 浏览器是多进程的"></a>1. 浏览器是多进程的</h4><p>它主要包括以下进程：</p><ul><li>Browser 进程：浏览器的主进程，唯一，负责创建和销毁其它进程、网络资源的下载与管理、浏览器界面的展示、前进后退等。</li><li>GPU 进程：用于 3D 绘制等，最多一个。</li><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。</li><li>浏览器渲染进程（浏览器内核）：内部是多线程的，每打开一个新网页就会创建一个进程，主要用于页面渲染，脚本执行，事件处理等。</li></ul><h4 id="2-渲染进程（浏览器内核）"><a href="#2-渲染进程（浏览器内核）" class="headerlink" title="2. 渲染进程（浏览器内核）"></a>2. 渲染进程（浏览器内核）</h4><p>浏览器的渲染进程是多线程的，页面的渲染，JavaScript 的执行，事件的循环，都在这个进程内进行：</p><ul><li>GUI 渲染线程：负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。</li><li>JavaScript 引擎线程：也称为 JavaScript 内核，负责处理 Javascript 脚本程序、解析 Javascript 脚本、运行代码等。（例如 V8 引擎）</li><li>事件触发线程：用来控制浏览器事件循环，注意这不归 JavaScript 引擎线程管，当事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。</li><li>定时触发器线程：传说中的 <code>setInterval</code> 与 <code>setTimeout</code> 所在线程，注意，W3C 在 HTML 标准中规定，规定要求 <code>setTimeout</code> 中低于 4ms 的时间间隔算为 4ms 。</li><li>异步 http 请求线程：在 <code>XMLHttpRequest</code> 连接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就<strong>产生状态变更事件</strong>，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li></ul><p>注意，<strong>GUI 渲染线程与 JavaScript 引擎线程是互斥的</strong>，当 JavaScript 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中<strong>等到 JavaScript 引擎空闲时</strong>立即被执行。所以如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><h3 id="二、单线程的-JavaScript"><a href="#二、单线程的-JavaScript" class="headerlink" title="二、单线程的 JavaScript"></a>二、单线程的 JavaScript</h3><p>所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。</p><p><strong>问题：首先为什么要引入单线程？</strong></p><p>我们知道：</p><ul><li>浏览器需要渲染 DOM</li><li>JavaScript 可以修改 DOM 结构</li><li>JavaScript 执行时，浏览器 DOM 渲染停止</li></ul><p>如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都修改 DOM，那么就会出现 DOM 冲突。</p><p>你可能会说，<a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noopener">web worker</a> 就支持多线程，但是 web worker 不能访问 window 对象，document 对象等。</p><p><strong>原因：避免 DOM 渲染的冲突</strong></p><p>当然，我们可以为浏览器引入<strong>锁</strong> 的机制来解决这些冲突，但其大大提高了复杂性，所以 JavaScript从诞生开始就选择了单线程执行。</p><p>引入单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这同时又导致了一个问题：如果前一个任务耗时很长，后一个任务就不得不一直等着。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例1</span></span><br><span class="line"><span class="keyword">let</span> i, sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i ++) &#123;</span><br><span class="line">    sum += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum)</span><br></pre></td></tr></table></figure><p>在实例1中，<code>sum</code> 并不能立刻打印出来，必须在 for 循环执行完成之后才能执行 <code>console.log(sum)</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">alert(<span class="string">'hello'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>在实例2中，浏览器先打印 <code>1</code> ，然后弹出弹框，点击确定后才执行 <code>console.log(2)</code> 。</p><p><strong>总结：</strong></p><ul><li>优点：实现比较简单，执行环境相对单纯</li><li>缺点：只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 Javascript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</li></ul><p>为了解决这个问题，JavaScript 语言将任务的执行模式分为两种：同步和异步</p><h3 id="三、同步与异步"><a href="#三、同步与异步" class="headerlink" title="三、同步与异步"></a>三、同步与异步</h3><h4 id="1-同步"><a href="#1-同步" class="headerlink" title="1. 同步"></a>1. 同步</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(args...)</span><br></pre></td></tr></table></figure><p>如果在函数 <code>func</code> 返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">Math</span>.floor(a)</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="2-异步"><a href="#2-异步" class="headerlink" title="2. 异步"></a>2. 异步</h4><p>如果在函数 <code>func</code> 返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'foo.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>JavaScript 采用异步编程原因有两点，</p><ul><li>一是 JavaScript 是单线程；</li><li>二是为了提高 CPU 的利用率。</li></ul><h3 id="四、异步过程"><a href="#四、异步过程" class="headerlink" title="四、异步过程"></a>四、异步过程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'data.json'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在执行这段代码时，<code>fs.readFile</code> 函数返回时，并不会立刻打印 <code>data</code> ，只有 <code>data.json</code> 读取完成时才打印。也就是异步函数 <code>fs.readFile</code> 执行很快，但后面还有工作线程执行异步任务、通知主线程、主线程回调等操作，这个过程就叫做异步过程。</p><p>主线程发起一个异步操作，相应的工作线程接受请求并告知主线程已收到（异步函数返回）；主线程继续执行后面的任务，同时工作线程执行异步任务；工作线程完成任务后，通知主线程；主线程收到通知后，执行一定的动作（调用回调函数）。</p><p>工作线程在异步操作完成后通知主线程，那么这个通知机制又是如何显现？答案就是就是消息队列与事件循环。</p><h3 id="五、消息队列与事件循环"><a href="#五、消息队列与事件循环" class="headerlink" title="五、消息队列与事件循环"></a>五、消息队列与事件循环</h3><p>工作线程将消息放在消息队列，主线程通过事件循环过程去取消息。</p><ul><li>消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。</li><li>事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。</li></ul><h4 id="1-事件循环（eventloop）"><a href="#1-事件循环（eventloop）" class="headerlink" title="1. 事件循环（eventloop）"></a>1. 事件循环（eventloop）</h4><p>主线程不断的从消息队列中取消息，执行消息，这个过程称为事件循环，这种机制叫事件循环机制，取一次消息并执行的过程叫一次循环。</p><p>大致实现过程如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> message = queue.get()</span><br><span class="line">    execute(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'xxxx'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// output：4321 或 4312</span></span><br></pre></td></tr></table></figure><p>其中，主线程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>异步队列：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步队列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 100ms后</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// ajax加载完成之后</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>事件循环是JavaScript实现异步的具体解决方案，其中同步代码，直接执行；异步函数先放在异步队列中，待同步函数执行完毕后，轮询执行 异步队列 的回调函数。</strong></p><h4 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2. 消息队列"></a>2. 消息队列</h4><p>其中，消息就是注册异步任务时添加的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(<span class="string">'XXX'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>主线程在发起 AJAX 请求后，会继续执行其他代码，AJAX 线程负责请求 <code>XXX</code>，拿到请求后，会封装成 JavaScript 对象，然后构造一条消息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息队列里的消息</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>callback</code> 是 AJAX 网络请求成功响应时的回调函数。</p><p>主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是 <code>message</code> 函数)，并执行它。到此为止，就完成了工作线程对主线程的 <code>通知</code> ，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，AJAX 线程在收到 HTTP 响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。</p><p><img src="https://camo.githubusercontent.com/2f5acdeefff9a281d03db7defe011fff037cf1ee/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139333333392e706e67" alt></p><p>异步过程中的回调函数，<strong>一定不在当前这一轮事件循环中执行</strong>。</p><h3 id="六、异步与事件"><a href="#六、异步与事件" class="headerlink" title="六、异步与事件"></a>六、异步与事件</h3><p>消息队列中的每条消息实际上都对应着一个事件。</p><p>其中一个重要的异步过程就是： <strong>DOM事件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>)</span><br><span class="line">button.addEventLister(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'事件'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>从异步的角度看，<code>addEventLister</code> 函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放在消息队列中，等待主线程执行。</p><p>事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。</p><p>另外，所有的异步过程也都可以用事件来描述。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(func, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 可以看成：</span></span><br><span class="line">timer.addEventLister(<span class="string">'timeout'</span>, <span class="number">1000</span>, func)</span><br></pre></td></tr></table></figure><p>其中关于事件的详细描述，可以看这篇文章： <a href="http://blog.xieliqun.com/2016/08/12/event-delegate/" target="_blank" rel="noopener">事件绑定、事件监听、事件委托</a>，这里不再深入介绍。</p><h3 id="七、生产者与消费者"><a href="#七、生产者与消费者" class="headerlink" title="七、生产者与消费者"></a>七、生产者与消费者</h3><p>生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加数据，消费者从存储空间中取走数据，当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。</p><p><img src="https://camo.githubusercontent.com/a717134740586438955fb819b2b76d07ff4d3295/687474703a2f2f7265736f757263652e6d757969792e636e2f696d6167652f32303230303232353139323732312e676966" alt></p><p>从生产者与消费者的角度看，异步过程是这样的：</p><p>工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空。</p><p>那么异步的实现方式有哪些？</p><ul><li>ES6之前：回调函数、eventloop事件机制、Promise、发布/订阅</li><li>ES6：Generator</li><li>ES7: Async/Await</li></ul><hr><p>参考：<br><a href="https://github.com/sisterAn/blog/issues/11" target="_blank" rel="noopener">瓶子君 blog</a></p><p><a href="https://github.com/sisterAn/blog/issues/23" target="_blank" rel="noopener">瓶子君 Generator</a></p><p><a href="https://github.com/sisterAn/blog/issues/27" target="_blank" rel="noopener">瓶子君 co函数</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;注： 转载瓶子君文章 &lt;a href=&quot;https://github.com/sisterAn/blog/issues/11&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;详细连接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p
      
    
    </summary>
    
    
    
      <category term="JS" scheme="https://jonnzer.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://jonnzer.github.io/2020/07/15/%E7%AE%97%E6%B3%95/"/>
    <id>https://jonnzer.github.io/2020/07/15/%E7%AE%97%E6%B3%95/</id>
    <published>2020-07-15T14:59:19.000Z</published>
    <updated>2020-07-15T16:19:16.931Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-深度优先搜索-amp-amp-广度优先搜索"><a href="#1-深度优先搜索-amp-amp-广度优先搜索" class="headerlink" title="1. 深度优先搜索 &amp;&amp; 广度优先搜索"></a>1. 深度优先搜索 &amp;&amp; 广度优先搜索</h4><p>深度：一个人，一条路走到黑，路不通，则到上一个分叉口，再一次一条路走到黑，循环，直到找到出口为止<br>广度：几个人，同时面对几个分叉路口，直到找到出口为止。像wifi状的数据节点分布就最适合这种算法。</p><p>参考：<br><a href="https://github.com/sisterAn/JavaScript-Algorithms" target="_blank" rel="noopener">瓶子君 算法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-深度优先搜索-amp-amp-广度优先搜索&quot;&gt;&lt;a href=&quot;#1-深度优先搜索-amp-amp-广度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;1. 深度优先搜索 &amp;amp;&amp;amp; 广度优先搜索&quot;&gt;&lt;/a&gt;1. 深度优先搜索 &amp;am
      
    
    </summary>
    
    
    
      <category term="算法" scheme="https://jonnzer.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>克隆对象&amp;&amp;数组（二）</title>
    <link href="https://jonnzer.github.io/2020/07/13/%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1&amp;&amp;%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://jonnzer.github.io/2020/07/13/%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1&amp;&amp;%E6%95%B0%E7%BB%84%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-07-13T07:12:29.000Z</published>
    <updated>2020-07-15T15:21:11.023Z</updated>
    
    <content type="html"><![CDATA[<h4 id="4-深拷贝CODE"><a href="#4-深拷贝CODE" class="headerlink" title="4. 深拷贝CODE"></a>4. 深拷贝CODE</h4><p><code>深拷贝 = 浅拷贝 + 遇到对象时递归拷贝</code><br>（1）最简单莫过于字符序列化，再parse反序列化<br>语法：JSON.parse(JSON.stringify) </p><div class="tip">后端传回的变量一般用它来拷贝足以应对。只是，1、会忽略 undefined<p>2、会忽略 symbol</p><p>3、不能序列化函数</p><p>4、不能解决循环引用的对象</p><p>5、不能正确处理new Date()</p><p>6、不能处理正则</p><p>undefined、symbol 和函数这三种情况，会直接忽略。拷贝函数会undefined，拷贝正则会Object{}，没拷完整。</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// undefined symbol 函数示例</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'muyiy'</span>,</span><br><span class="line">    a: <span class="literal">undefined</span>,</span><br><span class="line">    b: <span class="built_in">Symbol</span>(<span class="string">'muyiy'</span>),</span><br><span class="line">    c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: "muyiy", </span></span><br><span class="line"><span class="comment">// a: undefined, </span></span><br><span class="line"><span class="comment">//  b: Symbol(muyiy), </span></span><br><span class="line"><span class="comment">//  c: ƒ ()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;name: "muyiy"&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环引用</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        c: <span class="number">2</span>,</span><br><span class="line">   d: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a = obj.b;</span><br><span class="line">obj.b.c = obj.a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="comment">// Uncaught TypeError: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new Date转化结果不正确 结果方案是转为时间戳</span></span><br><span class="line"><span class="keyword">let</span> date = (<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf();</span><br><span class="line"><span class="built_in">JSON</span>.stringify(date); </span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(date)); <span class="comment">// 和上面的输出是同一个值</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正则</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"muyiy"</span>,</span><br><span class="line">    a: <span class="regexp">/'123'/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123;name: "muyiy", a: /'123'/&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// &#123;name: "muyiy", a: &#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>(2) 简易深拷贝</p><p>第一版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个虽然能简单实现 却有以下问题</span></span><br><span class="line"><span class="comment">// 1、没有对传入参数进行校验，传入 null 时应该返回 null 而不是 &#123;&#125;</span></span><br><span class="line"><span class="comment">// 2、对于对象的判断逻辑不严谨，因为 typeof null === 'object'</span></span><br><span class="line"><span class="comment">// 3、没有考虑数组的兼容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep1</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> source[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">                target[key] = cloneDeep1(source[key]); <span class="comment">// 注意这里 如果是对象的时候递归调用</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二版 （非对象的返回自身以及数组的支持）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;<span class="comment">// 非对象返回自身</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span> &amp;&amp; obj != <span class="literal">null</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep2</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source; <span class="comment">// 非对象返回自身</span></span><br><span class="line">    <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;; <span class="comment">// 初始值为空数组或空对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">                target[key] = cloneDeep2(source[key]); <span class="comment">// 注意这里</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用上面测试用例测试一下</span></span><br><span class="line"><span class="keyword">var</span> b = cloneDeep2(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">//   name: 'muyiy', </span></span><br><span class="line"><span class="comment">//   book: &#123; title: 'You Don\'t Know JS', price: '45' &#125;,</span></span><br><span class="line"><span class="comment">//   a1: undefined,</span></span><br><span class="line"><span class="comment">//   a2: null,</span></span><br><span class="line"><span class="comment">//   a3: 123</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>第三版 （支持对象循环引用）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep3</span>(<span class="params">source, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source; </span><br><span class="line">    <span class="keyword">if</span> (hash.has(source)) <span class="keyword">return</span> hash.get(source); <span class="comment">// 新增代码，查哈希表</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;;</span><br><span class="line">    hash.set(source, target); <span class="comment">// 新增代码，哈希表设值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">                target[key] = cloneDeep3(source[key], hash); <span class="comment">// 新增代码，传入哈希表</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">        name: <span class="string">"muyiy"</span>,</span><br><span class="line">        a1: <span class="literal">undefined</span>,</span><br><span class="line">        a2: <span class="literal">null</span>,</span><br><span class="line">        a3: <span class="number">123</span>,</span><br><span class="line">        book: &#123;<span class="attr">title</span>: <span class="string">"You Don't Know JS"</span>, <span class="attr">price</span>: <span class="string">"45"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    a.circleRef = a <span class="comment">// circleRef是个很奇特的属性，它能在自身存自己，并永久循环，</span></span><br><span class="line">    <span class="keyword">var</span> b = cloneDeep3(a)</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure><p>第四版 （保存引用关系）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组版</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">cloneDeep3</span>(<span class="params">source, uniqueList</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source</span><br><span class="line">     <span class="keyword">if</span> (!uniqueList) uniqueList = []</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> uniqueData = find(uniqueList, source)</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 数据已经存在，返回保存的数据 如果return这一步，会跳到下方的return target</span></span><br><span class="line">     <span class="keyword">if</span>(uniqueData) &#123;</span><br><span class="line">         <span class="keyword">return</span> uniqueData.target</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 数据不存在，保存源数据，以及对应的引用</span></span><br><span class="line">     uniqueList.push(&#123; <span class="comment">// 用数组存储键值对</span></span><br><span class="line">         source: source,</span><br><span class="line">         target: target</span><br><span class="line">     &#125;)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source,key)) &#123;</span><br><span class="line">             <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">                 target[key] = cloneDeep3(source[key], uniqueList)</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 target[key] = source[key]</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> target <span class="comment">// target很值得玩味，递归完了后的callStack让人惊奇</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"> <span class="keyword">var</span> obj2 = &#123;<span class="attr">a</span>: obj1, <span class="attr">b</span>: obj1&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(obj2.a === obj2.b);</span><br><span class="line"> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> obj3 = cloneDeep3(obj2);</span><br><span class="line"> <span class="built_in">console</span>.log(obj3.a === obj3.b)</span><br><span class="line"> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>第五版 （拷贝Symbol类型）<br>思路就是先查找有没有 Symbol 属性，如果查找到则先遍历处理 Symbol 情况，然后再处理正常情况，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逻辑代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep4</span>(<span class="params">source, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isObject(source)) <span class="keyword">return</span> source; </span><br><span class="line">    <span class="keyword">if</span> (hash.has(source)) <span class="keyword">return</span> hash.get(source); </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">let</span> target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;;</span><br><span class="line">    hash.set(source, target);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ============= 新增代码</span></span><br><span class="line">    <span class="keyword">let</span> symKeys = <span class="built_in">Object</span>.getOwnPropertySymbols(source); <span class="comment">// 查找 </span></span><br><span class="line">    <span class="keyword">if</span> (symKeys.length) &#123; <span class="comment">// 查找成功</span></span><br><span class="line">        symKeys.forEach(<span class="function"><span class="params">symKey</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isObject(source[symKey])) &#123;</span><br><span class="line">                target[symKey] = cloneDeep4(source[symKey], hash); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[symKey] = source[symKey];</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// =============</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isObject(source[key])) &#123;</span><br><span class="line">                target[key] = cloneDeep4(source[key], hash); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 可以看到成功拷贝了Symbol类型</span></span><br><span class="line"><span class="keyword">var</span> sym1 = <span class="built_in">Symbol</span>(<span class="string">"a"</span>); <span class="comment">// 创建新的symbol类型</span></span><br><span class="line"><span class="keyword">var</span> sym2 = <span class="built_in">Symbol</span>.for(<span class="string">"b"</span>); <span class="comment">// 从全局的symbol注册?表设置和取得symbol</span></span><br><span class="line"></span><br><span class="line">a[sym1] = <span class="string">"localSymbol"</span>;</span><br><span class="line">a[sym2] = <span class="string">"globalSymbol"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = cloneDeep4(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: "muyiy",</span></span><br><span class="line"><span class="comment">// a1: undefined,</span></span><br><span class="line"><span class="comment">//a2: null,</span></span><br><span class="line"><span class="comment">// a3: 123,</span></span><br><span class="line"><span class="comment">// book: &#123;title: "You Don't Know JS", price: "45"&#125;,</span></span><br><span class="line"><span class="comment">// circleRef: &#123;name: "muyiy", book: &#123;…&#125;, a1: undefined, a2: null, a3: 123, …&#125;,</span></span><br><span class="line"><span class="comment">//  [Symbol(a)]: 'localSymbol',</span></span><br><span class="line"><span class="comment">//  [Symbol(b)]: 'globalSymbol'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>第六版 破解递归爆栈 (待研究@todo)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep5</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> root = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈</span></span><br><span class="line">    <span class="keyword">const</span> loopList = [</span><br><span class="line">        &#123;</span><br><span class="line">            parent: root,</span><br><span class="line">            key: <span class="literal">undefined</span>,</span><br><span class="line">            data: x,</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(loopList.length) &#123;</span><br><span class="line">        <span class="comment">// 广度优先</span></span><br><span class="line">        <span class="keyword">const</span> node = loopList.pop();</span><br><span class="line">        <span class="keyword">const</span> parent = node.parent;</span><br><span class="line">        <span class="keyword">const</span> key = node.key;</span><br><span class="line">        <span class="keyword">const</span> data = node.data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span></span><br><span class="line">        <span class="keyword">let</span> res = parent;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> key !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            res = parent[key] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.hasOwnProperty(k)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> data[k] === <span class="string">'object'</span>) &#123;</span><br><span class="line">                    <span class="comment">// 下一次循环</span></span><br><span class="line">                    loopList.push(&#123;</span><br><span class="line">                        parent: res,</span><br><span class="line">                        key: k,</span><br><span class="line">                        data: data[k],</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[k] = data[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小语法："><a href="#小语法：" class="headerlink" title="小语法："></a>小语法：</h4><p>1 Object.keys(..) 返回一个数组，包含所有可枚举属性<br>2 Object.getOwnPropertyNames(..) 返回一个数组，包含所有属性，无论它们是否可枚举<br>3 Object.getOwnPropertyDescriptor() 会返回对象的属性的指定描述<br>4 in &amp;&amp; hasOwnProperty</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherObject = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建一个关联到 anotherObject 的对象</span></span><br><span class="line"><span class="keyword">var</span> myObject = <span class="built_in">Object</span>.create( anotherObject );</span><br><span class="line">myObject.b = <span class="number">2</span>;</span><br><span class="line">(<span class="string">"a"</span> <span class="keyword">in</span> myObject); <span class="comment">// true</span></span><br><span class="line">(<span class="string">"b"</span> <span class="keyword">in</span> myObject); <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">"a"</span> ); <span class="comment">// false</span></span><br><span class="line">myObject.hasOwnProperty( <span class="string">"b"</span> ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。</span></span><br><span class="line"><span class="comment">// (2) hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 原型链。</span></span><br></pre></td></tr></table></figure><p>5 WeakMap<br>特点：弱引用，需以对象作为key，不打扰垃圾回收机制，可以通过set，get来取值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">      wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(),</span><br><span class="line">      wm3 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;,</span><br><span class="line">      o2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">      o3 = <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">wm1.set(o1, <span class="number">37</span>);</span><br><span class="line">wm1.set(o2, <span class="string">"azerty"</span>);</span><br><span class="line">wm2.set(o1, o2); <span class="comment">// value可以是任意值,包括一个对象或一个函数</span></span><br><span class="line">wm2.set(o3, <span class="literal">undefined</span>);</span><br><span class="line">wm2.set(wm1, wm2); <span class="comment">// 键和值可以是任意对象,甚至另外一个WeakMap对象</span></span><br><span class="line"></span><br><span class="line">wm1.get(o2); <span class="comment">// "azerty"</span></span><br><span class="line">wm2.get(o2); <span class="comment">// undefined,wm2中没有o2这个键</span></span><br><span class="line">wm2.get(o3); <span class="comment">// undefined,值就是undefined</span></span><br><span class="line"></span><br><span class="line">wm1.has(o2); <span class="comment">// true</span></span><br><span class="line">wm2.has(o2); <span class="comment">// false</span></span><br><span class="line">wm2.has(o3); <span class="comment">// true (即使值是undefined)</span></span><br><span class="line"></span><br><span class="line">wm3.set(o1, <span class="number">37</span>);</span><br><span class="line">wm3.get(o1); <span class="comment">// 37</span></span><br><span class="line"></span><br><span class="line">wm1.has(o1);   <span class="comment">// true</span></span><br><span class="line">wm1.delete(o1);</span><br><span class="line">wm1.has(o1);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>参考<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">MDN Object.assign</a><br><a href="https://github.com/wengjq/Blog/issues/3" target="_blank" rel="noopener">wengjq issue</a><br><a href="https://github.com/yygmind/blog/issues/25" target="_blank" rel="noopener">yygmind issue</a><br><a href="https://github.com/yygmind/blog/labels/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">yygmind 深浅拷贝汇总</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax" target="_blank" rel="noopener">展开语法</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" rel="noopener">MDN Object.getOwnPropertyDescription</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" target="_blank" rel="noopener">MDN WeakMap</a><br><a href="https://www.codenong.com/29413222/" target="_blank" rel="noopener">神奇的weakmap科普贴</a><br><a href="https://segmentfault.com/a/1190000016672263" target="_blank" rel="noopener">颜海镜</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;4-深拷贝CODE&quot;&gt;&lt;a href=&quot;#4-深拷贝CODE&quot; class=&quot;headerlink&quot; title=&quot;4. 深拷贝CODE&quot;&gt;&lt;/a&gt;4. 深拷贝CODE&lt;/h4&gt;&lt;p&gt;&lt;code&gt;深拷贝 = 浅拷贝 + 遇到对象时递归拷贝&lt;/code&gt;&lt;br&gt;（1
      
    
    </summary>
    
    
    
      <category term="JS 拷贝" scheme="https://jonnzer.github.io/tags/JS-%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>克隆对象&amp;&amp;数组（一）</title>
    <link href="https://jonnzer.github.io/2020/07/13/%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1&amp;&amp;%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://jonnzer.github.io/2020/07/13/%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1&amp;&amp;%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-07-13T07:12:00.000Z</published>
    <updated>2020-07-14T11:33:11.129Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-从数据类型说起"><a href="#1-从数据类型说起" class="headerlink" title="1 从数据类型说起"></a>1 从数据类型说起</h4><p><code>JavaScript</code>的数据类型：</p><ul><li>基本类型： <code>Null，undefined，number，string，Boolean</code> 存放在<code>栈内存</code>的简单数据，可以直接访问</li><li>引用类型：<code>Array，Object，Function</code> 存放在<code>堆内存</code>，存放的是该对象的<code>地址指针</code></li></ul><h4 id="2-深浅拷贝由来"><a href="#2-深浅拷贝由来" class="headerlink" title="2 深浅拷贝由来"></a>2 深浅拷贝由来</h4><p>引用类型的数据，因为指向指针的问题，<code>浅拷贝</code>就会导致指向同一处，那么修改拷贝的任一者，都会<code>导致全部都改</code>了。<br>这时候，就需要<code>深拷贝</code>，它可以开辟新的内存地址，让拷贝的对象们指向不同，这样就<code>不会互相影响</code>了。</p><h4 id="3-浅拷贝CODE"><a href="#3-浅拷贝CODE" class="headerlink" title="3 浅拷贝CODE"></a>3 浅拷贝CODE</h4><p><code>浅拷贝</code>就是拷贝<code>第一层的基本类型值</code>，以及<code>第一层的引用类型地址</code>。<br>（1）for…in…遍历属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">copyObj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i <span class="keyword">in</span> copyObj) &#123;</span><br><span class="line">    obj[i] = copyObj[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">  c: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> y = shallowClone(x);</span><br><span class="line"><span class="built_in">console</span>.log(y.b.f === x.b.f);     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（2）Object.assign()<br>将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。只遍历一层<br>基础用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">b</span>: <span class="number">4</span>, <span class="attr">c</span>: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> returnedTarget = <span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target);</span><br><span class="line"><span class="comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(returnedTarget);</span><br><span class="line"><span class="comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br></pre></td></tr></table></figure><p>复制对象（浅）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>(3) <code>Array</code>的<code>slice&amp;concat</code>方法<br>它们虽然在demo里看起来像深，其实也是浅拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </span><br><span class="line"><span class="keyword">var</span> array_shallow = array; </span><br><span class="line"><span class="keyword">var</span> array_concat = array.concat(); </span><br><span class="line"><span class="keyword">var</span> array_slice = array.slice(<span class="number">0</span>); </span><br><span class="line"><span class="built_in">console</span>.log(array === array_shallow); <span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(array === array_slice); <span class="comment">//false，“看起来”像深拷贝</span></span><br><span class="line"><span class="built_in">console</span>.log(array === array_concat); <span class="comment">//false，“看起来”像深拷贝</span></span><br></pre></td></tr></table></figure><p>(4) 展开语法<code>...</code><br>对数组和对象的浅拷贝，类似Object.assign的功能。只能用于可迭代对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr1 = [...arr2, ...arr1]; <span class="comment">// arr1 现在为 [3, 4, 5, 0, 1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">x</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">'baz'</span>, <span class="attr">y</span>: <span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> clonedObj = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="comment">// 克隆后的对象: &#123; foo: "bar", x: 42 &#125;</span></span><br><span class="line"><span class="keyword">var</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line"><span class="comment">// 合并后的对象: &#123; foo: "baz", x: 42, y: 13 &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-从数据类型说起&quot;&gt;&lt;a href=&quot;#1-从数据类型说起&quot; class=&quot;headerlink&quot; title=&quot;1 从数据类型说起&quot;&gt;&lt;/a&gt;1 从数据类型说起&lt;/h4&gt;&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;的数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
    
      <category term="JS 拷贝" scheme="https://jonnzer.github.io/tags/JS-%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>apollo主题增加Valine评论</title>
    <link href="https://jonnzer.github.io/2020/07/11/apollo%E4%B8%BB%E9%A2%98%E5%A2%9E%E5%8A%A0Valine%E8%AF%84%E8%AE%BA/"/>
    <id>https://jonnzer.github.io/2020/07/11/apollo%E4%B8%BB%E9%A2%98%E5%A2%9E%E5%8A%A0Valine%E8%AF%84%E8%AE%BA/</id>
    <published>2020-07-11T11:08:18.000Z</published>
    <updated>2020-07-13T09:18:16.418Z</updated>
    
    <content type="html"><![CDATA[<h4 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h4><p>大道至简<br>最近刚迁移主题到<code>Apollo</code>，相当清新的主题，具体的参考<a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="noopener">github</a></p><h4 id="评论系统的选择"><a href="#评论系统的选择" class="headerlink" title="评论系统的选择"></a>评论系统的选择</h4><p>从支持的表情与颜值上来看，果断选择了<code>Valine</code><br>效果图可以看博客下方😊</p><div class="tip">    因为Apollo主题已经关闭issue，所以只能自己去增加评论的初始化代码了</div> <h4 id="魔改"><a href="#魔改" class="headerlink" title="魔改"></a>魔改</h4><p>1 <code>themes/apollo/_config.yml</code>:<br>    <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">    <span class="comment"># 开启 Valine 评论</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 设置应用 id 和 key</span></span><br><span class="line">    <span class="attr">appId:</span> <span class="string">您的appId</span></span><br><span class="line">    <span class="attr">appKey:</span> <span class="string">您的appkey</span></span><br></pre></td></tr></table></figure><br>2 <code>themes/apollo/source/js/Valine.min.js</code>： 拷贝Valinecdn路径，缓存到本地，以防万一<br>3 <code>themes/apollo/layout/partial/head.jade</code>: 增加引用<code>script(src=url_for(&quot;js/Valine.min.js&quot;))</code><br>4 <code>themes/apollo/layout/partial/comment.jade</code>: 增加主题的评论判断<br>     <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.valine</span><br><span class="line">    div#vcomments</span><br><span class="line">    <span class="comment">//script(src="//unpkg.com/valine/dist/Valine.min.js")</span></span><br><span class="line">    script.</span><br><span class="line">        <span class="keyword">new</span> Valine(&#123; <span class="comment">// 里面的参数配置具体参考Valine官网</span></span><br><span class="line">            el: <span class="string">'#vcomments'</span>,</span><br><span class="line">            appId: <span class="string">`#&#123;theme.valine.appId&#125;`</span>,</span><br><span class="line">            appKey: <span class="string">`#&#123;theme.valine.appKey&#125;`</span>,</span><br><span class="line">            placeholder: <span class="string">'快来评论吧(#^.^#)'</span>,</span><br><span class="line">            avatar: <span class="string">'wavatar'</span></span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><hr><p>参考<br><a href="https://www.playpi.org/2019032001.html" target="_blank" rel="noopener">Valine前后所需介绍</a><br><a href="https://valine.js.org/" target="_blank" rel="noopener">Valine官网</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;初衷&quot;&gt;&lt;a href=&quot;#初衷&quot; class=&quot;headerlink&quot; title=&quot;初衷&quot;&gt;&lt;/a&gt;初衷&lt;/h4&gt;&lt;p&gt;大道至简&lt;br&gt;最近刚迁移主题到&lt;code&gt;Apollo&lt;/code&gt;，相当清新的主题，具体的参考&lt;a href=&quot;https://gith
      
    
    </summary>
    
    
    
      <category term="Apollo Hexo Valine" scheme="https://jonnzer.github.io/tags/Apollo-Hexo-Valine/"/>
    
  </entry>
  
  <entry>
    <title>AST</title>
    <link href="https://jonnzer.github.io/2020/07/03/AST/"/>
    <id>https://jonnzer.github.io/2020/07/03/AST/</id>
    <published>2020-07-03T09:54:10.000Z</published>
    <updated>2020-07-26T09:27:29.708Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Hey, password is required here.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="84a33b2fbbed19185d31efebb6cafdde4175e8cc83e992ef9c78fcbc44a016d1">caa1a1d43835d9141a4da548b369bd263e2ca97808e7831a580ac0011e7780221685f5e1bed1e1f4b4e8f806a869deeb0dc76c7a9e1bf59c50fce6c5e1bedab86d0aad34e917afb9b0ba64e9ccec17e2922262dcf383d5f01eef153b4ec08861</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
    
      <category term="JS" scheme="https://jonnzer.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>test加密</title>
    <link href="https://jonnzer.github.io/2020/07/03/test/"/>
    <id>https://jonnzer.github.io/2020/07/03/test/</id>
    <published>2020-07-03T09:54:10.000Z</published>
    <updated>2020-07-23T10:52:38.649Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">您好, 这里需要密码😊</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="2178b67a31e04e98a6d5640f8120c88e6daf169d966b5834e802f4a9199af9a7">f1589d5d3bccaa9f6c29aaaf98e142b8d01af2777bb28c6d6efc96edc55df4ac</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      该篇文章博主不想让其他人看见哟~
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>偏函数</title>
    <link href="https://jonnzer.github.io/2020/07/02/%E5%81%8F%E5%87%BD%E6%95%B0/"/>
    <id>https://jonnzer.github.io/2020/07/02/%E5%81%8F%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-02T13:15:36.000Z</published>
    <updated>2020-07-02T13:22:28.729Z</updated>
    
    <content type="html"><![CDATA[<p>我的理解是，传入并缓存固定的参数，返回指定的函数。<br>而且是一种特别的柯里化。<br>柯里化是一参变多参。<br>偏函数是前面的参数会导致后来return的函数不一样。书面点讲，就是指定部分参数，来产生一个新的定制函数。</p><p>参考：<br><a href="https://blog.csdn.net/qq_15241071/article/details/80036346" target="_blank" rel="noopener">blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的理解是，传入并缓存固定的参数，返回指定的函数。&lt;br&gt;而且是一种特别的柯里化。&lt;br&gt;柯里化是一参变多参。&lt;br&gt;偏函数是前面的参数会导致后来return的函数不一样。书面点讲，就是指定部分参数，来产生一个新的定制函数。&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
    
      <category term="JS" scheme="https://jonnzer.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>proxy</title>
    <link href="https://jonnzer.github.io/2020/06/14/proxy/"/>
    <id>https://jonnzer.github.io/2020/06/14/proxy/</id>
    <published>2020-06-14T06:50:21.000Z</published>
    <updated>2020-06-17T06:35:05.022Z</updated>
    
    <content type="html"><![CDATA[<p><code>vue</code>源码的render部分，曾用到<code>proxy</code>来代理vue的实例。</p><h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1 概念："></a>1 概念：</h3><p><code>proxy</code> 原意就有代理的意思。它是外界访问对象的一层<code>代理控制</code>，也是对访问的一种<code>改写和过滤</code>。属于一种<code>元编程</code>。</p><h3 id="2-作用："><a href="#2-作用：" class="headerlink" title="2 作用："></a>2 作用：</h3><p>可以从获取和设置两种时机去代理指定对象</p><h3 id="3-代码结构："><a href="#3-代码结构：" class="headerlink" title="3 代码结构："></a>3 代码结构：</h3><p>标准结构：</p><blockquote><p>var proxy = new Proxy (target, handler);  // target是拦截的目标  handler是拦截行为</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">    <span class="keyword">get</span>: function(target, key, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(target, key, value, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj <span class="comment">// 默认是&#123;&#125;    </span></span><br><span class="line">obj.a = <span class="number">1</span> <span class="comment">// setting a</span></span><br><span class="line">obj.a = <span class="number">2</span> <span class="comment">// setting a</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// getting a</span></span><br></pre></td></tr></table></figure><h3 id="4-要注意的点："><a href="#4-要注意的点：" class="headerlink" title="4. 要注意的点："></a>4. 要注意的点：</h3><ul><li><p>要使proxy起作用，需对proxy的实例 进行操作，而不是针对原目标对象。</p></li><li><p>与原型的应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="keyword">get</span>: function(target, property) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">35</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> _obj = <span class="built_in">Object</span>.create(proxy)</span><br><span class="line">_obj.time <span class="comment">// 35</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy对象是_obj的原型，_obj上没有time这个属性，就顺着原型链找到proxy，proxy上的任何属性都会返回35</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-proxy还支持get、set之外的api补充"><a href="#5-proxy还支持get、set之外的api补充" class="headerlink" title="5. proxy还支持get、set之外的api补充"></a>5. proxy还支持get、set之外的api补充</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">'prototype'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span>(<span class="params">target, thisBinding, args</span>) </span>&#123; <span class="comment">// proxy实例作为函数调用时触发</span></span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>&#123; <span class="comment">// proxy作为构造函数时触发</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">value</span>: args[<span class="number">1</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"></span><br><span class="line">fproxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> fproxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// &#123;value: 2&#125;</span></span><br><span class="line">fproxy.prototype === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line">fproxy.foo === <span class="string">"Hello, foo"</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get 拦截 负数索引</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">...elements</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">     <span class="keyword">get</span>: function(target, property, receiver) &#123; </span><br><span class="line">         <span class="keyword">let</span> index = <span class="built_in">Number</span>(property) <span class="comment">// -1 会作为属性传进来</span></span><br><span class="line">         <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             property = <span class="built_in">String</span>(target.length + index) <span class="comment">// property\target 是可以修改的 奇怪...</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver) <span class="comment">// Reflect is what</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> target = []</span><br><span class="line"> target.push(...elements)</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">&#125;</span><br><span class="line">arr = createArray(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line">arr[<span class="number">-1</span>] <span class="comment">// 'c'</span></span><br></pre></td></tr></table></figure><h3 id="6-属性需可配置，configuable-和-可写writable，否则proxy实例访问代理这个属性会报错-也是一条可以阻止proxy的法子"><a href="#6-属性需可配置，configuable-和-可写writable，否则proxy实例访问代理这个属性会报错-也是一条可以阻止proxy的法子" class="headerlink" title="6. 属性需可配置，configuable 和 可写writable，否则proxy实例访问代理这个属性会报错 (也是一条可以阻止proxy的法子)"></a>6. 属性需可配置，configuable 和 可写writable，否则proxy实例访问代理这个属性会报错 (也是一条可以阻止proxy的法子)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    value: <span class="number">123</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, propKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'abc'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo</span><br><span class="line"><span class="comment">// Uncaught TypeError: 'get' on proxy: property 'foo' is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected '123' but got 'abc')</span></span><br></pre></td></tr></table></figure><hr><p>引申了解：</p><ul><li>元编程的概念</li><li>proxy的get和set，与 Object.defineProperty 相比，有什么区别<ul><li>答：<a href="https://juejin.im/post/5be4f7cfe51d453339084530" target="_blank" rel="noopener">jueim</a> proxy的应用场景更多，但是define的兼容性更好</li><li>答：<a href="https://github.com/YvetteLau/Blog/issues/25" target="_blank" rel="noopener">issue</a></li><li>答：<a href="https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf" target="_blank" rel="noopener">两者实现双向绑定差异</a></li></ul></li></ul><hr><p>参考文章：<br><a href="https://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">阮一峰es6 proxy章节</a><br><a href="https://www.infoq.cn/article/es6-in-depth-proxies-and-reflect" target="_blank" rel="noopener">深入浅出es6系列</a><br><a href="https://www.infoq.cn/article/es6-in-depth-proxies-and-reflect" target="_blank" rel="noopener">segmentFault</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Meta_programming" target="_blank" rel="noopener">元编程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;vue&lt;/code&gt;源码的render部分，曾用到&lt;code&gt;proxy&lt;/code&gt;来代理vue的实例。&lt;/p&gt;
&lt;h3 id=&quot;1-概念：&quot;&gt;&lt;a href=&quot;#1-概念：&quot; class=&quot;headerlink&quot; title=&quot;1 概念：&quot;&gt;&lt;/a&gt;1 概念
      
    
    </summary>
    
    
    
      <category term="ES6" scheme="https://jonnzer.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>函数柯里化</title>
    <link href="https://jonnzer.github.io/2020/05/27/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>https://jonnzer.github.io/2020/05/27/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</id>
    <published>2020-05-27T07:12:29.000Z</published>
    <updated>2020-07-15T13:13:19.032Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1. 是什么？"></a>1. 是什么？</h3><p>柯里化是一种将使用<code>多个参数</code>的一个函数<code>转换成</code>一系列使用<code>一个参数</code>的函数的编程技术。<br>简单示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 add 函数，一次传入两个参数即可</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有一个 curry 函数可以做到柯里化</span></span><br><span class="line"><span class="keyword">var</span> addCurry = curry(add);</span><br><span class="line"></span><br><span class="line">addCurry(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 调用跟 add (1，2)是一样的</span></span><br></pre></td></tr></table></figure><h3 id="2-curry函数的编写"><a href="#2-curry函数的编写" class="headerlink" title="2. curry函数的编写"></a>2. curry函数的编写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@feature </span>普通curry函数的编写</span></span><br><span class="line"><span class="comment"> arguments 对象是内部函数的。</span></span><br><span class="line"><span class="comment"> 当调用(返回的函数)时，它会在给定环境中执行被传入的函数并给出所有参数。</span></span><br><span class="line"><span class="comment"> arguments会视为每次传的参数而定</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = fn.length;</span><br><span class="line">    args = args || []; <span class="comment">// 直到这个时候的arguments都是类数组，arguments[0] = function(a,b,c)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _args = args.slice(<span class="number">0</span>),</span><br><span class="line">            arg, i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">            arg = <span class="built_in">arguments</span>[i];</span><br><span class="line">            _args.push(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_args.length &lt; length) &#123; <span class="comment">// 这个if else是关键，让curry函数一直循环到，实参数满足形参的个数</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> curry.call(<span class="keyword">this</span>, fn, _args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, _args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = curry(<span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line">fn(<span class="string">"a"</span>, <span class="string">"b"</span>)(<span class="string">"c"</span>)</span><br><span class="line">fn(<span class="string">"a"</span>)(<span class="string">"b"</span>)(<span class="string">"c"</span>)</span><br><span class="line">fn(<span class="string">"a"</span>)(<span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面四种都会得出这样的结果： ["a", "b", "c"]</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提前返回的例子</span></span><br><span class="line"><span class="keyword">var</span> addEvent = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, type, fn, capture</span>) </span>&#123; <span class="comment">// 提前返回</span></span><br><span class="line">            el.addEventListener(type, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                fn.call(el, e);</span><br><span class="line">            &#125;, capture);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">ele, type, fn</span>) </span>&#123; <span class="comment">// 提前返回</span></span><br><span class="line">            el.attachEvent(<span class="string">'on'</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line">                fn.call(el, e);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="3-curry函数写法的引申思考"><a href="#3-curry函数写法的引申思考" class="headerlink" title="3. curry函数写法的引申思考"></a>3. curry函数写法的引申思考</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简易版，理解 fn1 中 return fn2的执行</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ ) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> k = testFn()</span><br><span class="line">    <span class="built_in">console</span>.log(k())</span><br><span class="line">    <span class="built_in">console</span>.log(k())</span><br><span class="line">    <span class="built_in">console</span>.log(k())</span><br><span class="line">    <span class="comment">// k函数表达式的执行，仅仅只有第一次会执行testFn里的for循环，其他次数都已经解析成里面return 123 的函数了</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue 识别html标签的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeMap</span>(<span class="params">tagStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> tagArr = tagStr.split(<span class="string">','</span>);</span><br><span class="line">  <span class="keyword">const</span> tagObj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> tag <span class="keyword">of</span> tagArr) &#123;</span><br><span class="line">    tagObj[tag] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">tagName</span>) </span>&#123; <span class="comment">// 此处还运用了闭包去存储tagObj，仅运行一次就缓存好tagObj，降低了遍历带来的性能消耗</span></span><br><span class="line">    <span class="keyword">return</span> !!tagObj[tagName];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isHTMLTag = makeMap(<span class="string">'div,p,span,h1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(isHTMLTag(<span class="string">'div'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="4-curry函数的特点与作用"><a href="#4-curry函数的特点与作用" class="headerlink" title="4. curry函数的特点与作用"></a>4. curry函数的特点与作用</h3><ul><li>参数复用，提前固定参数</li><li>提前返回</li></ul><hr><p>参考文章：<br><a href="https://zh.javascript.info/currying-partials" target="_blank" rel="noopener">javascript.Info</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener">冴羽github文章</a><br><a href="https://my.oschina.net/u/4400687/blog/3660259" target="_blank" rel="noopener"><code>arguments</code>和<code>function.length</code>的区别</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length" target="_blank" rel="noopener">Function.length</a><br><a href="https://github.com/YvetteLau/Step-By-Step/issues/24" target="_blank" rel="noopener">github闭包论坛</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-是什么？&quot;&gt;&lt;a href=&quot;#1-是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. 是什么？&quot;&gt;&lt;/a&gt;1. 是什么？&lt;/h3&gt;&lt;p&gt;柯里化是一种将使用&lt;code&gt;多个参数&lt;/code&gt;的一个函数&lt;code&gt;转换成&lt;/code&gt;一系列使用
      
    
    </summary>
    
    
    
      <category term="JS" scheme="https://jonnzer.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>数组常见技巧</title>
    <link href="https://jonnzer.github.io/2020/05/26/array/"/>
    <id>https://jonnzer.github.io/2020/05/26/array/</id>
    <published>2020-05-26T05:40:18.000Z</published>
    <updated>2020-07-17T09:13:39.569Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数组降维"><a href="#1-数组降维" class="headerlink" title="1. 数组降维"></a>1. 数组降维</h3><p>二维数组降维成一维数组（引自vue源码）</p><blockquote><p>利用原理：<br>(1) <code>concat</code>的属性 : 如果concat方法的参数是一个元素，该元素会被直接插入到新数组中；如果参数是一个数组，该数组的各个元素将被插入到新数组中；<br>(2) <code>apply</code>的优化：<code>Array.prototype.concat.apply</code>([], children) 等同于 [].concat(demoArr)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> demoArr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,[<span class="number">7</span>,<span class="number">8</span>],[<span class="number">22</span>,<span class="number">23</span>,<span class="number">43</span>]]</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">simpleNormalizeChildren</span> (<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.concat.apply([], children)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> children</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">simpleNormalizeChildren(demoArr)  </span><br><span class="line"><span class="comment">// result =&gt;  [1, 2, 3, 4, 5, 7, 8, 22, 23, 43]</span></span><br></pre></td></tr></table></figure><h4 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h4><p>多维数组递归降维(借助了<code>递归</code>的能力)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> children = [<span class="number">1</span>, [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]]], [<span class="number">9</span>, <span class="number">10</span>]];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleNormalizeChildren</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children[i])) &#123;</span><br><span class="line">      children = <span class="built_in">Array</span>.prototype.concat.apply([], children);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j =<span class="number">0</span>; j&lt;children.length; j++) &#123;</span><br><span class="line">        simpleNormalizeChildren(children)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br><span class="line">simpleNormalizeChildren(children); </span><br><span class="line"><span class="comment">// result =&gt;  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure><h3 id="2-数组去重"><a href="#2-数组去重" class="headerlink" title="2. 数组去重"></a>2. 数组去重</h3><p>（1） ES6 <code>set</code>方法 (Set 对象允许你存储任何类型的唯一值)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>,</span><br><span class="line"> <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"> <span class="comment">//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", &#123;&#125;, &#123;&#125;]</span></span><br></pre></td></tr></table></figure><div class="tip">  set方法无法识别重复的{}空对象</div> <p>（2）双重for循环，splice去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>; j&lt;arr.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]==arr[j])&#123;         <span class="comment">//前者等于后者的时候，splice方法删除后者</span></span><br><span class="line">                    arr.splice(j,<span class="number">1</span>);</span><br><span class="line">                    j--; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>,</span><br><span class="line">     <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="built_in">console</span>.log(unique(arr))</span><br><span class="line">    <span class="comment">//[1, "true", 15, false, undefined, NaN, NaN, "NaN", "a", &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure><div class="tip">NaN和{}没有去重，两个null直接消失了</div><p>(3) indexOf（新建了一个空数组，遍历旧数组，如果空数组里没遇到重复的遍历项，则添加） </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'type error!'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> array = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.indexOf(arr[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">            array.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>,</span><br><span class="line">           <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line">   <span class="comment">// [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure><div class="tip">NaN、{}没有去重</div><p>(4) sort排序后再去重（sort后一样的元素的会在旁边，只需与身边的对比）高性能，推荐👍</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> seen; <span class="comment">// 动态指针</span></span><br><span class="line">  <span class="comment">// 浅拷贝后 排序targetArr 排序有要求的话，需要sort传入自定义的排序函数</span></span><br><span class="line">  <span class="keyword">var</span> targetArr = <span class="built_in">Array</span>.prototype.concat.call(arr).sort() </span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="comment">// 与上一位对比 因为index为0的时候没有上一位，所以直接插入结果数组返回</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;targetArr.length; i++) &#123; </span><br><span class="line">     <span class="comment">// 这里 0转为boolean是false，!0即true</span></span><br><span class="line">    <span class="comment">// 这个if是，如果是第一位，或者，动态指针与遍历到的不一样，即是匹配到新元素</span></span><br><span class="line">    <span class="keyword">if</span> (!i || seen !== targetArr[i]) &#123;</span><br><span class="line">      result.push(targetArr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新指针</span></span><br><span class="line">    seen = targetArr[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>,</span><br><span class="line">         <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure><div class="tip">  sort方法需要注意看使用场景，特殊类型的时候，sort会有坑。</div><p>(5) underScore 思路版 （提供三个参数）这个思路杂糅上面的方法<br> <code>array</code>： 必填参数，去重目标数组<br><code>isSorted</code>: 表示目标数组是否已经排序过了，true的话，将会采用方法（4）那样的高效对比。false的话，用indexOf<br><code>iteratee</code>: 自定义对目标数组的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array, isSorted, iteratee</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">var</span> seen = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> value = array[i];</span><br><span class="line">        <span class="keyword">var</span> computed = iteratee ? iteratee(value, i, array) : value;</span><br><span class="line">        <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!i || seen !== computed) &#123;</span><br><span class="line">                res.push(value)</span><br><span class="line">            &#125;</span><br><span class="line">            seen = computed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (iteratee) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seen.indexOf(computed) === <span class="number">-1</span>) &#123;</span><br><span class="line">                seen.push(computed);</span><br><span class="line">                res.push(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res.indexOf(value) === <span class="number">-1</span>) &#123;</span><br><span class="line">            res.push(value);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(array3, <span class="literal">false</span>, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> item == <span class="string">'string'</span> ? item.toLowerCase() : item</span><br><span class="line">&#125;)); <span class="comment">// [1, "a", 2]</span></span><br></pre></td></tr></table></figure><p>(6) 利用Object的key是唯一的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + item) </span><br><span class="line">        ? <span class="literal">false</span></span><br><span class="line">        : (obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真是叹为观止，妙！妙在哪？</p><ul><li><code>array.filter</code>本身就兼职<code>遍历，过滤，返回新数组</code>于一身，干净利落</li><li>Object的<code>key确实是唯一</code>的，如果重复时候，只能是覆盖value的</li><li>filter过滤条件需要的<code>true和false</code>就由 Obj是否包含这个<code>type+value</code>为key  来决定，<br>如果之前没存进obj，可以任意设置一个value，就是三元运算符里的<code>obj[typeof item + item] = true</code></li></ul><hr><h3 id="API补充："><a href="#API补充：" class="headerlink" title="API补充："></a>API补充：</h3><ol><li><code>reduce</code></li></ol><p>升序让数组每一项都调用传入函数，可以设置初始值。<br>四个参数<br><code>Accumulator</code> (acc) (累计器)<br><code>Current Value</code> (cur) (当前值)<br><code>Current Index</code> (idx) (当前索引)<br><code>Source Array</code>(src) (源数组)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计出现次数</span></span><br><span class="line"><span class="keyword">var</span> names = [<span class="string">'Alice'</span>, <span class="string">'Bob'</span>, <span class="string">'Tiff'</span>, <span class="string">'Bruce'</span>, <span class="string">'Alice'</span>];</span><br><span class="line"><span class="comment">// allNames为Accumulator累积器，name为当前值</span></span><br><span class="line"><span class="keyword">var</span> countedNames = names.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">allNames, name</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (name <span class="keyword">in</span> allNames) &#123;</span><br><span class="line">    allNames[name]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    allNames[name] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> allNames;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="comment">// countedNames is:</span></span><br><span class="line"><span class="comment">// &#123; 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 &#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pipe = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// proxy结合reduce实现 链式调用函数封装 需是get结尾</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="comment">// value是参数 闭包缓存funcStack数组</span></span><br><span class="line">          <span class="keyword">var</span> funcStack = [];</span><br><span class="line">          <span class="keyword">var</span> oproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125; , &#123;</span><br><span class="line">              <span class="keyword">get</span> : function (pipeObject, fnName) &#123;</span><br><span class="line">                  <span class="built_in">console</span>.log(<span class="string">'fnName is:'</span> + fnName)</span><br><span class="line">                  <span class="keyword">if</span> (fnName === <span class="string">'get'</span>) &#123;</span><br><span class="line">                      <span class="keyword">return</span> funcStack.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">val, fn</span>) </span>&#123;</span><br><span class="line">                          <span class="keyword">return</span> fn(val);</span><br><span class="line">                      &#125;,value);</span><br><span class="line">                  &#125;</span><br><span class="line">                  funcStack.push(<span class="built_in">window</span>[fnName]);</span><br><span class="line">                  <span class="built_in">console</span>.log(funcStack)</span><br><span class="line">                  <span class="keyword">return</span> oproxy;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">return</span> oproxy;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> pow    = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br><span class="line">  <span class="keyword">var</span> reverseInt = <span class="function"><span class="params">n</span> =&gt;</span> n.toString().split(<span class="string">""</span>).reverse().join(<span class="string">""</span>) | <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(pipe(<span class="number">3</span>)[<span class="string">'double'</span>].pow.get);</span><br><span class="line">  <span class="comment">// pipe(3).double.pow.reverseInt.get; // 63</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p><code>slice</code><br>类数组 =&gt; 真数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 也可以写成 [].slice.call(arguments) </span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list1 = list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li><p><code>Array.from</code><br>从一个类似数组或可迭代对象创建一个新的，<code>浅拷贝</code>的数组实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike[, mapFn[, thisArg]])</span><br></pre></td></tr></table></figure><p><code>arrayLike</code>：想要转换成数组的伪数组对象或可迭代对象。比如拥有一个 length 属性和若干索引属性的任意对象和Map、set等。<br><code>mapFn</code> 可选：如果指定了该参数，新数组中的每个元素会执行该回调函数。<br><code>thisArg</code> 可选：可选参数，执行回调函数 mapFn 时 this 对象。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someNumbers = &#123; <span class="string">'0'</span>: <span class="number">10</span>, <span class="string">'1'</span>: <span class="number">15</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Array</span>.from(someNumbers, value =&gt; value * <span class="number">2</span>); <span class="comment">// =&gt; [20, 30] 这里利用了mapFn的能力</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).reduce(<span class="function">(<span class="params">sum, num</span>) =&gt;</span> sum + num);</span><br><span class="line">&#125;</span><br><span class="line">sumArguments(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// =&gt; 6 //这里利用了转化伪数组成真数组的能力</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p><code>Array.concat()</code> 不传参数的时候，是一种浅拷贝的行为</p></li><li><p><code>Array.filter(function(){})</code>  如名，filter，过滤，该方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。不改变原数组</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</span><br></pre></td></tr></table></figure><p><code>callback</code>: 用来测试数组元素的函数 return true时 保留元素 否则不保留。<br><code>index</code>: 当前处理索引<br><code>array</code>: 调用了filter的数组本身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 创建了一个新数组，该数组的元素由原数组中值大于 10 的元素组成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">element</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> element &gt;= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> filtered = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].filter(isBigEnough);</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank" rel="noopener">MDN - slice</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">MDN - reduce</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">MDN - typeof</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="noopener">MDN - Array.from</a><br><a href="https://juejin.im/post/5b4d35406fb9a04fd55ac064" target="_blank" rel="noopener">掘金 reduce</a><br><a href="https://juejin.im/post/5d66b019f265da03a715e5d7" target="_blank" rel="noopener">掘金 Array.from</a><br><a href="https://www.lagou.com/lgeduarticle/86449.html" target="_blank" rel="noopener">拉钩博文</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/27" target="_blank" rel="noopener">冴羽 Array去重 issue</a><br><a href="http://www.ruanyifeng.com/blog/2017/03/reduce_transduce.html" target="_blank" rel="noopener">阮一峰 reduce transduce 关于 函数编程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-数组降维&quot;&gt;&lt;a href=&quot;#1-数组降维&quot; class=&quot;headerlink&quot; title=&quot;1. 数组降维&quot;&gt;&lt;/a&gt;1. 数组降维&lt;/h3&gt;&lt;p&gt;二维数组降维成一维数组（引自vue源码）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;利用原理：&lt;br&gt;(1
      
    
    </summary>
    
    
    
      <category term="Array" scheme="https://jonnzer.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>vue源码分析</title>
    <link href="https://jonnzer.github.io/2020/04/27/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://jonnzer.github.io/2020/04/27/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-04-26T17:27:25.000Z</published>
    <updated>2020-07-06T05:10:49.346Z</updated>
    
    <content type="html"><![CDATA[<p>网址：<br><a href="https://jiongks.name/blog/vue-code-review/" target="_blank" rel="noopener">勾三股四</a><br><a href="https://github.com/HcySunYang/vue-design" target="_blank" rel="noopener">授之以渔</a><br><a href="https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/update.html#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">vue大概讲解</a><br><a href="https://github.com/answershuto/learnVue" target="_blank" rel="noopener">染陌电子书</a><br><a href="https://www.cnblogs.com/QH-Jimmy/p/7210363.html" target="_blank" rel="noopener">patch原理</a><br><a href="https://github.com/aooy/blog/issues/2" target="_blank" rel="noopener">victual dom diff</a><br><a href="https://www.bookstack.cn/books/5865c0921b69e6006b3145a1" target="_blank" rel="noopener">书栈网</a><br><a href="http://caibaojian.com/vue-design/art/81vue-lexical-analysis.html" target="_blank" rel="noopener">vue中的AST</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网址：&lt;br&gt;&lt;a href=&quot;https://jiongks.name/blog/vue-code-review/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;勾三股四&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/HcySun
      
    
    </summary>
    
    
    
      <category term="vue" scheme="https://jonnzer.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>面试</title>
    <link href="https://jonnzer.github.io/2020/04/12/%E9%9D%A2%E8%AF%95%E8%A6%81%E6%B1%82/"/>
    <id>https://jonnzer.github.io/2020/04/12/%E9%9D%A2%E8%AF%95%E8%A6%81%E6%B1%82/</id>
    <published>2020-04-12T09:19:35.000Z</published>
    <updated>2020-07-14T17:06:19.763Z</updated>
    
    <content type="html"><![CDATA[<p>知己知彼，百战百胜<br>实力推荐<br><a href="https://muyiy.cn/" target="_blank" rel="noopener">木易杨</a></p><p>参考链接：</p><p><a href="https://zhuanlan.zhihu.com/p/69705235" target="_blank" rel="noopener">阿里p7要求</a><br><a href="https://github.com/jawil/blog/issues/22" target="_blank" rel="noopener">阿里P6+要求</a><br><a href="https://juejin.im/post/5e5522b36fb9a07ce152c51c" target="_blank" rel="noopener">掘金1</a><br><a href="https://juejin.im/post/587dab348d6d810058d87a0a" target="_blank" rel="noopener">掘金2</a><br><a href="https://github.com/axuebin/articles/issues/39" target="_blank" rel="noopener">axuebin issue</a><br><a href="https://github.com/coffe1891/frontend-hard-mode-interview" target="_blank" rel="noopener">前端内参github</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知己知彼，百战百胜&lt;br&gt;实力推荐&lt;br&gt;&lt;a href=&quot;https://muyiy.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;木易杨&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhi
      
    
    </summary>
    
    
    
      <category term="面试" scheme="https://jonnzer.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
